/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _app_mpx_vue_type_template_id_5ef46707_isApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _app_mpx_vue_type_script_lang_ts_isApp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _app_mpx_vue_type_style_index_0_id_5ef46707_mpxStyleOptions_7B_22mid_22_3A_22mpx_app_scope_22_7D_lang_css_isApp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(299);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(205);



;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _app_mpx_vue_type_script_lang_ts_isApp__WEBPACK_IMPORTED_MODULE_1__["default"],
  _app_mpx_vue_type_template_id_5ef46707_isApp__WEBPACK_IMPORTED_MODULE_0__.render,
  _app_mpx_vue_type_template_id_5ef46707_isApp__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/app.mpx"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 2 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_template_id_5ef46707_isApp__WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_template_id_5ef46707_isApp__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_template_id_5ef46707_isApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);


/***/ }),
/* 3 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "staticRenderFns": function() { return /* binding */ staticRenderFns; }
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c("div", {
    staticClass: "app"
  }, [_c("mpx-keep-alive", [_c("router-view", {
    staticClass: "page"
  })], 1)], 1);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),
/* 4 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_script_lang_ts_isApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_script_lang_ts_isApp__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 5 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _mpxjs_web_plugin_src_runtime_base_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _mpxjs_web_plugin_src_runtime_base_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mpxjs_web_plugin_src_runtime_base_styl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27);
/* harmony import */ var vue_i18n__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17);
/* harmony import */ var vue_i18n_bridge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(21);

  

          
          
           
          vue__WEBPACK_IMPORTED_MODULE_2__["default"].use(vue_router__WEBPACK_IMPORTED_MODULE_3__["default"])
          __webpack_require__.g.getApp = function(){}
          __webpack_require__.g.getCurrentPages = function(){
            if(!__webpack_require__.g.__mpxRouter) return []
            // @ts-ignore
            return __webpack_require__.g.__mpxRouter.stack.map(item => {
            let page
            const vnode = item.vnode
            if(vnode && vnode.componentInstance) {
              page = vnode.tag.endsWith('mpx-tab-bar-container') ? vnode.componentInstance.$refs.tabBarPage : vnode.componentInstance
            }
            return page || { route: item.path.slice(1) }
          })
        }
        __webpack_require__.g.__networkTimeout = undefined
        __webpack_require__.g.__mpxGenericsMap = {}
        __webpack_require__.g.__mpxOptionsMap = {}
        __webpack_require__.g.__style = "v1"
        __webpack_require__.g.__mpxPageConfig = undefined
        __webpack_require__.g.__mpxTransRpxFn = undefined
;
            
            vue__WEBPACK_IMPORTED_MODULE_2__["default"].use(vue_i18n__WEBPACK_IMPORTED_MODULE_4__["default"] , { bridge: true })

              const i18nCfg = {"locale":"en-US"}
  i18nCfg.messages = __webpack_require__(18)
   i18nCfg.legacy = false
   const i18n = (0,vue_i18n_bridge__WEBPACK_IMPORTED_MODULE_5__.createI18n)(i18nCfg, vue_i18n__WEBPACK_IMPORTED_MODULE_4__["default"])
            vue__WEBPACK_IMPORTED_MODULE_2__["default"].use(i18n)
            _mpxjs_core__WEBPACK_IMPORTED_MODULE_6__["default"].i18n = i18n
            
  const wxsModules = {}
  __webpack_require__.g.currentModuleId = "mpx-app-scope"

           __webpack_require__.g.currentSrcMode = "wx"

          __webpack_require__.g.currentResource = "/Users/didi/Documents/Work/Code/mpx/examples/mpx-transform-web/src/app.mpx"
  /** script content **/
  __webpack_require__(124)

        const currentOption = __webpack_require__.g.__mpxOptionsMap["mpx-app-scope"]

          __webpack_require__.g.__tabBar = {"borderStyle":"black","position":"bottom","custom":false,"isShow":true,"color":"red","selectedColor":"black","backgroundColor":"white","list":[{"pagePath":"pages/index","text":"page10","iconPath":__webpack_require__(196)},{"pagePath":"pages/wxs","text":"page2","iconPath":"https://ut-static.udache.com/webx/mini-pics/pZ0qkcV-yweUQ644F5pVp.png"}]}
             vue__WEBPACK_IMPORTED_MODULE_2__["default"].observable(__webpack_require__.g.__tabBar)
             // @ts-ignore
            __webpack_require__.g.__tabBarPagesMap = {'mpx-tab-bar':(0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(197), {}),'pages/index':(0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(206), {"__mpxPageRoute":"\"pages/index\""}),'pages/wxs':()=>__webpack_require__.e(/* import() */ 1).then(__webpack_require__.bind(__webpack_require__, 302)).then(res => (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(res, {"__mpxPageRoute":"\"pages/wxs\""}))}

            /* harmony default export */ __webpack_exports__["default"] = ((0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__["default"])({
        option: currentOption,
        ctorType: "app",
        firstPage: "pages/wxs",
        outputPath: "",
        pageConfig: {},
        // @ts-ignore
        pagesMap: {'pages/wxs':(0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(285), {"__mpxBuiltIn":true}),'packageA/pages/picker':()=>__webpack_require__.e(/* import() */ 2).then(__webpack_require__.bind(__webpack_require__, 328)).then(res => (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(res, {"__mpxPageRoute":"\"packageA/pages/picker\""})),'pages/index':(0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(285), {"__mpxBuiltIn":true}),'packageA/pages/swiper':()=>Promise.all(/* import() */[__webpack_require__.e(4), __webpack_require__.e(3)]).then(__webpack_require__.bind(__webpack_require__, 353)).then(res => (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(res, {"__mpxPageRoute":"\"packageA/pages/swiper\""})),'pages/index2':()=>__webpack_require__.e(/* import() */ 5).then(__webpack_require__.bind(__webpack_require__, 372)).then(res => (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(res, {"__mpxPageRoute":"\"pages/index2\""})),'pages/other':(0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(290), {"__mpxPageRoute":"\"pages/other\""})},
        // @ts-ignore
        componentsMap: {'mpx-keep-alive':(0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(296), {"__mpxBuiltIn":true})},
        tabBarMap: {"pages/index":true,"pages/wxs":true},
        componentGenerics: {},
        genericsInfo: undefined,
        mixin: (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getWxsMixin)(wxsModules),
        hasApp: true
        ,Vue: vue__WEBPACK_IMPORTED_MODULE_2__["default"], VueRouter: vue_router__WEBPACK_IMPORTED_MODULE_3__["default"]
      }));

/***/ }),
/* 6 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ processOption; },
/* harmony export */   "getComponent": function() { return /* binding */ getComponent; },
/* harmony export */   "getWxsMixin": function() { return /* binding */ getWxsMixin; }
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _transRpxStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* eslint-disable */




function processOption ({
                                         option,
                                         ctorType,
                                         firstPage,
                                         outputPath,
                                         pageConfig,
                                         pagesMap,
                                         componentsMap,
                                         tabBarMap,
                                         componentGenerics,
                                         genericsInfo,
                                         mixin,
                                         hasApp,
                                         Vue,
                                         VueRouter
                                       }
) {
  if (ctorType === 'app') {
    // 对于app中的组件需要全局注册
    for (const componentName in componentsMap) {
      if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(componentsMap, componentName)) {
        const component = componentsMap[componentName]
        Vue.component(componentName, component)
      }
    }

    Vue.directive('animation', _animation__WEBPACK_IMPORTED_MODULE_2__["default"])

    Vue.filter('transRpxStyle', _transRpxStyle__WEBPACK_IMPORTED_MODULE_1__["default"])

    const routes = []

    for (const pagePath in pagesMap) {
      if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(pagesMap, pagePath)) {
        const page = pagesMap[pagePath]
        routes.push({
          path: '/' + pagePath,
          component: page
        })
      }
    }

    if (routes.length) {
      if (firstPage) {
        routes.push({
          path: '/',
          redirect: '/' + firstPage
        })
      }
      const webRouteConfig = __webpack_require__.g.__mpx.config.webRouteConfig
      __webpack_require__.g.__mpxRouter = option.router = new VueRouter({
        ...webRouteConfig,
        routes: routes
      })
      __webpack_require__.g.__mpxRouter.stack = []
      __webpack_require__.g.__mpxRouter.needCache = null
      __webpack_require__.g.__mpxRouter.needRemove = []
      // 处理reLaunch中传递的url并非首页时的replace逻辑
      __webpack_require__.g.__mpxRouter.beforeEach(function (to, from, next) {
        let action = __webpack_require__.g.__mpxRouter.__mpxAction
        const stack = __webpack_require__.g.__mpxRouter.stack

        // 处理人为操作
        if (!action) {
          if (stack.length > 1 && stack[stack.length - 2].path === to.path) {
            action = {
              type: 'back',
              delta: 1
            }
          } else {
            action = {
              type: 'to'
            }
          }
        }

        const pageInRoutes = routes.some(item => item.path === to.path)
        if (!pageInRoutes) {
          if (stack.length < 1) {
            if (__webpack_require__.g.__mpxRouter.app.$options.onPageNotFound) {
              // onPageNotFound，仅首次进入时生效
              __webpack_require__.g.__mpxRouter.app.$options.onPageNotFound({
                path: to.path,
                query: to.query,
                isEntryPage: true
              })
              return
            } else {
              console.warn(`[Mpx runtime warn]: the ${to.path} path does not exist in the application，will redirect to the home page path ${firstPage}`)
              return next({
                path: firstPage,
                replace: true
              })
            }
          } else {
            let methods = ''
            switch (action.type) {
              case 'to':
                methods = 'navigateTo'
                break
              case 'redirect':
                methods = 'redirectTo'
                break
              case 'back':
                methods = 'navigateBack'
                break
              case 'reLaunch':
                methods = 'reLaunch'
                break
              default:
                methods = 'navigateTo'
            }
            throw new Error(`${methods}:fail page "${to.path}" is not found`)
          }
        }

        const insertItem = {
          path: to.path
        }
        // 构建历史栈
        switch (action.type) {
          case 'to':
            stack.push(insertItem)
            __webpack_require__.g.__mpxRouter.needCache = insertItem
            break
          case 'back':
            __webpack_require__.g.__mpxRouter.needRemove = stack.splice(stack.length - action.delta, action.delta)
            break
          case 'redirect':
            __webpack_require__.g.__mpxRouter.needRemove = stack.splice(stack.length - 1, 1, insertItem)
            __webpack_require__.g.__mpxRouter.needCache = insertItem
            break
          case 'switch':
            if (!action.replaced) {
              action.replaced = true
              return next({
                path: action.path,
                replace: true
              })
            } else {
              // 将非tabBar页面remove
              let tabItem = null
              __webpack_require__.g.__mpxRouter.needRemove = stack.filter((item) => {
                if (tabBarMap[item.path.slice(1)]) {
                  tabItem = item
                  return false
                }
                return true
              })
              if (tabItem) {
                __webpack_require__.g.__mpxRouter.stack = [tabItem]
              } else {
                __webpack_require__.g.__mpxRouter.stack = [insertItem]
                __webpack_require__.g.__mpxRouter.needCache = insertItem
              }
            }
            break
          case 'reLaunch':
            if (!action.replaced) {
              action.replaced = true
              return next({
                path: action.path,
                query: {
                  reLaunchCount: action.reLaunchCount
                },
                replace: true
              })
            } else {
              __webpack_require__.g.__mpxRouter.needRemove = stack
              __webpack_require__.g.__mpxRouter.stack = [insertItem]
              __webpack_require__.g.__mpxRouter.needCache = insertItem
            }
        }
        next()
      })
      // 处理visibilitychange时触发当前活跃页面组件的onshow/onhide
      if (_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
        const errorHandler = function (args, fromVue) {
          if (__webpack_require__.g.__mpxAppCbs && __webpack_require__.g.__mpxAppCbs.error && __webpack_require__.g.__mpxAppCbs.error.length) {
            __webpack_require__.g.__mpxAppCbs.error.forEach((cb) => {
              cb.apply(null, args)
            })
          } else if (fromVue) {
            throw args[0]
          }
        }
        Vue.config.errorHandler = (...args) => {
          return errorHandler(args, true)
        }
        window.addEventListener('error', (event) => {
          return errorHandler([event.error, event])
        })
        window.addEventListener('unhandledrejection', (event) => {
          return errorHandler([event.reason, event])
        })
        document.addEventListener('visibilitychange', function () {
          const vnode = __webpack_require__.g.__mpxRouter && __webpack_require__.g.__mpxRouter.__mpxActiveVnode
          if (vnode && vnode.componentInstance) {
            const currentPage = vnode.tag.endsWith('mpx-tab-bar-container') ? vnode.componentInstance.$refs.tabBarPage : vnode.componentInstance
            if (document.hidden) {
              if (__webpack_require__.g.__mpxAppCbs && __webpack_require__.g.__mpxAppCbs.hide) {
                __webpack_require__.g.__mpxAppCbs.hide.forEach((cb) => {
                  cb()
                })
              }
              if (currentPage) {
                currentPage.mpxPageStatus = 'hide'
              }
            } else {
              if (__webpack_require__.g.__mpxAppCbs && __webpack_require__.g.__mpxAppCbs.show) {
                __webpack_require__.g.__mpxAppCbs.show.forEach((cb) => {
                  // todo 实现app.onShow参数
                  /* eslint-disable node/no-callback-literal */
                  cb({})
                })
              }
              if (currentPage) {
                currentPage.mpxPageStatus = 'show'
              }
            }
          }
        })
        // 初始化length
        __webpack_require__.g.__mpxRouter.__mpxHistoryLength = __webpack_require__.g.history.length
      }
    }

    // 注入pinia
    if (__webpack_require__.g.__mpxPinia) {
      option.pinia = __webpack_require__.g.__mpxPinia
    }
  } else {
    // 局部注册页面和组件中依赖的组件
    for (const componentName in componentsMap) {
      if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(componentsMap, componentName)) {
        const component = componentsMap[componentName]
        if (!option.components) {
          option.components = {}
        }
        option.components[componentName] = component
      }
    }

    if (genericsInfo) {
      const genericHash = genericsInfo.hash
      __webpack_require__.g.__mpxGenericsMap[genericHash] = {}
      Object.keys(genericsInfo.map).forEach((genericValue) => {
        if (componentsMap[genericValue]) {
          __webpack_require__.g.__mpxGenericsMap[genericHash][genericValue] = componentsMap[genericValue]
        } else {
          console.log(option)
          console.warn(`[Mpx runtime warn]: generic value "${genericValue}" must be
registered in parent context!`)
        }
      })
    }

    if (componentGenerics) {
      option.props = option.props || {}
      option.props.generichash = String
      Object.keys(componentGenerics).forEach((genericName) => {
        if (componentGenerics[genericName].default) {
          option.props[`generic${genericName}`] = {
            type: String,
            default: `${genericName}default`
          }
        } else {
          option.props[`generic${genericName}`] = String
        }
      })
    }

    if (ctorType === 'page') {
      option.__mpxPageConfig = Object.assign({}, __webpack_require__.g.__mpxPageConfig, pageConfig)
    }
    if (!hasApp) {
      option.directives = { animation: _animation__WEBPACK_IMPORTED_MODULE_2__["default"] }
      option.filters = { transRpxStyle: _transRpxStyle__WEBPACK_IMPORTED_MODULE_1__["default"] }
    }
  }

  if (option.mixins) {
    option.mixins.push(mixin)
  } else {
    option.mixins = [mixin]
  }

  if (outputPath) {
    option.componentPath = '/' + outputPath
  }
  return option
}

function getComponent (component, extendOptions) {
  component = component.__esModule ? component.default : component
  // eslint-disable-next-line
  if (extendOptions) Object.assign(component, extendOptions)
  return component
}

function getWxsMixin (wxsModules) {
  if (!wxsModules || !Object.keys(wxsModules).length) return {}
  return {
    created () {
      Object.keys(wxsModules).forEach((key) => {
        if (key in this) {
          console.error(`[Mpx runtime error]: The wxs module key [${key}] exist in the component/page instance already, please check and rename it!`)
        } else {
          this[key] = wxsModules[key]
        }
      })
    }
  }
}


/***/ }),
/* 7 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasOwn": function() { return /* binding */ hasOwn; },
/* harmony export */   "isBrowser": function() { return /* binding */ isBrowser; }
/* harmony export */ });
const hasOwnProperty = Object.prototype.hasOwnProperty

function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

const isBrowser = typeof window !== 'undefined'


/***/ }),
/* 8 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(style) {
  const defaultTransRpxFn = function (match, $1) {
    const rpx2vwRatio = +(100 / 750).toFixed(8)
    return '' + ($1 * rpx2vwRatio) + 'vw'
  }
  const transRpxFn = __webpack_require__.g.__mpxTransRpxFn || defaultTransRpxFn
  const parsedStyleObj = {}
  const rpxRegExpG = /\b(\d+(\.\d+)?)rpx\b/g
  const parseStyleText = (cssText) => {
    const listDelimiter = /;(?![^(]*\))/g
    const propertyDelimiter = /:(.+)/
    if (typeof cssText === 'string') {
      cssText.split(listDelimiter).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiter)
          tmp.length > 1 && (parsedStyleObj[tmp[0].trim()] = tmp[1].trim())
        }
      })
    } else if (typeof cssText === 'object') {
      if (Array.isArray(cssText)) {
        cssText.forEach(cssItem => {
          parseStyleText(cssItem)
        })
      } else {
        Object.assign(parsedStyleObj, cssText)
      }
    }
  }
  const transRpxStyleFn = (val) => {
    if (typeof val === 'string' && val.indexOf('rpx') > 0) {
      return val.replace(rpxRegExpG, transRpxFn).replace(/"/g, '')
    }
    return val
  }
  if (style) {
    style.forEach(item => {
      parseStyleText(item)
      for (const key in parsedStyleObj) {
        parsedStyleObj[key] = transRpxStyleFn(parsedStyleObj[key])
      }
    })
  }
  return parsedStyleObj
}


/***/ }),
/* 9 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(el, binding) {
  const newActions = binding && binding.value && binding.value.actions
  if (el.actions === newActions) {
    Promise.resolve().then(() => {
      Object.assign(el.style, el.lastDynamicStyle)
    })
    return
  }
  el.actions = newActions
  if (typeof el.setAnimation === 'function') {
    el.removeEventListener('transitionend', el.setAnimation, false)
    el.setAnimation = undefined
  }
  el.dynamicStyleQueue = []
  el.lastDynamicStyle = undefined
  if (Array.isArray(newActions) && newActions.length) {
    newActions.forEach((item) => {
      const property = []
      const { animates, option } = item
      // 存储动画需要改变的样式属性
      const dynamicStyle = {
        transform: ''
      }
      animates.forEach((itemAnimation) => {
        switch (itemAnimation.type) {
          case 'style': {
            const [key, value] = itemAnimation.args
            dynamicStyle[key] = value
            property.push(key)
            break
          }
          default:
            dynamicStyle.transform += `${itemAnimation.type}(${itemAnimation.args}) `
            if (!property.includes('transform')) {
              property.push('transform')
            }
        }
      })
      Object.assign(dynamicStyle, {
        transition: `${parseInt(option.duration)}ms ${option.timingFunction} ${parseInt(option.delay)}ms`,
        transitionProperty: `${property}`,
        transformOrigin: option.transformOrigin
      })
      el.dynamicStyleQueue.push(dynamicStyle)
    })
    el.setAnimation = function () {
      if (!el.dynamicStyleQueue.length) {
        el.removeEventListener('transitionend', el.setAnimation, false)
        return
      }
      const dynamicStyle = el.dynamicStyleQueue.shift()
      Object.assign(el.style, dynamicStyle)
      el.lastDynamicStyle = dynamicStyle
    }
    // 首次动画属性设置
    setTimeout(el.setAnimation, 0)
    // 在transitionend事件内设置动画样式
    el.addEventListener('transitionend', el.setAnimation, false)
  }
}


/***/ }),
/* 10 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(11);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("094763ad", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\nhtml,\nbody,\ndiv,\nspan,\napplet,\nobject,\niframe,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\np,\nblockquote,\npre,\na,\nabbr,\nacronym,\naddress,\nbig,\ncite,\ncode,\ndel,\ndfn,\nem,\nimg,\nins,\nkbd,\nq,\ns,\nsamp,\nsmall,\nstrike,\nstrong,\nsub,\nsup,\ntt,\nvar,\nb,\nu,\ni,\ncenter,\ndl,\ndt,\ndd,\nol,\nul,\nli,\nfieldset,\nform,\nlabel,\nlegend,\ntable,\ncaption,\ntbody,\ntfoot,\nthead,\ntr,\nth,\ntd,\narticle,\naside,\ncanvas,\ndetails,\nembed,\nfigure,\nfigcaption,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\noutput,\nruby,\nsection,\nsummary,\ntime,\nmark,\naudio,\nvideo {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n}\n/* HTML5 display-role reset for older browsers */\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\nsection {\n  display: block;\n}\nol,\nul {\n  list-style: none;\n}\nblockquote,\nq {\n  quotes: none;\n}\nblockquote:before,\nblockquote:after,\nq:before,\nq:after {\n  content: '';\n  content: none;\n}\ntable {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\nspan {\n  white-space: pre-line;\n}\nhtml,\nbody,\n.app {\n  width: 100%;\n  height: 100%;\n}\n.pull-down-loading {\n  position: absolute;\n  width: 100%;\n  top: -56px;\n  height: 56px;\n  line-height: 56px;\n  text-align: center;\n}\n.dot-flashing {\n  display: inline-block;\n  position: absolute;\n  top: 50%;\n  margin-top: -3px;\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  background-color: #666;\n  animation: dot-flashing 0.4s infinite steps(2, jump-none) alternate;\n  animation-delay: 0.2s;\n}\n.dot-flashing::before,\n.dot-flashing::after {\n  content: '';\n  display: inline-block;\n  position: absolute;\n  top: 0;\n}\n.dot-flashing::before {\n  left: -14px;\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  background-color: #666;\n  animation: dot-flashing 0.4s infinite steps(2, jump-none) alternate;\n  animation-delay: 0s;\n}\n.dot-flashing::after {\n  left: 14px;\n  width: 6px;\n  height: 6px;\n  border-radius: 50%;\n  background-color: #666;\n  animation: dot-flashing 0.4s infinite steps(2, jump-none) alternate;\n  animation-delay: 0.4s;\n}\n@font-face {\n  font-weight: normal;\n  font-style: normal;\n  font-family: \"weui\";\n  src: url(\"data:application/octet-stream;base64,AAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzJAKEx+AAABfAAAAFZjbWFw65cFHQAAAhwAAAJQZ2x5ZvCRR/EAAASUAAAKtGhlYWQLKIN9AAAA4AAAADZoaGVhCCwD+gAAALwAAAAkaG10eEJo//8AAAHUAAAASGxvY2EYqhW6AAAEbAAAACZtYXhwASEAVQAAARgAAAAgbmFtZeNcHtgAAA9IAAAB5nBvc3T6bLhLAAARMAAAAOYAAQAAA+gAAABaA+j/////A+kAAQAAAAAAAAAAAAAAAAAAABIAAQAAAAEAACkCj3dfDzz1AAsD6AAAAADUER9XAAAAANQRH1f//wAAA+kD6gAAAAgAAgAAAAAAAAABAAAAEgBJAAUAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQOwAZAABQAIAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABA6gHqEQPoAAAAWgPqAAAAAAABAAAAAAAAAAAAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+gAAAPoAAAD6AAAA+j//wPoAAAD6AAAAAAABQAAAAMAAAAsAAAABAAAAXQAAQAAAAAAbgADAAEAAAAsAAMACgAAAXQABABCAAAABAAEAAEAAOoR//8AAOoB//8AAAABAAQAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAAAEGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAANwAAAAAAAAAEQAA6gEAAOoBAAAAAQAA6gIAAOoCAAAAAgAA6gMAAOoDAAAAAwAA6gQAAOoEAAAABAAA6gUAAOoFAAAABQAA6gYAAOoGAAAABgAA6gcAAOoHAAAABwAA6ggAAOoIAAAACAAA6gkAAOoJAAAACQAA6goAAOoKAAAACgAA6gsAAOoLAAAACwAA6gwAAOoMAAAADAAA6g0AAOoNAAAADQAA6g4AAOoOAAAADgAA6g8AAOoPAAAADwAA6hAAAOoQAAAAEAAA6hEAAOoRAAAAEQAAAAAARgCMANIBJgF4AcQCMgJgAqgC/ANIA6YD/gROBKAE9AVaAAAAAgAAAAADrwOtABQAKQAAASIHBgcGFBcWFxYyNzY3NjQnJicmAyInJicmNDc2NzYyFxYXFhQHBgcGAfV4Z2Q7PDw7ZGfwZmQ7PDw7ZGZ4bl5bNjc3Nlte215bNjc3NlteA608O2Rn8GdjOzw8O2Nn8GdkOzz8rzc1W17bXlw1Nzc1XF7bXls1NwAAAAACAAAAAAOzA7MAFwAtAAABIgcGBwYVFBcWFxYzMjc2NzY1NCcmJyYTBwYiLwEmNjsBETQ2OwEyFhURMzIWAe52Z2Q7PT07ZGd2fGpmOz4+O2ZpIXYOKA52Dg0XXQsHJgcLXRcNA7M+O2ZqfHZnZDs9PTtkZ3Z9aWY7Pv3wmhISmhIaARcICwsI/ukaAAMAAAAAA+UD5QAXACMALAAAASIHBgcGFRQXFhcWMzI3Njc2NTQnJicmAxQrASI1AzQ7ATIHJyImNDYyFhQGAe6Ecm9BRERBb3KEiXZxQkREQnF1aQIxAwgCQgMBIxIZGSQZGQPkREJxdomEcm9BRERBb3KEinVxQkT9HQICAWICAjEZIxkZIxkAAAAAAwAAAAADsQPkABsAKgAzAAABBgcGBwYHBjcRFBcWFxYXNjc2NzY1ESQXJicmBzMyFhUDFAYrASInAzQ2EyImNDYyFhQGAfVBQTg7LDt/IEc+bF5sbF1tPUj+2KhQQVVvNAQGDAMCJgUBCwYeDxYWHhUVA+QPEg4SDhIpCv6tj3VkST4dHT5JZHWPAVNeNRkSGPwGBP7GAgMFAToEBv5AFR8VFR8VAAAAAgAAAAADsQPkABkALgAAAQYHBgc2BREUFxYXFhc2NzY3NjURJBcmJyYTAQYvASY/ATYyHwEWNjclNjIfARYB9VVVQk+v/tFHPmxebGxdbT1I/tGvT0JVo/7VBASKAwMSAQUBcQEFAgESAgUBEQQD4xMYEhk3YP6sjnVlSD8cHD9IZXWOAVRgNxkSGP62/tkDA48EBBkCAVYCAQHlAQIQBAAAAAACAAAAAAPkA+QAFwAtAAABIgcGBwYVFBcWFxYzMjc2NzY1NCcmJyYTAQYiLwEmPwE2Mh8BFjI3ATYyHwEWAe6Ecm9BQ0NCbnODiXVxQkREQnF1kf6gAQUBowMDFgEFAYUCBQEBQwIFARUEA+NEQnF1iYNzbkJDQ0FvcoSJdXFCRP6j/qUBAagEBR4CAWYBAQENAgIVBAAAAAQAAAAAA68DrQAUACkAPwBDAAABIgcGBwYUFxYXFjI3Njc2NCcmJyYDIicmJyY0NzY3NjIXFhcWFAcGBwYTBQ4BLwEmBg8BBhYfARYyNwE+ASYiFzAfAQH1eGdkOzw8O2Rn8GZkOzw8O2RmeG5eWzY3NzZbXtteWzY3NzZbXmn+9gYSBmAGDwUDBQEGfQUQBgElBQELEBUBAQOtPDtkZ/BnYzs8PDtjZ/BnZDs8/K83NVte215cNTc3NVxe215bNTcCJt0FAQVJBQIGBAcRBoAGBQEhBQ8LBAEBAAABAAAAAAO7AzoAFwAAEy4BPwE+AR8BFjY3ATYWFycWFAcBBiInPQoGBwUHGgzLDCELAh0LHwsNCgr9uQoeCgGzCyEOCw0HCZMJAQoBvgkCCg0LHQv9sQsKAAAAAAIAAAAAA+UD5gAXACwAAAEiBwYHBhUUFxYXFjMyNzY3NjU0JyYnJhMHBi8BJicmNRM0NjsBMhYVExceAQHvhHJvQUNDQm5zg4l1cUJEREJxdVcQAwT6AwIEEAMCKwIDDsUCAQPlREJxdYmDc25CQ0NBb3KEiXVxQkT9VhwEAncCAgMGAXoCAwMC/q2FAgQAAAQAAAAAA68DrQADABgALQAzAAABMB8BAyIHBgcGFBcWFxYyNzY3NjQnJicmAyInJicmNDc2NzYyFxYXFhQHBgcGAyMVMzUjAuUBAfJ4Z2Q7PDw7ZGfwZmQ7PDw7ZGZ4bl5bNjc3Nlte215bNjc3NltemyT92QKDAQEBLDw7ZGfwZ2M7PDw7Y2fwZ2Q7PPyvNzVbXtteXDU3NzVcXtteWzU3AjH9JAAAAAMAAAAAA+QD5AAXACcAMAAAASIHBgcGFRQXFhcWMzI3Njc2NTQnJicmAzMyFhUDFAYrASImNQM0NhMiJjQ2MhYUBgHuhHJvQUNDQm5zg4l1cUJEREJxdZ42BAYMAwInAwMMBh8PFhYeFhYD40RCcXWJg3NuQkNDQW9yhIl1cUJE/vYGBf7AAgMDAgFABQb+NhYfFhYfFgAABAAAAAADwAPAAAgAEgAoAD0AAAEyNjQmIgYUFhcjFTMRIxUzNSMDIgcGBwYVFBYXFjMyNzY3NjU0Jy4BAyInJicmNDc2NzYyFxYXFhQHBgcGAfQYISEwISFRjzk5yTorhG5rPT99am+DdmhlPD4+PMyFbV5bNTc3NVte2l5bNTc3NVteAqAiLyIiLyI5Hf7EHBwCsT89a26Ed8w8Pj48ZWh2g29qffyjNzVbXtpeWzU3NzVbXtpeWzU3AAADAAAAAAOoA6gACwAgADUAAAEHJwcXBxc3FzcnNwMiBwYHBhQXFhcWMjc2NzY0JyYnJgMiJyYnJjQ3Njc2MhcWFxYUBwYHBgKOmpocmpocmpocmpq2dmZiOjs7OmJm7GZiOjs7OmJmdmtdWTQ2NjRZXdZdWTQ2NjRZXQKqmpocmpocmpocmpoBGTs6YmbsZmI6Ozs6YmbsZmI6O/zCNjRZXdZdWTQ2NjRZXdZdWTQ2AAMAAAAAA+kD6gAaAC8AMAAAAQYHBiMiJyYnJjQ3Njc2MhcWFxYVFAcGBwEHATI3Njc2NCcmJyYiBwYHBhQXFhcWMwKONUBCR21dWjU3NzVaXdpdWzU2GBcrASM5/eBXS0grKysrSEuuSkkqLCwqSUpXASMrFxg2NVtd2l1aNTc3NVpdbUdCQDX+3jkBGSsrSEuuSkkqLCwqSUquS0grKwAC//8AAAPoA+gAFAAwAAABIgcGBwYQFxYXFiA3Njc2ECcmJyYTFg4BIi8BBwYuATQ/AScmPgEWHwE3Nh4BBg8BAfSIdHFDRERDcXQBEHRxQ0REQ3F0SQoBFBsKoqgKGxMKqKIKARQbCqKoChsUAQqoA+hEQ3F0/vB0cUNERENxdAEQdHFDRP1jChsTCqiiCgEUGwqiqAobFAEKqKIKARQbCqIAAAIAAAAAA+QD5AAXADQAAAEiBwYHBhUUFxYXFjMyNzY3NjU0JyYnJhMUBiMFFxYUDwEGLwEuAT8BNh8BFhQPAQUyFh0BAe6Ecm9BQ0NCbnODiXVxQkREQnF1fwQC/pGDAQEVAwTsAgEC7AQEFAIBhAFwAgMD40RCcXWJg3NuQkNDQW9yhIl1cUJE/fYCAwuVAgQCFAQE0AIFAtEEBBQCBQGVCwMDJwAAAAUAAAAAA9QD0wAjACcANwBHAEgAAAERFAYjISImNREjIiY9ATQ2MyE1NDYzITIWHQEhMhYdARQGIyERIREHIgYVERQWOwEyNjURNCYjISIGFREUFjsBMjY1ETQmKwEDeyYb/XYbJkMJDQ0JAQYZEgEvExkBBgkNDQn9CQJc0QkNDQktCQ0NCf7sCQ0NCS0JDQ0JLQMi/TQbJiYbAswMCiwJDS4SGRkSLg0JLAoM/UwCtGsNCf5NCQ0NCQGzCQ0NCf5NCQ0NCQGzCQ0AAAAAEADGAAEAAAAAAAEABAAAAAEAAAAAAAIABwAEAAEAAAAAAAMABAALAAEAAAAAAAQABAAPAAEAAAAAAAUACwATAAEAAAAAAAYABAAeAAEAAAAAAAoAKwAiAAEAAAAAAAsAEwBNAAMAAQQJAAEACABgAAMAAQQJAAIADgBoAAMAAQQJAAMACAB2AAMAAQQJAAQACAB+AAMAAQQJAAUAFgCGAAMAAQQJAAYACACcAAMAAQQJAAoAVgCkAAMAAQQJAAsAJgD6d2V1aVJlZ3VsYXJ3ZXVpd2V1aVZlcnNpb24gMS4wd2V1aUdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAHcAZQB1AGkAUgBlAGcAdQBsAGEAcgB3AGUAdQBpAHcAZQB1AGkAVgBlAHIAcwBpAG8AbgAgADEALgAwAHcAZQB1AGkARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETAAZjaXJjbGUIZG93bmxvYWQEaW5mbwxzYWZlX3N1Y2Nlc3MJc2FmZV93YXJuB3N1Y2Nlc3MOc3VjY2Vzcy1jaXJjbGURc3VjY2Vzcy1uby1jaXJjbGUHd2FpdGluZw53YWl0aW5nLWNpcmNsZQR3YXJuC2luZm8tY2lyY2xlBmNhbmNlbAZzZWFyY2gFY2xlYXIEYmFjawZkZWxldGUAAAAA\") format('truetype');\n}\n.mpx-root-view {\n  display: inline;\n  line-height: normal;\n}\n@-moz-keyframes dot-flashing {\n0% {\n    background-color: #666;\n}\n50% {\n    background-color: #bbb;\n}\n100% {\n    background-color: #ddd;\n}\n}\n@-webkit-keyframes dot-flashing {\n0% {\n    background-color: #666;\n}\n50% {\n    background-color: #bbb;\n}\n100% {\n    background-color: #ddd;\n}\n}\n@-o-keyframes dot-flashing {\n0% {\n    background-color: #666;\n}\n50% {\n    background-color: #bbb;\n}\n100% {\n    background-color: #ddd;\n}\n}\n@keyframes dot-flashing {\n0% {\n    background-color: #666;\n}\n50% {\n    background-color: #bbb;\n}\n100% {\n    background-color: #ddd;\n}\n}\n", ""]);

// exports


/***/ }),
/* 12 */
/***/ (function(module) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 13 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ addStylesClient; }
/* harmony export */ });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 14 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ listToStyles; }
/* harmony export */ });
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 15 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": function() { return /* binding */ EffectScope; },
/* harmony export */   "computed": function() { return /* binding */ computed; },
/* harmony export */   "customRef": function() { return /* binding */ customRef; },
/* harmony export */   "default": function() { return /* binding */ Vue; },
/* harmony export */   "defineAsyncComponent": function() { return /* binding */ defineAsyncComponent; },
/* harmony export */   "defineComponent": function() { return /* binding */ defineComponent; },
/* harmony export */   "del": function() { return /* binding */ del; },
/* harmony export */   "effectScope": function() { return /* binding */ effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* binding */ getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* binding */ getCurrentScope; },
/* harmony export */   "h": function() { return /* binding */ h; },
/* harmony export */   "inject": function() { return /* binding */ inject; },
/* harmony export */   "isProxy": function() { return /* binding */ isProxy; },
/* harmony export */   "isReactive": function() { return /* binding */ isReactive; },
/* harmony export */   "isReadonly": function() { return /* binding */ isReadonly; },
/* harmony export */   "isRef": function() { return /* binding */ isRef; },
/* harmony export */   "isShallow": function() { return /* binding */ isShallow; },
/* harmony export */   "markRaw": function() { return /* binding */ markRaw; },
/* harmony export */   "mergeDefaults": function() { return /* binding */ mergeDefaults; },
/* harmony export */   "nextTick": function() { return /* binding */ nextTick; },
/* harmony export */   "onActivated": function() { return /* binding */ onActivated; },
/* harmony export */   "onBeforeMount": function() { return /* binding */ onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* binding */ onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* binding */ onBeforeUpdate; },
/* harmony export */   "onDeactivated": function() { return /* binding */ onDeactivated; },
/* harmony export */   "onErrorCaptured": function() { return /* binding */ onErrorCaptured; },
/* harmony export */   "onMounted": function() { return /* binding */ onMounted; },
/* harmony export */   "onRenderTracked": function() { return /* binding */ onRenderTracked; },
/* harmony export */   "onRenderTriggered": function() { return /* binding */ onRenderTriggered; },
/* harmony export */   "onScopeDispose": function() { return /* binding */ onScopeDispose; },
/* harmony export */   "onServerPrefetch": function() { return /* binding */ onServerPrefetch; },
/* harmony export */   "onUnmounted": function() { return /* binding */ onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* binding */ onUpdated; },
/* harmony export */   "provide": function() { return /* binding */ provide; },
/* harmony export */   "proxyRefs": function() { return /* binding */ proxyRefs; },
/* harmony export */   "reactive": function() { return /* binding */ reactive; },
/* harmony export */   "readonly": function() { return /* binding */ readonly; },
/* harmony export */   "ref": function() { return /* binding */ ref$1; },
/* harmony export */   "set": function() { return /* binding */ set; },
/* harmony export */   "shallowReactive": function() { return /* binding */ shallowReactive; },
/* harmony export */   "shallowReadonly": function() { return /* binding */ shallowReadonly; },
/* harmony export */   "shallowRef": function() { return /* binding */ shallowRef; },
/* harmony export */   "toRaw": function() { return /* binding */ toRaw; },
/* harmony export */   "toRef": function() { return /* binding */ toRef; },
/* harmony export */   "toRefs": function() { return /* binding */ toRefs; },
/* harmony export */   "triggerRef": function() { return /* binding */ triggerRef; },
/* harmony export */   "unref": function() { return /* binding */ unref; },
/* harmony export */   "useAttrs": function() { return /* binding */ useAttrs; },
/* harmony export */   "useCssModule": function() { return /* binding */ useCssModule; },
/* harmony export */   "useCssVars": function() { return /* binding */ useCssVars; },
/* harmony export */   "useListeners": function() { return /* binding */ useListeners; },
/* harmony export */   "useSlots": function() { return /* binding */ useSlots; },
/* harmony export */   "version": function() { return /* binding */ version; },
/* harmony export */   "watch": function() { return /* binding */ watch; },
/* harmony export */   "watchEffect": function() { return /* binding */ watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* binding */ watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* binding */ watchSyncEffect; }
/* harmony export */ });
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var emptyObject = Object.freeze({});
var isArray = Array.isArray;
// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef(v) {
    return v === undefined || v === null;
}
function isDef(v) {
    return v !== undefined && v !== null;
}
function isTrue(v) {
    return v === true;
}
function isFalse(v) {
    return v === false;
}
/**
 * Check if value is primitive.
 */
function isPrimitive(value) {
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        // $flow-disable-line
        typeof value === 'symbol' ||
        typeof value === 'boolean');
}
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * Quick object check - this is primarily used to tell
 * objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;
function toRawType(value) {
    return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
}
function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
}
function isPromise(val) {
    return (isDef(val) &&
        typeof val.then === 'function' &&
        typeof val.catch === 'function');
}
/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
    return val == null
        ? ''
        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
            ? JSON.stringify(val, null, 2)
            : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };
}
/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */
function remove$2(arr, item) {
    var len = arr.length;
    if (len) {
        // fast path for the only / last item
        if (item === arr[len - 1]) {
            arr.length = len - 1;
            return;
        }
        var index = arr.indexOf(item);
        if (index > -1) {
            return arr.splice(index, 1);
        }
    }
}
/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
        var hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });
});
/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */
/* istanbul ignore next */
function polyfillBind(fn, ctx) {
    function boundFn(a) {
        var l = arguments.length;
        return l
            ? l > 1
                ? fn.apply(ctx, arguments)
                : fn.call(ctx, a)
            : fn.call(ctx);
    }
    boundFn._length = fn.length;
    return boundFn;
}
function nativeBind(fn, ctx) {
    return fn.bind(ctx);
}
// @ts-expect-error bind cannot be `undefined`
var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
        ret[i] = list[i + start];
    }
    return ret;
}
/**
 * Mix properties into target object.
 */
function extend(to, _from) {
    for (var key in _from) {
        to[key] = _from[key];
    }
    return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend(res, arr[i]);
        }
    }
    return res;
}
/* eslint-disable no-unused-vars */
/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop(a, b, c) { }
/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };
/* eslint-enable no-unused-vars */
/**
 * Return the same value.
 */
var identity = function (_) { return _; };
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
    if (a === b)
        return true;
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
        try {
            var isArrayA = Array.isArray(a);
            var isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every(function (e, i) {
                        return looseEqual(e, b[i]);
                    }));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                var keysA = Object.keys(a);
                var keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(function (key) {
                        return looseEqual(a[key], b[key]);
                    }));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val))
            return i;
    }
    return -1;
}
/**
 * Ensure a function is called only once.
 */
function once(fn) {
    var called = false;
    return function () {
        if (!called) {
            called = true;
            fn.apply(this, arguments);
        }
    };
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
function hasChanged(x, y) {
    if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
    }
    else {
        return x === x || y === y;
    }
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch',
    'renderTracked',
    'renderTriggered'
];

var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),
    /**
     * Whether to suppress warnings.
     */
    silent: false,
    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',
    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',
    /**
     * Whether to record perf
     */
    performance: false,
    /**
     * Error handler for watcher errors
     */
    errorHandler: null,
    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,
    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],
    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),
    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,
    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,
    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,
    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,
    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,
    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,
    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,
    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
};

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5f;
}
/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
    });
}
/**
 * Parse simple path.
 */
var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
function parsePath(path) {
    if (bailRE.test(path)) {
        return;
    }
    var segments = path.split('.');
    return function (obj) {
        for (var i = 0; i < segments.length; i++) {
            if (!obj)
                return;
            obj = obj[segments[i]];
        }
        return obj;
    };
}

// can we use __proto__?
var hasProto = '__proto__' in {};
// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);
// Firefox has a "watch" function on Object.prototype...
// @ts-expect-error firebox support
var nativeWatch = {}.watch;
var supportsPassive = false;
if (inBrowser) {
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', {
            get: function () {
                /* istanbul ignore next */
                supportsPassive = true;
            }
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener('test-passive', null, opts);
    }
    catch (e) { }
}
// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
    if (_isServer === undefined) {
        /* istanbul ignore if */
        if (!inBrowser && typeof __webpack_require__.g !== 'undefined') {
            // detect presence of vue-server-renderer and avoid
            // Webpack shimming the process
            _isServer =
                __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
        }
        else {
            _isServer = false;
        }
    }
    return _isServer;
};
// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */
function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}
var hasSymbol = typeof Symbol !== 'undefined' &&
    isNative(Symbol) &&
    typeof Reflect !== 'undefined' &&
    isNative(Reflect.ownKeys);
var _Set; // $flow-disable-line
/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
}
else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /** @class */ (function () {
        function Set() {
            this.set = Object.create(null);
        }
        Set.prototype.has = function (key) {
            return this.set[key] === true;
        };
        Set.prototype.add = function (key) {
            this.set[key] = true;
        };
        Set.prototype.clear = function () {
            this.set = Object.create(null);
        };
        return Set;
    }());
}

var currentInstance = null;
/**
 * This is exposed for compatibility with v3 (e.g. some functions in VueUse
 * relies on it). Do not use this internally, just use `currentInstance`.
 *
 * @internal this function needs manual type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function getCurrentInstance() {
    return currentInstance && { proxy: currentInstance };
}
/**
 * @internal
 */
function setCurrentInstance(vm) {
    if (vm === void 0) { vm = null; }
    if (!vm)
        currentInstance && currentInstance._scope.off();
    currentInstance = vm;
    vm && vm._scope.on();
}

/**
 * @internal
 */
var VNode = /** @class */ (function () {
    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
    }
    Object.defineProperty(VNode.prototype, "child", {
        // DEPRECATED: alias for componentInstance for backwards compat.
        /* istanbul ignore next */
        get: function () {
            return this.componentInstance;
        },
        enumerable: false,
        configurable: true
    });
    return VNode;
}());
var createEmptyVNode = function (text) {
    if (text === void 0) { text = ''; }
    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
};
function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
}
// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, 
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var uid$2 = 0;
var pendingCleanupDeps = [];
var cleanupDeps = function () {
    for (var i = 0; i < pendingCleanupDeps.length; i++) {
        var dep = pendingCleanupDeps[i];
        dep.subs = dep.subs.filter(function (s) { return s; });
        dep._pending = false;
    }
    pendingCleanupDeps.length = 0;
};
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 * @internal
 */
var Dep = /** @class */ (function () {
    function Dep() {
        // pending subs cleanup
        this._pending = false;
        this.id = uid$2++;
        this.subs = [];
    }
    Dep.prototype.addSub = function (sub) {
        this.subs.push(sub);
    };
    Dep.prototype.removeSub = function (sub) {
        // #12696 deps with massive amount of subscribers are extremely slow to
        // clean up in Chromium
        // to workaround this, we unset the sub for now, and clear them on
        // next scheduler flush.
        this.subs[this.subs.indexOf(sub)] = null;
        if (!this._pending) {
            this._pending = true;
            pendingCleanupDeps.push(this);
        }
    };
    Dep.prototype.depend = function (info) {
        if (Dep.target) {
            Dep.target.addDep(this);
            if ( true && info && Dep.target.onTrack) {
                Dep.target.onTrack(__assign({ effect: Dep.target }, info));
            }
        }
    };
    Dep.prototype.notify = function (info) {
        // stabilize the subscriber list first
        var subs = this.subs.filter(function (s) { return s; });
        if ( true && !config.async) {
            // subs aren't sorted in scheduler if not running async
            // we need to sort them now to make sure they fire in correct
            // order
            subs.sort(function (a, b) { return a.id - b.id; });
        }
        for (var i = 0, l = subs.length; i < l; i++) {
            var sub = subs[i];
            if ( true && info) {
                sub.onTrigger &&
                    sub.onTrigger(__assign({ effect: subs[i] }, info));
            }
            sub.update();
        }
    };
    return Dep;
}());
// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];
function pushTarget(target) {
    targetStack.push(target);
    Dep.target = target;
}
function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */
var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);
var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                inserted = args.slice(2);
                break;
        }
        if (inserted)
            ob.observeArray(inserted);
        // notify change
        if (true) {
            ob.dep.notify({
                type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
                target: this,
                key: method
            });
        }
        else {}
        return result;
    });
});

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
var NO_INIITIAL_VALUE = {};
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;
function toggleObserving(value) {
    shouldObserve = value;
}
// ssr mock dep
var mockDep = {
    notify: noop,
    depend: noop,
    addSub: noop,
    removeSub: noop
};
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = /** @class */ (function () {
    function Observer(value, shallow, mock) {
        if (shallow === void 0) { shallow = false; }
        if (mock === void 0) { mock = false; }
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        // this.value = value
        this.dep = mock ? mockDep : new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (isArray(value)) {
            if (!mock) {
                if (hasProto) {
                    value.__proto__ = arrayMethods;
                    /* eslint-enable no-proto */
                }
                else {
                    for (var i = 0, l = arrayKeys.length; i < l; i++) {
                        var key = arrayKeys[i];
                        def(value, key, arrayMethods[key]);
                    }
                }
            }
            if (!shallow) {
                this.observeArray(value);
            }
        }
        else {
            /**
             * Walk through all properties and convert them into
             * getter/setters. This method should only be called when
             * value type is Object.
             */
            var keys = Object.keys(value);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);
            }
        }
    }
    /**
     * Observe a list of Array items.
     */
    Observer.prototype.observeArray = function (value) {
        for (var i = 0, l = value.length; i < l; i++) {
            observe(value[i], false, this.mock);
        }
    };
    return Observer;
}());
// helpers
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, shallow, ssrMockReactivity) {
    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        return value.__ob__;
    }
    if (shouldObserve &&
        (ssrMockReactivity || !isServerRendering()) &&
        (isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value.__v_skip /* ReactiveFlags.SKIP */ &&
        !isRef(value) &&
        !(value instanceof VNode)) {
        return new Observer(value, shallow, ssrMockReactivity);
    }
}
/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow, mock) {
    var dep = new Dep();
    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return;
    }
    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) &&
        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {
        val = obj[key];
    }
    var childOb = !shallow && observe(val, false, mock);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            var value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                if (true) {
                    dep.depend({
                        target: obj,
                        type: "get" /* TrackOpTypes.GET */,
                        key: key
                    });
                }
                else {}
                if (childOb) {
                    childOb.dep.depend();
                    if (isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return isRef(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
            var value = getter ? getter.call(obj) : val;
            if (!hasChanged(value, newVal)) {
                return;
            }
            if ( true && customSetter) {
                customSetter();
            }
            if (setter) {
                setter.call(obj, newVal);
            }
            else if (getter) {
                // #7981: for accessor properties without setter
                return;
            }
            else if (!shallow && isRef(value) && !isRef(newVal)) {
                value.value = newVal;
                return;
            }
            else {
                val = newVal;
            }
            childOb = !shallow && observe(newVal, false, mock);
            if (true) {
                dep.notify({
                    type: "set" /* TriggerOpTypes.SET */,
                    target: obj,
                    key: key,
                    newValue: newVal,
                    oldValue: value
                });
            }
            else {}
        }
    });
    return dep;
}
function set(target, key, val) {
    if ( true && (isUndef(target) || isPrimitive(target))) {
        warn("Cannot set reactive property on undefined, null, or primitive value: ".concat(target));
    }
    if (isReadonly(target)) {
         true && warn("Set operation on key \"".concat(key, "\" failed: target is readonly."));
        return;
    }
    var ob = target.__ob__;
    if (isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        // when mocking for SSR, array methods are not hijacked
        if (ob && !ob.shallow && ob.mock) {
            observe(val, false, true);
        }
        return val;
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val;
    }
    if (target._isVue || (ob && ob.vmCount)) {
         true &&
            warn('Avoid adding reactive properties to a Vue instance or its root $data ' +
                'at runtime - declare it upfront in the data option.');
        return val;
    }
    if (!ob) {
        target[key] = val;
        return val;
    }
    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
    if (true) {
        ob.dep.notify({
            type: "add" /* TriggerOpTypes.ADD */,
            target: target,
            key: key,
            newValue: val,
            oldValue: undefined
        });
    }
    else {}
    return val;
}
function del(target, key) {
    if ( true && (isUndef(target) || isPrimitive(target))) {
        warn("Cannot delete reactive property on undefined, null, or primitive value: ".concat(target));
    }
    if (isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1);
        return;
    }
    var ob = target.__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
         true &&
            warn('Avoid deleting properties on a Vue instance or its root $data ' +
                '- just set it to null.');
        return;
    }
    if (isReadonly(target)) {
         true &&
            warn("Delete operation on key \"".concat(key, "\" failed: target is readonly."));
        return;
    }
    if (!hasOwn(target, key)) {
        return;
    }
    delete target[key];
    if (!ob) {
        return;
    }
    if (true) {
        ob.dep.notify({
            type: "delete" /* TriggerOpTypes.DELETE */,
            target: target,
            key: key
        });
    }
    else {}
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
            e.__ob__.dep.depend();
        }
        if (isArray(e)) {
            dependArray(e);
        }
    }
}

function reactive(target) {
    makeReactive(target, false);
    return target;
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    makeReactive(target, true);
    def(target, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    return target;
}
function makeReactive(target, shallow) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (!isReadonly(target)) {
        if (true) {
            if (isArray(target)) {
                warn("Avoid using Array as root value for ".concat(shallow ? "shallowReactive()" : "reactive()", " as it cannot be tracked in watch() or watchEffect(). Use ").concat(shallow ? "shallowRef()" : "ref()", " instead. This is a Vue-2-only limitation."));
            }
            var existingOb = target && target.__ob__;
            if (existingOb && existingOb.shallow !== shallow) {
                warn("Target is already a ".concat(existingOb.shallow ? "" : "non-", "shallow reactive object, and cannot be converted to ").concat(shallow ? "" : "non-", "shallow."));
            }
        }
        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);
        if ( true && !ob) {
            if (target == null || isPrimitive(target)) {
                warn("value cannot be made reactive: ".concat(String(target)));
            }
            if (isCollectionType(target)) {
                warn("Vue 2 does not support reactive collection types such as Map or Set.");
            }
        }
    }
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);
    }
    return !!(value && value.__ob__);
}
function isShallow(value) {
    return !!(value && value.__v_isShallow);
}
function isReadonly(value) {
    return !!(value && value.__v_isReadonly);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    var raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    // non-extensible objects won't be observed anyway
    if (Object.isExtensible(value)) {
        def(value, "__v_skip" /* ReactiveFlags.SKIP */, true);
    }
    return value;
}
/**
 * @internal
 */
function isCollectionType(value) {
    var type = toRawType(value);
    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');
}

/**
 * @internal
 */
var RefFlag = "__v_isRef";
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref$1(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    var ref = {};
    def(ref, RefFlag, true);
    def(ref, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, shallow);
    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));
    return ref;
}
function triggerRef(ref) {
    if ( true && !ref.dep) {
        warn("received object is not a triggerable ref.");
    }
    if (true) {
        ref.dep &&
            ref.dep.notify({
                type: "set" /* TriggerOpTypes.SET */,
                target: ref,
                key: 'value'
            });
    }
    else {}
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
function proxyRefs(objectWithRefs) {
    if (isReactive(objectWithRefs)) {
        return objectWithRefs;
    }
    var proxy = {};
    var keys = Object.keys(objectWithRefs);
    for (var i = 0; i < keys.length; i++) {
        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);
    }
    return proxy;
}
function proxyWithRefUnwrap(target, source, key) {
    Object.defineProperty(target, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = source[key];
            if (isRef(val)) {
                return val.value;
            }
            else {
                var ob = val && val.__ob__;
                if (ob)
                    ob.dep.depend();
                return val;
            }
        },
        set: function (value) {
            var oldValue = source[key];
            if (isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
            }
            else {
                source[key] = value;
            }
        }
    });
}
function customRef(factory) {
    var dep = new Dep();
    var _a = factory(function () {
        if (true) {
            dep.depend({
                target: ref,
                type: "get" /* TrackOpTypes.GET */,
                key: 'value'
            });
        }
        else {}
    }, function () {
        if (true) {
            dep.notify({
                target: ref,
                type: "set" /* TriggerOpTypes.SET */,
                key: 'value'
            });
        }
        else {}
    }), get = _a.get, set = _a.set;
    var ref = {
        get value() {
            return get();
        },
        set value(newVal) {
            set(newVal);
        }
    };
    def(ref, RefFlag, true);
    return ref;
}
function toRefs(object) {
    if ( true && !isReactive(object)) {
        warn("toRefs() expects a reactive object but received a plain one.");
    }
    var ret = isArray(object) ? new Array(object.length) : {};
    for (var key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
function toRef(object, key, defaultValue) {
    var val = object[key];
    if (isRef(val)) {
        return val;
    }
    var ref = {
        get value() {
            var val = object[key];
            return val === undefined ? defaultValue : val;
        },
        set value(newVal) {
            object[key] = newVal;
        }
    };
    def(ref, RefFlag, true);
    return ref;
}

var rawToReadonlyFlag = "__v_rawToReadonly";
var rawToShallowReadonlyFlag = "__v_rawToShallowReadonly";
function readonly(target) {
    return createReadonly(target, false);
}
function createReadonly(target, shallow) {
    if (!isPlainObject(target)) {
        if (true) {
            if (isArray(target)) {
                warn("Vue 2 does not support readonly arrays.");
            }
            else if (isCollectionType(target)) {
                warn("Vue 2 does not support readonly collection types such as Map or Set.");
            }
            else {
                warn("value cannot be made readonly: ".concat(typeof target));
            }
        }
        return target;
    }
    if ( true && !Object.isExtensible(target)) {
        warn("Vue 2 does not support creating readonly proxy for non-extensible object.");
    }
    // already a readonly object
    if (isReadonly(target)) {
        return target;
    }
    // already has a readonly proxy
    var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
    var existingProxy = target[existingFlag];
    if (existingProxy) {
        return existingProxy;
    }
    var proxy = Object.create(Object.getPrototypeOf(target));
    def(target, existingFlag, proxy);
    def(proxy, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, true);
    def(proxy, "__v_raw" /* ReactiveFlags.RAW */, target);
    if (isRef(target)) {
        def(proxy, RefFlag, true);
    }
    if (shallow || isShallow(target)) {
        def(proxy, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    }
    var keys = Object.keys(target);
    for (var i = 0; i < keys.length; i++) {
        defineReadonlyProperty(proxy, target, keys[i], shallow);
    }
    return proxy;
}
function defineReadonlyProperty(proxy, target, key, shallow) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = target[key];
            return shallow || !isPlainObject(val) ? val : readonly(val);
        },
        set: function () {
             true &&
                warn("Set operation on key \"".concat(key, "\" failed: target is readonly."));
        }
    });
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReadonly(target, true);
}

function computed(getterOrOptions, debugOptions) {
    var getter;
    var setter;
    var onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter =  true
            ? function () {
                warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    var watcher = isServerRendering()
        ? null
        : new Watcher(currentInstance, getter, noop, { lazy: true });
    if ( true && watcher && debugOptions) {
        watcher.onTrack = debugOptions.onTrack;
        watcher.onTrigger = debugOptions.onTrigger;
    }
    var ref = {
        // some libs rely on the presence effect for checking computed refs
        // from normal refs, but the implementation doesn't matter
        effect: watcher,
        get value() {
            if (watcher) {
                if (watcher.dirty) {
                    watcher.evaluate();
                }
                if (Dep.target) {
                    if ( true && Dep.target.onTrack) {
                        Dep.target.onTrack({
                            effect: Dep.target,
                            target: ref,
                            type: "get" /* TrackOpTypes.GET */,
                            key: 'value'
                        });
                    }
                    watcher.depend();
                }
                return watcher.value;
            }
            else {
                return getter();
            }
        },
        set value(newVal) {
            setter(newVal);
        }
    };
    def(ref, RefFlag, true);
    def(ref, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, onlyGetter);
    return ref;
}

var WATCHER = "watcher";
var WATCHER_CB = "".concat(WATCHER, " callback");
var WATCHER_GETTER = "".concat(WATCHER, " getter");
var WATCHER_CLEANUP = "".concat(WATCHER, " cleanup");
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, ( true
        ? __assign(__assign({}, options), { flush: 'post' }) : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, ( true
        ? __assign(__assign({}, options), { flush: 'sync' }) : 0));
}
// initial value for watchers to trigger on undefined initial values
var INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if ( true && typeof cb !== 'function') {
        warn("`watch(fn, options?)` signature has been moved to a separate API. " +
            "Use `watchEffect(fn, options?)` instead. `watch` now only " +
            "supports `watch(source, cb, options?) signature.");
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, _a) {
    var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;
    if ( true && !cb) {
        if (immediate !== undefined) {
            warn("watch() \"immediate\" option is only respected when using the " +
                "watch(source, callback, options?) signature.");
        }
        if (deep !== undefined) {
            warn("watch() \"deep\" option is only respected when using the " +
                "watch(source, callback, options?) signature.");
        }
    }
    var warnInvalidSource = function (s) {
        warn("Invalid watch source: ".concat(s, ". A watch source can only be a getter/effect ") +
            "function, a ref, a reactive object, or an array of these types.");
    };
    var instance = currentInstance;
    var call = function (fn, type, args) {
        if (args === void 0) { args = null; }
        return invokeWithErrorHandling(fn, null, args, instance, type);
    };
    var getter;
    var forceTrigger = false;
    var isMultiSource = false;
    if (isRef(source)) {
        getter = function () { return source.value; };
        forceTrigger = isShallow(source);
    }
    else if (isReactive(source)) {
        getter = function () {
            source.__ob__.dep.depend();
            return source;
        };
        deep = true;
    }
    else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });
        getter = function () {
            return source.map(function (s) {
                if (isRef(s)) {
                    return s.value;
                }
                else if (isReactive(s)) {
                    return traverse(s);
                }
                else if (isFunction(s)) {
                    return call(s, WATCHER_GETTER);
                }
                else {
                     true && warnInvalidSource(s);
                }
            });
        };
    }
    else if (isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = function () { return call(source, WATCHER_GETTER); };
        }
        else {
            // no cb -> simple effect
            getter = function () {
                if (instance && instance._isDestroyed) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return call(source, WATCHER, [onCleanup]);
            };
        }
    }
    else {
        getter = noop;
         true && warnInvalidSource(source);
    }
    if (cb && deep) {
        var baseGetter_1 = getter;
        getter = function () { return traverse(baseGetter_1()); };
    }
    var cleanup;
    var onCleanup = function (fn) {
        cleanup = watcher.onStop = function () {
            call(fn, WATCHER_CLEANUP);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isServerRendering()) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = noop;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            call(cb, WATCHER_CB, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return noop;
    }
    var watcher = new Watcher(currentInstance, getter, noop, {
        lazy: true
    });
    watcher.noRecurse = !cb;
    var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    // overwrite default run
    watcher.run = function () {
        if (!watcher.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            var newValue = watcher.get();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some(function (v, i) {
                        return hasChanged(v, oldValue[i]);
                    })
                    : hasChanged(newValue, oldValue))) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                call(cb, WATCHER_CB, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            watcher.get();
        }
    };
    if (flush === 'sync') {
        watcher.update = watcher.run;
    }
    else if (flush === 'post') {
        watcher.post = true;
        watcher.update = function () { return queueWatcher(watcher); };
    }
    else {
        // pre
        watcher.update = function () {
            if (instance && instance === currentInstance && !instance._isMounted) {
                // pre-watcher triggered before
                var buffer = instance._preWatchers || (instance._preWatchers = []);
                if (buffer.indexOf(watcher) < 0)
                    buffer.push(watcher);
            }
            else {
                queueWatcher(watcher);
            }
        };
    }
    if (true) {
        watcher.onTrack = onTrack;
        watcher.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            watcher.run();
        }
        else {
            oldValue = watcher.get();
        }
    }
    else if (flush === 'post' && instance) {
        instance.$once('hook:mounted', function () { return watcher.get(); });
    }
    else {
        watcher.get();
    }
    return function () {
        watcher.teardown();
    };
}

var activeEffectScope;
var EffectScope = /** @class */ (function () {
    function EffectScope(detached) {
        if (detached === void 0) { detached = false; }
        this.detached = detached;
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    EffectScope.prototype.run = function (fn) {
        if (this.active) {
            var currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else if (true) {
            warn("cannot run an inactive effect scope.");
        }
    };
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    EffectScope.prototype.on = function () {
        activeEffectScope = this;
    };
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    EffectScope.prototype.off = function () {
        activeEffectScope = this.parent;
    };
    EffectScope.prototype.stop = function (fromParent) {
        if (this.active) {
            var i = void 0, l = void 0;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].teardown();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (!this.detached && this.parent && !fromParent) {
                // optimized O(1) removal
                var last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = undefined;
            this.active = false;
        }
    };
    return EffectScope;
}());
function effectScope(detached) {
    return new EffectScope(detached);
}
/**
 * @internal
 */
function recordEffectScope(effect, scope) {
    if (scope === void 0) { scope = activeEffectScope; }
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if (true) {
        warn("onScopeDispose() is called when there is no active effect scope" +
            " to be associated with.");
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if (true) {
            warn("provide() can only be used inside setup().");
        }
    }
    else {
        // TS doesn't allow symbol as index type
        resolveProvided(currentInstance)[key] = value;
    }
}
function resolveProvided(vm) {
    // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.
    var existing = vm._provided;
    var parentProvides = vm.$parent && vm.$parent._provided;
    if (parentProvides === existing) {
        return (vm._provided = Object.create(parentProvides));
    }
    else {
        return existing;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory) {
    if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    var instance = currentInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        var provides = instance.$parent && instance.$parent._provided;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction(defaultValue)
                ? defaultValue.call(instance)
                : defaultValue;
        }
        else if (true) {
            warn("injection \"".concat(String(key), "\" not found."));
        }
    }
    else if (true) {
        warn("inject() can only be used inside setup() or functional components.");
    }
}

var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
        name: name,
        once: once,
        capture: capture,
        passive: passive
    };
});
function createFnInvoker(fns, vm) {
    function invoker() {
        var fns = invoker.fns;
        if (isArray(fns)) {
            var cloned = fns.slice();
            for (var i = 0; i < cloned.length; i++) {
                invokeWithErrorHandling(cloned[i], null, arguments, vm, "v-on handler");
            }
        }
        else {
            // return handler return value for single handlers
            return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
        }
    }
    invoker.fns = fns;
    return invoker;
}
function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
    var name, cur, old, event;
    for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
             true &&
                warn("Invalid handler for event \"".concat(event.name, "\": got ") + String(cur), vm);
        }
        else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
        }
        else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
        }
    }
    for (name in oldOn) {
        if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove(event.name, oldOn[name], event.capture);
        }
    }
}

function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
        def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];
    function wrappedHook() {
        hook.apply(this, arguments);
        // important: remove merged hook to ensure it's called only once
        // and prevent memory leak
        remove$2(invoker.fns, wrappedHook);
    }
    if (isUndef(oldHook)) {
        // no existing hook
        invoker = createFnInvoker([wrappedHook]);
    }
    else {
        /* istanbul ignore if */
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
            // already a merged invoker
            invoker = oldHook;
            invoker.fns.push(wrappedHook);
        }
        else {
            // existing plain hook
            invoker = createFnInvoker([oldHook, wrappedHook]);
        }
    }
    invoker.merged = true;
    def[hookKey] = invoker;
}

function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
        return;
    }
    var res = {};
    var attrs = data.attrs, props = data.props;
    if (isDef(attrs) || isDef(props)) {
        for (var key in propOptions) {
            var altKey = hyphenate(key);
            if (true) {
                var keyInLowerCase = key.toLowerCase();
                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                    tip("Prop \"".concat(keyInLowerCase, "\" is passed to component ") +
                        "".concat(formatComponentName(
                        // @ts-expect-error tag is string
                        tag || Ctor), ", but the declared prop name is") +
                        " \"".concat(key, "\". ") +
                        "Note that HTML attributes are case-insensitive and camelCased " +
                        "props need to use their kebab-case equivalents when using in-DOM " +
                        "templates. You should probably use \"".concat(altKey, "\" instead of \"").concat(key, "\"."));
                }
            }
            checkProp(res, props, key, altKey, true) ||
                checkProp(res, attrs, key, altKey, false);
        }
    }
    return res;
}
function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
        if (hasOwn(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
                delete hash[key];
            }
            return true;
        }
        else if (hasOwn(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
                delete hash[altKey];
            }
            return true;
        }
    }
    return false;
}

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
        if (isArray(children[i])) {
            return Array.prototype.concat.apply([], children);
        }
    }
    return children;
}
// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
    return isPrimitive(children)
        ? [createTextVNode(children)]
        : isArray(children)
            ? normalizeArrayChildren(children)
            : undefined;
}
function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean')
            continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (isArray(c)) {
            if (c.length > 0) {
                c = normalizeArrayChildren(c, "".concat(nestedIndex || '', "_").concat(i));
                // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                    res[lastIndex] = createTextVNode(last.text + c[0].text);
                    c.shift();
                }
                res.push.apply(res, c);
            }
        }
        else if (isPrimitive(c)) {
            if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
            }
            else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
            }
        }
        else {
            if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
            }
            else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
                    isDef(c.tag) &&
                    isUndef(c.key) &&
                    isDef(nestedIndex)) {
                    c.key = "__vlist".concat(nestedIndex, "_").concat(i, "__");
                }
                res.push(c);
            }
        }
    }
    return res;
}

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
    var ret = null, i, l, keys, key;
    if (isArray(val) || typeof val === 'string') {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render(val[i], i);
        }
    }
    else if (typeof val === 'number') {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
            ret[i] = render(i + 1, i);
        }
    }
    else if (isObject(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
            ret = [];
            var iterator = val[Symbol.iterator]();
            var result = iterator.next();
            while (!result.done) {
                ret.push(render(result.value, ret.length));
                result = iterator.next();
            }
        }
        else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                ret[i] = render(val[key], key, i);
            }
        }
    }
    if (!isDef(ret)) {
        ret = [];
    }
    ret._isVList = true;
    return ret;
}

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallbackRender, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
        // scoped slot
        props = props || {};
        if (bindObject) {
            if ( true && !isObject(bindObject)) {
                warn('slot v-bind without argument expects an Object', this);
            }
            props = extend(extend({}, bindObject), props);
        }
        nodes =
            scopedSlotFn(props) ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    else {
        nodes =
            this.$slots[name] ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    var target = props && props.slot;
    if (target) {
        return this.$createElement('template', { slot: target }, nodes);
    }
    else {
        return nodes;
    }
}

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
}

function isKeyNotMatch(expect, actual) {
    if (isArray(expect)) {
        return expect.indexOf(actual) === -1;
    }
    else {
        return expect !== actual;
    }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
    }
    else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    }
    else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key;
    }
    return eventKeyCode === undefined;
}

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
        if (!isObject(value)) {
             true &&
                warn('v-bind without argument expects an Object or Array value', this);
        }
        else {
            if (isArray(value)) {
                value = toObject(value);
            }
            var hash = void 0;
            var _loop_1 = function (key) {
                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                    hash = data;
                }
                else {
                    var type = data.attrs && data.attrs.type;
                    hash =
                        asProp || config.mustUseProp(tag, type, key)
                            ? data.domProps || (data.domProps = {})
                            : data.attrs || (data.attrs = {});
                }
                var camelizedKey = camelize(key);
                var hyphenatedKey = hyphenate(key);
                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                    hash[key] = value[key];
                    if (isSync) {
                        var on = data.on || (data.on = {});
                        on["update:".concat(key)] = function ($event) {
                            value[key] = $event;
                        };
                    }
                }
            };
            for (var key in value) {
                _loop_1(key);
            }
        }
    }
    return data;
}

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
        return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates
    );
    markStatic(tree, "__static__".concat(index), false);
    return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
    markStatic(tree, "__once__".concat(index).concat(key ? "_".concat(key) : ""), true);
    return tree;
}
function markStatic(tree, key, isOnce) {
    if (isArray(tree)) {
        for (var i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], "".concat(key, "_").concat(i), isOnce);
            }
        }
    }
    else {
        markStaticNode(tree, key, isOnce);
    }
}
function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
}

function bindObjectListeners(data, value) {
    if (value) {
        if (!isPlainObject(value)) {
             true && warn('v-on without argument expects an Object value', this);
        }
        else {
            var on = (data.on = data.on ? extend({}, data.on) : {});
            for (var key in value) {
                var existing = on[key];
                var ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
            }
        }
    }
    return data;
}

function resolveScopedSlots(fns, res, 
// the following are added in 2.6
hasDynamicKeys, contentHashKey) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
        var slot = fns[i];
        if (isArray(slot)) {
            resolveScopedSlots(slot, res, hasDynamicKeys);
        }
        else if (slot) {
            // marker for reverse proxying v-slot without scope on this.$slots
            // @ts-expect-error
            if (slot.proxy) {
                // @ts-expect-error
                slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
        }
    }
    if (contentHashKey) {
        res.$key = contentHashKey;
    }
    return res;
}

// helper to process dynamic keys for dynamic arguments in v-bind and v-on.
function bindDynamicKeys(baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
        var key = values[i];
        if (typeof key === 'string' && key) {
            baseObj[values[i]] = values[i + 1];
        }
        else if ( true && key !== '' && key !== null) {
            // null is a special value for explicitly removing a binding
            warn("Invalid value for dynamic directive argument (expected string or null): ".concat(key), this);
        }
    }
    return baseObj;
}
// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
}

function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
    if (!children || !children.length) {
        return {};
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
        var child = children[i];
        var data = child.data;
        // remove slot attribute if the node is resolved as a Vue slot node
        if (data && data.attrs && data.attrs.slot) {
            delete data.attrs.slot;
        }
        // named slots should only be respected if the vnode was rendered in the
        // same context.
        if ((child.context === context || child.fnContext === context) &&
            data &&
            data.slot != null) {
            var name_1 = data.slot;
            var slot = slots[name_1] || (slots[name_1] = []);
            if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
            }
            else {
                slot.push(child);
            }
        }
        else {
            (slots.default || (slots.default = [])).push(child);
        }
    }
    // ignore slots that contains only whitespace
    for (var name_2 in slots) {
        if (slots[name_2].every(isWhitespace)) {
            delete slots[name_2];
        }
    }
    return slots;
}
function isWhitespace(node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' ';
}

function isAsyncPlaceholder(node) {
    // @ts-expect-error not really boolean type
    return node.isComment && node.asyncFactory;
}

function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
    var key = scopedSlots && scopedSlots.$key;
    if (!scopedSlots) {
        res = {};
    }
    else if (scopedSlots._normalized) {
        // fast path 1: child component re-render only, parent did not change
        return scopedSlots._normalized;
    }
    else if (isStable &&
        prevScopedSlots &&
        prevScopedSlots !== emptyObject &&
        key === prevScopedSlots.$key &&
        !hasNormalSlots &&
        !prevScopedSlots.$hasNormal) {
        // fast path 2: stable scoped slots w/ no normal slots to proxy,
        // only need to normalize once
        return prevScopedSlots;
    }
    else {
        res = {};
        for (var key_1 in scopedSlots) {
            if (scopedSlots[key_1] && key_1[0] !== '$') {
                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);
            }
        }
    }
    // expose normal slots on scopedSlots
    for (var key_2 in normalSlots) {
        if (!(key_2 in res)) {
            res[key_2] = proxyNormalSlot(normalSlots, key_2);
        }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res;
}
function normalizeScopedSlot(vm, normalSlots, key, fn) {
    var normalized = function () {
        var cur = currentInstance;
        setCurrentInstance(vm);
        var res = arguments.length ? fn.apply(null, arguments) : fn({});
        res =
            res && typeof res === 'object' && !isArray(res)
                ? [res] // single vnode
                : normalizeChildren(res);
        var vnode = res && res[0];
        setCurrentInstance(cur);
        return res &&
            (!vnode ||
                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391
            ? undefined
            : res;
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
        });
    }
    return normalized;
}
function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; };
}

function initSetup(vm) {
    var options = vm.$options;
    var setup = options.setup;
    if (setup) {
        var ctx = (vm._setupContext = createSetupContext(vm));
        setCurrentInstance(vm);
        pushTarget();
        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, "setup");
        popTarget();
        setCurrentInstance();
        if (isFunction(setupResult)) {
            // render function
            // @ts-ignore
            options.render = setupResult;
        }
        else if (isObject(setupResult)) {
            // bindings
            if ( true && setupResult instanceof VNode) {
                warn("setup() should not return VNodes directly - " +
                    "return a render function instead.");
            }
            vm._setupState = setupResult;
            // __sfc indicates compiled bindings from <script setup>
            if (!setupResult.__sfc) {
                for (var key in setupResult) {
                    if (!isReserved(key)) {
                        proxyWithRefUnwrap(vm, setupResult, key);
                    }
                    else if (true) {
                        warn("Avoid using variables that start with _ or $ in setup().");
                    }
                }
            }
            else {
                // exposed for compiled render fn
                var proxy = (vm._setupProxy = {});
                for (var key in setupResult) {
                    if (key !== '__sfc') {
                        proxyWithRefUnwrap(proxy, setupResult, key);
                    }
                }
            }
        }
        else if ( true && setupResult !== undefined) {
            warn("setup() should return an object. Received: ".concat(setupResult === null ? 'null' : typeof setupResult));
        }
    }
}
function createSetupContext(vm) {
    var exposeCalled = false;
    return {
        get attrs() {
            if (!vm._attrsProxy) {
                var proxy = (vm._attrsProxy = {});
                def(proxy, '_v_attr_proxy', true);
                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');
            }
            return vm._attrsProxy;
        },
        get listeners() {
            if (!vm._listenersProxy) {
                var proxy = (vm._listenersProxy = {});
                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');
            }
            return vm._listenersProxy;
        },
        get slots() {
            return initSlotsProxy(vm);
        },
        emit: bind(vm.$emit, vm),
        expose: function (exposed) {
            if (true) {
                if (exposeCalled) {
                    warn("expose() should be called only once per setup().", vm);
                }
                exposeCalled = true;
            }
            if (exposed) {
                Object.keys(exposed).forEach(function (key) {
                    return proxyWithRefUnwrap(vm, exposed, key);
                });
            }
        }
    };
}
function syncSetupProxy(to, from, prev, instance, type) {
    var changed = false;
    for (var key in from) {
        if (!(key in to)) {
            changed = true;
            defineProxyAttr(to, key, instance, type);
        }
        else if (from[key] !== prev[key]) {
            changed = true;
        }
    }
    for (var key in to) {
        if (!(key in from)) {
            changed = true;
            delete to[key];
        }
    }
    return changed;
}
function defineProxyAttr(proxy, key, instance, type) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            return instance[type][key];
        }
    });
}
function initSlotsProxy(vm) {
    if (!vm._slotsProxy) {
        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);
    }
    return vm._slotsProxy;
}
function syncSetupSlots(to, from) {
    for (var key in from) {
        to[key] = from[key];
    }
    for (var key in to) {
        if (!(key in from)) {
            delete to[key];
        }
    }
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useSlots() {
    return getContext().slots;
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useAttrs() {
    return getContext().attrs;
}
/**
 * Vue 2 only
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useListeners() {
    return getContext().listeners;
}
function getContext() {
    if ( true && !currentInstance) {
        warn("useContext() called without active instance.");
    }
    var vm = currentInstance;
    return vm._setupContext || (vm._setupContext = createSetupContext(vm));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    var props = isArray(raw)
        ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})
        : raw;
    for (var key in defaults) {
        var opt = props[key];
        if (opt) {
            if (isArray(opt) || isFunction(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if (true) {
            warn("props default key \"".concat(key, "\" has no corresponding declaration."));
        }
    }
    return props;
}

function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = parentVnode
        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)
        : emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    // @ts-expect-error
    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    // @ts-expect-error
    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };
    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;
    /* istanbul ignore else */
    if (true) {
        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, function () {
            !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
        }, true);
        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
            !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
        }, true);
    }
    else {}
}
var currentRenderingInstance = null;
function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);
    Vue.prototype.$nextTick = function (fn) {
        return nextTick(fn, this);
    };
    Vue.prototype._render = function () {
        var vm = this;
        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;
        if (_parentVnode && vm._isMounted) {
            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
            if (vm._slotsProxy) {
                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
            }
        }
        // set parent vnode. this allows render functions to have access
        // to the data on the placeholder node.
        vm.$vnode = _parentVnode;
        // render self
        var vnode;
        try {
            // There's no need to maintain a stack because all render fns are called
            // separately from one another. Nested component's render fns are called
            // when parent component is patched.
            setCurrentInstance(vm);
            currentRenderingInstance = vm;
            vnode = render.call(vm._renderProxy, vm.$createElement);
        }
        catch (e) {
            handleError(e, vm, "render");
            // return error render result,
            // or previous vnode to prevent render error causing blank component
            /* istanbul ignore else */
            if ( true && vm.$options.renderError) {
                try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                }
                catch (e) {
                    handleError(e, vm, "renderError");
                    vnode = vm._vnode;
                }
            }
            else {
                vnode = vm._vnode;
            }
        }
        finally {
            currentRenderingInstance = null;
            setCurrentInstance();
        }
        // if the returned array contains only a single node, allow it
        if (isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
        }
        // return empty vnode in case the render function errored out
        if (!(vnode instanceof VNode)) {
            if ( true && isArray(vnode)) {
                warn('Multiple root nodes returned from render function. Render function ' +
                    'should return a single root node.', vm);
            }
            vnode = createEmptyVNode();
        }
        // set parent
        vnode.parent = _parentVnode;
        return vnode;
    };
}

function ensureCtor(comp, base) {
    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
}
function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp;
    }
    if (isDef(factory.resolved)) {
        return factory.resolved;
    }
    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        // already pending
        factory.owners.push(owner);
    }
    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp;
    }
    if (owner && !isDef(factory.owners)) {
        var owners_1 = (factory.owners = [owner]);
        var sync_1 = true;
        var timerLoading_1 = null;
        var timerTimeout_1 = null;
        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });
        var forceRender_1 = function (renderCompleted) {
            for (var i = 0, l = owners_1.length; i < l; i++) {
                owners_1[i].$forceUpdate();
            }
            if (renderCompleted) {
                owners_1.length = 0;
                if (timerLoading_1 !== null) {
                    clearTimeout(timerLoading_1);
                    timerLoading_1 = null;
                }
                if (timerTimeout_1 !== null) {
                    clearTimeout(timerTimeout_1);
                    timerTimeout_1 = null;
                }
            }
        };
        var resolve = once(function (res) {
            // cache resolved
            factory.resolved = ensureCtor(res, baseCtor);
            // invoke callbacks only if this is not a synchronous resolve
            // (async resolves are shimmed as synchronous during SSR)
            if (!sync_1) {
                forceRender_1(true);
            }
            else {
                owners_1.length = 0;
            }
        });
        var reject_1 = once(function (reason) {
             true &&
                warn("Failed to resolve async component: ".concat(String(factory)) +
                    (reason ? "\nReason: ".concat(reason) : ''));
            if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender_1(true);
            }
        });
        var res_1 = factory(resolve, reject_1);
        if (isObject(res_1)) {
            if (isPromise(res_1)) {
                // () => Promise
                if (isUndef(factory.resolved)) {
                    res_1.then(resolve, reject_1);
                }
            }
            else if (isPromise(res_1.component)) {
                res_1.component.then(resolve, reject_1);
                if (isDef(res_1.error)) {
                    factory.errorComp = ensureCtor(res_1.error, baseCtor);
                }
                if (isDef(res_1.loading)) {
                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);
                    if (res_1.delay === 0) {
                        factory.loading = true;
                    }
                    else {
                        // @ts-expect-error NodeJS timeout type
                        timerLoading_1 = setTimeout(function () {
                            timerLoading_1 = null;
                            if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                factory.loading = true;
                                forceRender_1(false);
                            }
                        }, res_1.delay || 200);
                    }
                }
                if (isDef(res_1.timeout)) {
                    // @ts-expect-error NodeJS timeout type
                    timerTimeout_1 = setTimeout(function () {
                        timerTimeout_1 = null;
                        if (isUndef(factory.resolved)) {
                            reject_1( true ? "timeout (".concat(res_1.timeout, "ms)") : 0);
                        }
                    }, res_1.timeout);
                }
            }
        }
        sync_1 = false;
        // return in case resolved synchronously
        return factory.loading ? factory.loadingComp : factory.resolved;
    }
}

function getFirstComponentChild(children) {
    if (isArray(children)) {
        for (var i = 0; i < children.length; i++) {
            var c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
            }
        }
    }
}

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;
// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
         true &&
            warn("Avoid using observed data object as vnode data: ".concat(JSON.stringify(data), "\n") + 'Always create fresh vnode data objects in each render!', context);
        return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
        tag = data.is;
    }
    if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode();
    }
    // warn against non-primitive key
    if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
        warn('Avoid using non-primitive value as key, ' +
            'use string/number value instead.', context);
    }
    // support single function children as default scoped slot
    if (isArray(children) && isFunction(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
    }
    else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
        var Ctor = void 0;
        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
        if (config.isReservedTag(tag)) {
            // platform built-in elements
            if ( true &&
                isDef(data) &&
                isDef(data.nativeOn) &&
                data.tag !== 'component') {
                warn("The .native modifier for v-on is only valid on components but it was used on <".concat(tag, ">."), context);
            }
            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
        }
        else if ((!data || !data.pre) &&
            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag);
        }
        else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(tag, data, children, undefined, undefined, context);
        }
    }
    else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children);
    }
    if (isArray(vnode)) {
        return vnode;
    }
    else if (isDef(vnode)) {
        if (isDef(ns))
            applyNS(vnode, ns);
        if (isDef(data))
            registerDeepBindings(data);
        return vnode;
    }
    else {
        return createEmptyVNode();
    }
}
function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
        // use default namespace inside foreignObject
        ns = undefined;
        force = true;
    }
    if (isDef(vnode.children)) {
        for (var i = 0, l = vnode.children.length; i < l; i++) {
            var child = vnode.children[i];
            if (isDef(child.tag) &&
                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
                applyNS(child, ns, force);
            }
        }
    }
}
// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings(data) {
    if (isObject(data.style)) {
        traverse(data.style);
    }
    if (isObject(data.class)) {
        traverse(data.class);
    }
}

/**
 * @internal this function needs manual public type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function h(type, props, children) {
    if (!currentInstance) {
         true &&
            warn("globally imported h() can only be invoked when there is an active " +
                "component instance, e.g. synchronously in a component's render or setup function.");
    }
    return createElement$1(currentInstance, type, props, children, 2, true);
}

function handleError(err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
        if (vm) {
            var cur = vm;
            while ((cur = cur.$parent)) {
                var hooks = cur.$options.errorCaptured;
                if (hooks) {
                    for (var i = 0; i < hooks.length; i++) {
                        try {
                            var capture = hooks[i].call(cur, err, vm, info) === false;
                            if (capture)
                                return;
                        }
                        catch (e) {
                            globalHandleError(e, cur, 'errorCaptured hook');
                        }
                    }
                }
            }
        }
        globalHandleError(err, vm, info);
    }
    finally {
        popTarget();
    }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
    var res;
    try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise(res) && !res._handled) {
            res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
            res._handled = true;
        }
    }
    catch (e) {
        handleError(e, vm, info);
    }
    return res;
}
function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
        try {
            return config.errorHandler.call(null, err, vm, info);
        }
        catch (e) {
            // if the user intentionally throws the original error in the handler,
            // do not log it twice
            if (e !== err) {
                logError(e, null, 'config.errorHandler');
            }
        }
    }
    logError(err, vm, info);
}
function logError(err, vm, info) {
    if (true) {
        warn("Error in ".concat(info, ": \"").concat(err.toString(), "\""), vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
        console.error(err);
    }
    else {
        throw err;
    }
}

/* globals MutationObserver */
var isUsingMicroTask = false;
var callbacks = [];
var pending = false;
function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
        copies[i]();
    }
}
// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;
// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p_1 = Promise.resolve();
    timerFunc = function () {
        p_1.then(flushCallbacks);
        // In problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS)
            setTimeout(noop);
    };
    isUsingMicroTask = true;
}
else if (!isIE &&
    typeof MutationObserver !== 'undefined' &&
    (isNative(MutationObserver) ||
        // PhantomJS and iOS 7.x
        MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter_1 = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode_1 = document.createTextNode(String(counter_1));
    observer.observe(textNode_1, {
        characterData: true
    });
    timerFunc = function () {
        counter_1 = (counter_1 + 1) % 2;
        textNode_1.data = String(counter_1);
    };
    isUsingMicroTask = true;
}
else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
        setImmediate(flushCallbacks);
    };
}
else {
    // Fallback to setTimeout.
    timerFunc = function () {
        setTimeout(flushCallbacks, 0);
    };
}
/**
 * @internal
 */
function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
        if (cb) {
            try {
                cb.call(ctx);
            }
            catch (e) {
                handleError(e, ctx, 'nextTick');
            }
        }
        else if (_resolve) {
            _resolve(ctx);
        }
    });
    if (!pending) {
        pending = true;
        timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
            _resolve = resolve;
        });
    }
}

function useCssModule(name) {
    if (name === void 0) { name = '$style'; }
    /* istanbul ignore else */
    {
        if (!currentInstance) {
             true && warn("useCssModule must be called inside setup()");
            return emptyObject;
        }
        var mod = currentInstance[name];
        if (!mod) {
             true &&
                warn("Current instance does not have CSS module named \"".concat(name, "\"."));
            return emptyObject;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    if (!inBrowser && !false)
        return;
    var instance = currentInstance;
    if (!instance) {
         true &&
            warn("useCssVars is called without current active component instance.");
        return;
    }
    watchPostEffect(function () {
        var el = instance.$el;
        var vars = getter(instance, instance._setupProxy);
        if (el && el.nodeType === 1) {
            var style = el.style;
            for (var key in vars) {
                style.setProperty("--".concat(key), vars[key]);
            }
        }
    });
}

/**
 * v3-compatible async component API.
 * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts
 * because it relies on existing manual types
 */
function defineAsyncComponent(source) {
    if (isFunction(source)) {
        source = { loader: source };
    }
    var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out
    _b = source.suspensible, // undefined = never times out
    suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true
    userOnError = source.onError;
    if ( true && suspensible) {
        warn("The suspensiblbe option for async components is not supported in Vue2. It is ignored.");
    }
    var pendingRequest = null;
    var retries = 0;
    var retry = function () {
        retries++;
        pendingRequest = null;
        return load();
    };
    var load = function () {
        var thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(function (err) {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise(function (resolve, reject) {
                            var userRetry = function () { return resolve(retry()); };
                            var userFail = function () { return reject(err); };
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then(function (comp) {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if ( true && !comp) {
                        warn("Async component loader resolved to undefined. " +
                            "If you are using retry(), make sure to return its return value.");
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if ( true && comp && !isObject(comp) && !isFunction(comp)) {
                        throw new Error("Invalid async component load result: ".concat(comp));
                    }
                    return comp;
                })));
    };
    return function () {
        var component = load();
        return {
            component: component,
            delay: delay,
            timeout: timeout,
            error: errorComponent,
            loading: loadingComponent
        };
    };
}

function createLifeCycle(hookName) {
    return function (fn, target) {
        if (target === void 0) { target = currentInstance; }
        if (!target) {
             true &&
                warn("".concat(formatName(hookName), " is called when there is no active component instance to be ") +
                    "associated with. " +
                    "Lifecycle injection APIs can only be used during execution of setup().");
            return;
        }
        return injectHook(target, hookName, fn);
    };
}
function formatName(name) {
    if (name === 'beforeDestroy') {
        name = 'beforeUnmount';
    }
    else if (name === 'destroyed') {
        name = 'unmounted';
    }
    return "on".concat(name[0].toUpperCase() + name.slice(1));
}
function injectHook(instance, hookName, fn) {
    var options = instance.$options;
    options[hookName] = mergeLifecycleHook(options[hookName], fn);
}
var onBeforeMount = createLifeCycle('beforeMount');
var onMounted = createLifeCycle('mounted');
var onBeforeUpdate = createLifeCycle('beforeUpdate');
var onUpdated = createLifeCycle('updated');
var onBeforeUnmount = createLifeCycle('beforeDestroy');
var onUnmounted = createLifeCycle('destroyed');
var onActivated = createLifeCycle('activated');
var onDeactivated = createLifeCycle('deactivated');
var onServerPrefetch = createLifeCycle('serverPrefetch');
var onRenderTracked = createLifeCycle('renderTracked');
var onRenderTriggered = createLifeCycle('renderTriggered');
var injectErrorCapturedHook = createLifeCycle('errorCaptured');
function onErrorCaptured(hook, target) {
    if (target === void 0) { target = currentInstance; }
    injectErrorCapturedHook(hook, target);
}

/**
 * Note: also update dist/vue.runtime.mjs when adding new exports to this file.
 */
var version = '2.7.14';
/**
 * @internal type is manually declared in <root>/types/v3-define-component.d.ts
 */
function defineComponent(options) {
    return options;
}

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
    return val;
}
function _traverse(val, seen) {
    var i, keys;
    var isA = isArray(val);
    if ((!isA && !isObject(val)) ||
        val.__v_skip /* ReactiveFlags.SKIP */ ||
        Object.isFrozen(val) ||
        val instanceof VNode) {
        return;
    }
    if (val.__ob__) {
        var depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
            return;
        }
        seen.add(depId);
    }
    if (isA) {
        i = val.length;
        while (i--)
            _traverse(val[i], seen);
    }
    else if (isRef(val)) {
        _traverse(val.value, seen);
    }
    else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
            _traverse(val[keys[i]], seen);
    }
}

var uid$1 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 * @internal
 */
var Watcher = /** @class */ (function () {
    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
        recordEffectScope(this, 
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        activeEffectScope && !activeEffectScope._vm
            ? activeEffectScope
            : vm
                ? vm._scope
                : undefined);
        if ((this.vm = vm) && isRenderWatcher) {
            vm._watcher = this;
        }
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
            this.before = options.before;
            if (true) {
                this.onTrack = options.onTrack;
                this.onTrigger = options.onTrigger;
            }
        }
        else {
            this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$1; // uid for batching
        this.active = true;
        this.post = false;
        this.dirty = this.lazy; // for lazy watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression =  true ? expOrFn.toString() : 0;
        // parse expression for getter
        if (isFunction(expOrFn)) {
            this.getter = expOrFn;
        }
        else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = noop;
                 true &&
                    warn("Failed watching path: \"".concat(expOrFn, "\" ") +
                        'Watcher only accepts simple dot-delimited paths. ' +
                        'For full control, use a function instead.', vm);
            }
        }
        this.value = this.lazy ? undefined : this.get();
    }
    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    Watcher.prototype.get = function () {
        pushTarget(this);
        var value;
        var vm = this.vm;
        try {
            value = this.getter.call(vm, vm);
        }
        catch (e) {
            if (this.user) {
                handleError(e, vm, "getter for watcher \"".concat(this.expression, "\""));
            }
            else {
                throw e;
            }
        }
        finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
                traverse(value);
            }
            popTarget();
            this.cleanupDeps();
        }
        return value;
    };
    /**
     * Add a dependency to this directive.
     */
    Watcher.prototype.addDep = function (dep) {
        var id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    };
    /**
     * Clean up for dependency collection.
     */
    Watcher.prototype.cleanupDeps = function () {
        var i = this.deps.length;
        while (i--) {
            var dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
                dep.removeSub(this);
            }
        }
        var tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    };
    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     */
    Watcher.prototype.update = function () {
        /* istanbul ignore else */
        if (this.lazy) {
            this.dirty = true;
        }
        else if (this.sync) {
            this.run();
        }
        else {
            queueWatcher(this);
        }
    };
    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    Watcher.prototype.run = function () {
        if (this.active) {
            var value = this.get();
            if (value !== this.value ||
                // Deep watchers and watchers on Object/Arrays should fire even
                // when the value is the same, because the value may
                // have mutated.
                isObject(value) ||
                this.deep) {
                // set new value
                var oldValue = this.value;
                this.value = value;
                if (this.user) {
                    var info = "callback for watcher \"".concat(this.expression, "\"");
                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
                }
                else {
                    this.cb.call(this.vm, value, oldValue);
                }
            }
        }
    };
    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    Watcher.prototype.evaluate = function () {
        this.value = this.get();
        this.dirty = false;
    };
    /**
     * Depend on all deps collected by this watcher.
     */
    Watcher.prototype.depend = function () {
        var i = this.deps.length;
        while (i--) {
            this.deps[i].depend();
        }
    };
    /**
     * Remove self from all dependencies' subscriber list.
     */
    Watcher.prototype.teardown = function () {
        if (this.vm && !this.vm._isBeingDestroyed) {
            remove$2(this.vm._scope.effects, this);
        }
        if (this.active) {
            var i = this.deps.length;
            while (i--) {
                this.deps[i].removeSub(this);
            }
            this.active = false;
            if (this.onStop) {
                this.onStop();
            }
        }
    };
    return Watcher;
}());

var mark;
var measure;
if (true) {
    var perf_1 = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf_1 &&
        // @ts-ignore
        perf_1.mark &&
        // @ts-ignore
        perf_1.measure &&
        // @ts-ignore
        perf_1.clearMarks &&
        // @ts-ignore
        perf_1.clearMeasures) {
        mark = function (tag) { return perf_1.mark(tag); };
        measure = function (name, startTag, endTag) {
            perf_1.measure(name, startTag, endTag);
            perf_1.clearMarks(startTag);
            perf_1.clearMarks(endTag);
            // perf.clearMeasures(name)
        };
    }
}

function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
        updateComponentListeners(vm, listeners);
    }
}
var target$1;
function add$1(event, fn) {
    target$1.$on(event, fn);
}
function remove$1(event, fn) {
    target$1.$off(event, fn);
}
function createOnceHandler$1(event, fn) {
    var _target = target$1;
    return function onceHandler() {
        var res = fn.apply(null, arguments);
        if (res !== null) {
            _target.$off(event, onceHandler);
        }
    };
}
function updateComponentListeners(vm, listeners, oldListeners) {
    target$1 = vm;
    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
    target$1 = undefined;
}
function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
        var vm = this;
        if (isArray(event)) {
            for (var i = 0, l = event.length; i < l; i++) {
                vm.$on(event[i], fn);
            }
        }
        else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
                vm._hasHookEvent = true;
            }
        }
        return vm;
    };
    Vue.prototype.$once = function (event, fn) {
        var vm = this;
        function on() {
            vm.$off(event, on);
            fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm;
    };
    Vue.prototype.$off = function (event, fn) {
        var vm = this;
        // all
        if (!arguments.length) {
            vm._events = Object.create(null);
            return vm;
        }
        // array of events
        if (isArray(event)) {
            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {
                vm.$off(event[i_1], fn);
            }
            return vm;
        }
        // specific event
        var cbs = vm._events[event];
        if (!cbs) {
            return vm;
        }
        if (!fn) {
            vm._events[event] = null;
            return vm;
        }
        // specific handler
        var cb;
        var i = cbs.length;
        while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1);
                break;
            }
        }
        return vm;
    };
    Vue.prototype.$emit = function (event) {
        var vm = this;
        if (true) {
            var lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip("Event \"".concat(lowerCaseEvent, "\" is emitted in component ") +
                    "".concat(formatComponentName(vm), " but the handler is registered for \"").concat(event, "\". ") +
                    "Note that HTML attributes are case-insensitive and you cannot use " +
                    "v-on to listen to camelCase events when using in-DOM templates. " +
                    "You should probably use \"".concat(hyphenate(event), "\" instead of \"").concat(event, "\"."));
            }
        }
        var cbs = vm._events[event];
        if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            var args = toArray(arguments, 1);
            var info = "event handler for \"".concat(event, "\"");
            for (var i = 0, l = cbs.length; i < l; i++) {
                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
        }
        return vm;
    };
}

var activeInstance = null;
var isUpdatingChildComponent = false;
function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
        activeInstance = prevActiveInstance;
    };
}
function initLifecycle(vm) {
    var options = vm.$options;
    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
        }
        parent.$children.push(vm);
    }
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._provided = parent ? parent._provided : Object.create(null);
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
        var vm = this;
        var prevEl = vm.$el;
        var prevVnode = vm._vnode;
        var restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        // Vue.prototype.__patch__ is injected in entry points
        // based on the rendering backend used.
        if (!prevVnode) {
            // initial render
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
        }
        else {
            // updates
            vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        // update __vue__ reference
        if (prevEl) {
            prevEl.__vue__ = null;
        }
        if (vm.$el) {
            vm.$el.__vue__ = vm;
        }
        // if parent is an HOC, update its $el as well
        var wrapper = vm;
        while (wrapper &&
            wrapper.$vnode &&
            wrapper.$parent &&
            wrapper.$vnode === wrapper.$parent._vnode) {
            wrapper.$parent.$el = wrapper.$el;
            wrapper = wrapper.$parent;
        }
        // updated hook is called by the scheduler to ensure that children are
        // updated in a parent's updated hook.
    };
    Vue.prototype.$forceUpdate = function () {
        var vm = this;
        if (vm._watcher) {
            vm._watcher.update();
        }
    };
    Vue.prototype.$destroy = function () {
        var vm = this;
        if (vm._isBeingDestroyed) {
            return;
        }
        callHook$1(vm, 'beforeDestroy');
        vm._isBeingDestroyed = true;
        // remove self from parent
        var parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove$2(parent.$children, vm);
        }
        // teardown scope. this includes both the render watcher and other
        // watchers created
        vm._scope.stop();
        // remove reference from data ob
        // frozen object may not have observer.
        if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
        }
        // call the last hook...
        vm._isDestroyed = true;
        // invoke destroy hooks on current rendered tree
        vm.__patch__(vm._vnode, null);
        // fire destroyed hook
        callHook$1(vm, 'destroyed');
        // turn off all instance listeners.
        vm.$off();
        // remove __vue__ reference
        if (vm.$el) {
            vm.$el.__vue__ = null;
        }
        // release circular reference (#6759)
        if (vm.$vnode) {
            vm.$vnode.parent = null;
        }
    };
}
function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
        // @ts-expect-error invalid type
        vm.$options.render = createEmptyVNode;
        if (true) {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                vm.$options.el ||
                el) {
                warn('You are using the runtime-only build of Vue where the template ' +
                    'compiler is not available. Either pre-compile the templates into ' +
                    'render functions, or use the compiler-included build.', vm);
            }
            else {
                warn('Failed to mount component: template or render function not defined.', vm);
            }
        }
    }
    callHook$1(vm, 'beforeMount');
    var updateComponent;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
        updateComponent = function () {
            var name = vm._name;
            var id = vm._uid;
            var startTag = "vue-perf-start:".concat(id);
            var endTag = "vue-perf-end:".concat(id);
            mark(startTag);
            var vnode = vm._render();
            mark(endTag);
            measure("vue ".concat(name, " render"), startTag, endTag);
            mark(startTag);
            vm._update(vnode, hydrating);
            mark(endTag);
            measure("vue ".concat(name, " patch"), startTag, endTag);
        };
    }
    else {
        updateComponent = function () {
            vm._update(vm._render(), hydrating);
        };
    }
    var watcherOptions = {
        before: function () {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook$1(vm, 'beforeUpdate');
            }
        }
    };
    if (true) {
        watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };
        watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };
    }
    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);
    hydrating = false;
    // flush buffer for flush: "pre" watchers queued in setup()
    var preWatchers = vm._preWatchers;
    if (preWatchers) {
        for (var i = 0; i < preWatchers.length; i++) {
            preWatchers[i].run();
        }
    }
    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook$1(vm, 'mounted');
    }
    return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    if (true) {
        isUpdatingChildComponent = true;
    }
    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.
    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||
        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
        (!newScopedSlots && vm.$scopedSlots.$key));
    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(renderChildren || // has new static slots
        vm.$options._renderChildren || // has old static slots
        hasDynamicScopedSlot);
    var prevVNode = vm.$vnode;
    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
    if (vm._vnode) {
        // update child tree's parent
        vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;
    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    var attrs = parentVnode.data.attrs || emptyObject;
    if (vm._attrsProxy) {
        // force update if attrs are accessed and has changed since it may be
        // passed to a child component.
        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {
            needsForceUpdate = true;
        }
    }
    vm.$attrs = attrs;
    // update listeners
    listeners = listeners || emptyObject;
    var prevListeners = vm.$options._parentListeners;
    if (vm._listenersProxy) {
        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');
    }
    vm.$listeners = vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, prevListeners);
    // update props
    if (propsData && vm.$options.props) {
        toggleObserving(false);
        var props = vm._props;
        var propKeys = vm.$options._propKeys || [];
        for (var i = 0; i < propKeys.length; i++) {
            var key = propKeys[i];
            var propOptions = vm.$options.props; // wtf flow?
            props[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        // keep a copy of raw propsData
        vm.$options.propsData = propsData;
    }
    // resolve slots + force update if has children
    if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
    }
    if (true) {
        isUpdatingChildComponent = false;
    }
}
function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
            return true;
    }
    return false;
}
function activateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    else if (vm._directInactive) {
        return;
    }
    if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (var i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'activated');
    }
}
function deactivateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    if (!vm._inactive) {
        vm._inactive = true;
        for (var i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'deactivated');
    }
}
function callHook$1(vm, hook, args, setContext) {
    if (setContext === void 0) { setContext = true; }
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var prev = currentInstance;
    setContext && setCurrentInstance(vm);
    var handlers = vm.$options[hook];
    var info = "".concat(hook, " hook");
    if (handlers) {
        for (var i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
        }
    }
    if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook);
    }
    setContext && setCurrentInstance(prev);
    popTarget();
}

var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    if (true) {
        circular = {};
    }
    waiting = flushing = false;
}
// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;
// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;
// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
    var performance_1 = window.performance;
    if (performance_1 &&
        typeof performance_1.now === 'function' &&
        getNow() > document.createEvent('Event').timeStamp) {
        // if the event timestamp, although evaluated AFTER the Date.now(), is
        // smaller than it, it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listener timestamps as
        // well.
        getNow = function () { return performance_1.now(); };
    }
}
var sortCompareFn = function (a, b) {
    if (a.post) {
        if (!b.post)
            return 1;
    }
    else if (b.post) {
        return -1;
    }
    return a.id - b.id;
};
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(sortCompareFn);
    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
        watcher = queue[index];
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if ( true && has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn('You may have an infinite update loop ' +
                    (watcher.user
                        ? "in watcher with expression \"".concat(watcher.expression, "\"")
                        : "in a component render function."), watcher.vm);
                break;
            }
        }
    }
    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();
    resetSchedulerState();
    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);
    cleanupDeps();
    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}
function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
        var watcher = queue[i];
        var vm = watcher.vm;
        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook$1(vm, 'updated');
        }
    }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
}
function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
        queue[i]._inactive = true;
        activateChildComponent(queue[i], true /* true */);
    }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] != null) {
        return;
    }
    if (watcher === Dep.target && watcher.noRecurse) {
        return;
    }
    has[id] = true;
    if (!flushing) {
        queue.push(watcher);
    }
    else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
            i--;
        }
        queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
        waiting = true;
        if ( true && !config.async) {
            flushSchedulerQueue();
            return;
        }
        nextTick(flushSchedulerQueue);
    }
}

function initProvide(vm) {
    var provideOption = vm.$options.provide;
    if (provideOption) {
        var provided = isFunction(provideOption)
            ? provideOption.call(vm)
            : provideOption;
        if (!isObject(provided)) {
            return;
        }
        var source = resolveProvided(vm);
        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to
        // iterate the keys ourselves.
        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
        }
    }
}
function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
        toggleObserving(false);
        Object.keys(result).forEach(function (key) {
            /* istanbul ignore else */
            if (true) {
                defineReactive(vm, key, result[key], function () {
                    warn("Avoid mutating an injected value directly since the changes will be " +
                        "overwritten whenever the provided component re-renders. " +
                        "injection being mutated: \"".concat(key, "\""), vm);
                });
            }
            else {}
        });
        toggleObserving(true);
    }
}
function resolveInject(inject, vm) {
    if (inject) {
        // inject is :any because flow is not smart enough to figure out cached
        var result = Object.create(null);
        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            // #6574 in case the inject object is observed...
            if (key === '__ob__')
                continue;
            var provideKey = inject[key].from;
            if (provideKey in vm._provided) {
                result[key] = vm._provided[provideKey];
            }
            else if ('default' in inject[key]) {
                var provideDefault = inject[key].default;
                result[key] = isFunction(provideDefault)
                    ? provideDefault.call(vm)
                    : provideDefault;
            }
            else if (true) {
                warn("Injection \"".concat(key, "\" not found"), vm);
            }
        }
        return result;
    }
}

function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var _this = this;
    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
    }
    else {
        // the context vm passed in is a functional context as well.
        // in this case we want to make sure we are able to get a hold to the
        // real context instance.
        contextVm = parent;
        // @ts-ignore
        parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;
    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
        if (!_this.$slots) {
            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));
        }
        return _this.$slots;
    };
    Object.defineProperty(this, 'scopedSlots', {
        enumerable: true,
        get: function () {
            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
        }
    });
    // support for compiled functional template
    if (isCompiled) {
        // exposing $options for renderStatic()
        this.$options = options;
        // pre-resolve slots for renderSlot()
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
    }
    if (options._scopeId) {
        this._c = function (a, b, c, d) {
            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
            if (vnode && !isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
            }
            return vnode;
        };
    }
    else {
        this._c = function (a, b, c, d) {
            return createElement$1(contextVm, a, b, c, d, needNormalization);
        };
    }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
        for (var key in propOptions) {
            props[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
    }
    else {
        if (isDef(data.attrs))
            mergeProps(props, data.attrs);
        if (isDef(data.props))
            mergeProps(props, data.props);
    }
    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
    var vnode = options.render.call(null, renderContext._c, renderContext);
    if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    }
    else if (isArray(vnode)) {
        var vnodes = normalizeChildren(vnode) || [];
        var res = new Array(vnodes.length);
        for (var i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
    }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    if (true) {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
            renderContext;
    }
    if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
}
function mergeProps(to, from) {
    for (var key in from) {
        to[camelize(key)] = from[key];
    }
}

function getComponentName(options) {
    return options.name || options.__name || options._componentTag;
}
// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
    init: function (vnode, hydrating) {
        if (vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive) {
            // kept-alive components, treat as a patch
            var mountedNode = vnode; // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
        }
        else {
            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        }
    },
    prepatch: function (oldVnode, vnode) {
        var options = vnode.componentOptions;
        var child = (vnode.componentInstance = oldVnode.componentInstance);
        updateChildComponent(child, options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
        );
    },
    insert: function (vnode) {
        var context = vnode.context, componentInstance = vnode.componentInstance;
        if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook$1(componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
            if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
            }
            else {
                activateChildComponent(componentInstance, true /* direct */);
            }
        }
    },
    destroy: function (vnode) {
        var componentInstance = vnode.componentInstance;
        if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
            }
            else {
                deactivateChildComponent(componentInstance, true /* direct */);
            }
        }
    }
};
var hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
        return;
    }
    var baseCtor = context.$options._base;
    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
    }
    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
        if (true) {
            warn("Invalid Component definition: ".concat(String(Ctor)), context);
        }
        return;
    }
    // async component
    var asyncFactory;
    // @ts-expect-error
    if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === undefined) {
            // return a placeholder node for async component, which is rendered
            // as a comment node but preserves all the raw information for the node.
            // the information will be used for async server-rendering and hydration.
            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
        }
    }
    data = data || {};
    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);
    // transform component v-model data into props & events
    if (isDef(data.model)) {
        // @ts-expect-error
        transformModel(Ctor.options, data);
    }
    // extract props
    // @ts-expect-error
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);
    // functional component
    // @ts-expect-error
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children);
    }
    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;
    // @ts-expect-error
    if (isTrue(Ctor.options.abstract)) {
        // abstract components do not keep anything
        // other than props & listeners & slot
        // work around flow
        var slot = data.slot;
        data = {};
        if (slot) {
            data.slot = slot;
        }
    }
    // install component management hooks onto the placeholder node
    installComponentHooks(data);
    // return a placeholder vnode
    // @ts-expect-error
    var name = getComponentName(Ctor.options) || tag;
    var vnode = new VNode(
    // @ts-expect-error
    "vue-component-".concat(Ctor.cid).concat(name ? "-".concat(name) : ''), data, undefined, undefined, undefined, context, 
    // @ts-expect-error
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
    return vnode;
}
function createComponentInstanceForVnode(
// we know it's MountedComponentVNode but flow doesn't
vnode, 
// activeInstance in lifecycle state
parent) {
    var options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
        var key = hooksToMerge[i];
        var existing = hooks[key];
        var toMerge = componentVNodeHooks[key];
        // @ts-expect-error
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
        }
    }
}
function mergeHook(f1, f2) {
    var merged = function (a, b) {
        // flow complains about extra args which is why we use any
        f1(a, b);
        f2(a, b);
    };
    merged._merged = true;
    return merged;
}
// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
    var prop = (options.model && options.model.prop) || 'value';
    var event = (options.model && options.model.event) || 'input';
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
        if (isArray(existing)
            ? existing.indexOf(callback) === -1
            : existing !== callback) {
            on[event] = [callback].concat(existing);
        }
    }
    else {
        on[event] = callback;
    }
}

var warn = noop;
var tip = noop;
var generateComponentTrace; // work around flow check
var formatComponentName;
if (true) {
    var hasConsole_1 = typeof console !== 'undefined';
    var classifyRE_1 = /(?:^|[-_])(\w)/g;
    var classify_1 = function (str) {
        return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');
    };
    warn = function (msg, vm) {
        if (vm === void 0) { vm = currentInstance; }
        var trace = vm ? generateComponentTrace(vm) : '';
        if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
        }
        else if (hasConsole_1 && !config.silent) {
            console.error("[Vue warn]: ".concat(msg).concat(trace));
        }
    };
    tip = function (msg, vm) {
        if (hasConsole_1 && !config.silent) {
            console.warn("[Vue tip]: ".concat(msg) + (vm ? generateComponentTrace(vm) : ''));
        }
    };
    formatComponentName = function (vm, includeFile) {
        if (vm.$root === vm) {
            return '<Root>';
        }
        var options = isFunction(vm) && vm.cid != null
            ? vm.options
            : vm._isVue
                ? vm.$options || vm.constructor.options
                : vm;
        var name = getComponentName(options);
        var file = options.__file;
        if (!name && file) {
            var match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
        }
        return ((name ? "<".concat(classify_1(name), ">") : "<Anonymous>") +
            (file && includeFile !== false ? " at ".concat(file) : ''));
    };
    var repeat_1 = function (str, n) {
        var res = '';
        while (n) {
            if (n % 2 === 1)
                res += str;
            if (n > 1)
                str += str;
            n >>= 1;
        }
        return res;
    };
    generateComponentTrace = function (vm) {
        if (vm._isVue && vm.$parent) {
            var tree = [];
            var currentRecursiveSequence = 0;
            while (vm) {
                if (tree.length > 0) {
                    var last = tree[tree.length - 1];
                    if (last.constructor === vm.constructor) {
                        currentRecursiveSequence++;
                        vm = vm.$parent;
                        continue;
                    }
                    else if (currentRecursiveSequence > 0) {
                        tree[tree.length - 1] = [last, currentRecursiveSequence];
                        currentRecursiveSequence = 0;
                    }
                }
                tree.push(vm);
                vm = vm.$parent;
            }
            return ('\n\nfound in\n\n' +
                tree
                    .map(function (vm, i) {
                    return "".concat(i === 0 ? '---> ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)
                        ? "".concat(formatComponentName(vm[0]), "... (").concat(vm[1], " recursive calls)")
                        : formatComponentName(vm));
                })
                    .join('\n'));
        }
        else {
            return "\n\n(found in ".concat(formatComponentName(vm), ")");
        }
    };
}

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */
if (true) {
    strats.el = strats.propsData = function (parent, child, vm, key) {
        if (!vm) {
            warn("option \"".concat(key, "\" can only be used during instance ") +
                'creation with the `new` keyword.');
        }
        return defaultStrat(parent, child);
    };
}
/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from, recursive) {
    if (recursive === void 0) { recursive = true; }
    if (!from)
        return to;
    var key, toVal, fromVal;
    var keys = hasSymbol
        ? Reflect.ownKeys(from)
        : Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
        key = keys[i];
        // in case the object is already observed...
        if (key === '__ob__')
            continue;
        toVal = to[key];
        fromVal = from[key];
        if (!recursive || !hasOwn(to, key)) {
            set(to, key, fromVal);
        }
        else if (toVal !== fromVal &&
            isPlainObject(toVal) &&
            isPlainObject(fromVal)) {
            mergeData(toVal, fromVal);
        }
    }
    return to;
}
/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
            return parentVal;
        }
        if (!parentVal) {
            return childVal;
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn() {
            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
        };
    }
    else {
        return function mergedInstanceDataFn() {
            // instance merge
            var instanceData = isFunction(childVal)
                ? childVal.call(vm, vm)
                : childVal;
            var defaultData = isFunction(parentVal)
                ? parentVal.call(vm, vm)
                : parentVal;
            if (instanceData) {
                return mergeData(instanceData, defaultData);
            }
            else {
                return defaultData;
            }
        };
    }
}
strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
        if (childVal && typeof childVal !== 'function') {
             true &&
                warn('The "data" option should be a function ' +
                    'that returns a per-instance value in component ' +
                    'definitions.', vm);
            return parentVal;
        }
        return mergeDataOrFn(parentVal, childVal);
    }
    return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */
function mergeLifecycleHook(parentVal, childVal) {
    var res = childVal
        ? parentVal
            ? parentVal.concat(childVal)
            : isArray(childVal)
                ? childVal
                : [childVal]
        : parentVal;
    return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
            res.push(hooks[i]);
        }
    }
    return res;
}
LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeLifecycleHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
         true && assertObjectType(key, childVal, vm);
        return extend(res, childVal);
    }
    else {
        return res;
    }
}
ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    //@ts-expect-error work around
    if (parentVal === nativeWatch)
        parentVal = undefined;
    //@ts-expect-error work around
    if (childVal === nativeWatch)
        childVal = undefined;
    /* istanbul ignore if */
    if (!childVal)
        return Object.create(parentVal || null);
    if (true) {
        assertObjectType(key, childVal, vm);
    }
    if (!parentVal)
        return childVal;
    var ret = {};
    extend(ret, parentVal);
    for (var key_1 in childVal) {
        var parent_1 = ret[key_1];
        var child = childVal[key_1];
        if (parent_1 && !isArray(parent_1)) {
            parent_1 = [parent_1];
        }
        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];
    }
    return ret;
};
/**
 * Other object hashes.
 */
strats.props =
    strats.methods =
        strats.inject =
            strats.computed =
                function (parentVal, childVal, vm, key) {
                    if (childVal && "development" !== 'production') {
                        assertObjectType(key, childVal, vm);
                    }
                    if (!parentVal)
                        return childVal;
                    var ret = Object.create(null);
                    extend(ret, parentVal);
                    if (childVal)
                        extend(ret, childVal);
                    return ret;
                };
strats.provide = function (parentVal, childVal) {
    if (!parentVal)
        return childVal;
    return function () {
        var ret = Object.create(null);
        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);
        if (childVal) {
            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive
            );
        }
        return ret;
    };
};
/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */
function checkComponents(options) {
    for (var key in options.components) {
        validateComponentName(key);
    }
}
function validateComponentName(name) {
    if (!new RegExp("^[a-zA-Z][\\-\\.0-9_".concat(unicodeRegExp.source, "]*$")).test(name)) {
        warn('Invalid component name: "' +
            name +
            '". Component names ' +
            'should conform to valid custom element name in html5 specification.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component ' +
            'id: ' +
            name);
    }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
    var props = options.props;
    if (!props)
        return;
    var res = {};
    var i, val, name;
    if (isArray(props)) {
        i = props.length;
        while (i--) {
            val = props[i];
            if (typeof val === 'string') {
                name = camelize(val);
                res[name] = { type: null };
            }
            else if (true) {
                warn('props must be strings when using array syntax.');
            }
        }
    }
    else if (isPlainObject(props)) {
        for (var key in props) {
            val = props[key];
            name = camelize(key);
            res[name] = isPlainObject(val) ? val : { type: val };
        }
    }
    else if (true) {
        warn("Invalid value for option \"props\": expected an Array or an Object, " +
            "but got ".concat(toRawType(props), "."), vm);
    }
    options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject)
        return;
    var normalized = (options.inject = {});
    if (isArray(inject)) {
        for (var i = 0; i < inject.length; i++) {
            normalized[inject[i]] = { from: inject[i] };
        }
    }
    else if (isPlainObject(inject)) {
        for (var key in inject) {
            var val = inject[key];
            normalized[key] = isPlainObject(val)
                ? extend({ from: key }, val)
                : { from: val };
        }
    }
    else if (true) {
        warn("Invalid value for option \"inject\": expected an Array or an Object, " +
            "but got ".concat(toRawType(inject), "."), vm);
    }
}
/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives$1(options) {
    var dirs = options.directives;
    if (dirs) {
        for (var key in dirs) {
            var def = dirs[key];
            if (isFunction(def)) {
                dirs[key] = { bind: def, update: def };
            }
        }
    }
}
function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
        warn("Invalid value for option \"".concat(name, "\": expected an Object, ") +
            "but got ".concat(toRawType(value), "."), vm);
    }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
    if (true) {
        checkComponents(child);
    }
    if (isFunction(child)) {
        // @ts-expect-error
        child = child.options;
    }
    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives$1(child);
    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
        if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
            for (var i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
    }
    var options = {};
    var key;
    for (key in parent) {
        mergeField(key);
    }
    for (key in child) {
        if (!hasOwn(parent, key)) {
            mergeField(key);
        }
    }
    function mergeField(key) {
        var strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
        return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id))
        return assets[id];
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId))
        return assets[camelizedId];
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId))
        return assets[PascalCaseId];
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if ( true && warnMissing && !res) {
        warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id);
    }
    return res;
}

function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, 'default')) {
            value = false;
        }
        else if (value === '' || value === hyphenate(key)) {
            // only cast empty string / same name to boolean if
            // boolean has higher priority
            var stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
            }
        }
    }
    // check default value
    if (value === undefined) {
        value = getPropDefaultValue(vm, prop, key);
        // since the default value is a fresh copy,
        // make sure to observe it.
        var prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
    }
    if (true) {
        assertProp(prop, key, value, vm, absent);
    }
    return value;
}
/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
        return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if ( true && isObject(def)) {
        warn('Invalid default value for prop "' +
            key +
            '": ' +
            'Props with type Object/Array must use a factory function ' +
            'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm &&
        vm.$options.propsData &&
        vm.$options.propsData[key] === undefined &&
        vm._props[key] !== undefined) {
        return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return isFunction(def) && getType(prop.type) !== 'Function'
        ? def.call(vm)
        : def;
}
/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
        warn('Missing required prop: "' + name + '"', vm);
        return;
    }
    if (value == null && !prop.required) {
        return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
        if (!isArray(type)) {
            type = [type];
        }
        for (var i = 0; i < type.length && !valid; i++) {
            var assertedType = assertType(value, type[i], vm);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
        }
    }
    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
    if (!valid && haveExpectedTypes) {
        warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
        return;
    }
    var validator = prop.validator;
    if (validator) {
        if (!validator(value)) {
            warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
    }
}
var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
function assertType(value, type, vm) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
        var t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = isPlainObject(value);
    }
    else if (expectedType === 'Array') {
        valid = isArray(value);
    }
    else {
        try {
            valid = value instanceof type;
        }
        catch (e) {
            warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
            valid = false;
        }
    }
    return {
        valid: valid,
        expectedType: expectedType
    };
}
var functionTypeCheckRE = /^\s*function (\w+)/;
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
    var match = fn && fn.toString().match(functionTypeCheckRE);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (!isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
            return i;
        }
    }
    return -1;
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"".concat(name, "\".") +
        " Expected ".concat(expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        isExplicable(typeof value) &&
        !isBoolean(expectedType, receivedType)) {
        message += " with value ".concat(styleValue(value, expectedType));
    }
    message += ", got ".concat(receivedType, " ");
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += "with value ".concat(styleValue(value, receivedType), ".");
    }
    return message;
}
function styleValue(value, type) {
    if (type === 'String') {
        return "\"".concat(value, "\"");
    }
    else if (type === 'Number') {
        return "".concat(Number(value));
    }
    else {
        return "".concat(value);
    }
}
var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable(value) {
    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });
}
function isBoolean() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });
}

/* not type checking this file because flow doesn't play well with Proxy */
var initProxy;
if (true) {
    var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
        'require' // for Webpack/Browserify
    );
    var warnNonPresent_1 = function (target, key) {
        warn("Property or method \"".concat(key, "\" is not defined on the instance but ") +
            'referenced during render. Make sure that this property is reactive, ' +
            'either in the data option, or for class-based components, by ' +
            'initializing the property. ' +
            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };
    var warnReservedPrefix_1 = function (target, key) {
        warn("Property \"".concat(key, "\" must be accessed with \"$data.").concat(key, "\" because ") +
            'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
            'prevent conflicts with Vue internals. ' +
            'See: https://v2.vuejs.org/v2/api/#data', target);
    };
    var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);
    if (hasProxy_1) {
        var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
        config.keyCodes = new Proxy(config.keyCodes, {
            set: function (target, key, value) {
                if (isBuiltInModifier_1(key)) {
                    warn("Avoid overwriting built-in modifier in config.keyCodes: .".concat(key));
                    return false;
                }
                else {
                    target[key] = value;
                    return true;
                }
            }
        });
    }
    var hasHandler_1 = {
        has: function (target, key) {
            var has = key in target;
            var isAllowed = allowedGlobals_1(key) ||
                (typeof key === 'string' &&
                    key.charAt(0) === '_' &&
                    !(key in target.$data));
            if (!has && !isAllowed) {
                if (key in target.$data)
                    warnReservedPrefix_1(target, key);
                else
                    warnNonPresent_1(target, key);
            }
            return has || !isAllowed;
        }
    };
    var getHandler_1 = {
        get: function (target, key) {
            if (typeof key === 'string' && !(key in target)) {
                if (key in target.$data)
                    warnReservedPrefix_1(target, key);
                else
                    warnNonPresent_1(target, key);
            }
            return target[key];
        }
    };
    initProxy = function initProxy(vm) {
        if (hasProxy_1) {
            // determine which proxy handler to use
            var options = vm.$options;
            var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;
            vm._renderProxy = new Proxy(vm, handlers);
        }
        else {
            vm._renderProxy = vm;
        }
    };
}

var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
};
function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function initState(vm) {
    var opts = vm.$options;
    if (opts.props)
        initProps$1(vm, opts.props);
    // Composition API
    initSetup(vm);
    if (opts.methods)
        initMethods(vm, opts.methods);
    if (opts.data) {
        initData(vm);
    }
    else {
        var ob = observe((vm._data = {}));
        ob && ob.vmCount++;
    }
    if (opts.computed)
        initComputed$1(vm, opts.computed);
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}
function initProps$1(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = (vm._props = shallowReactive({}));
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = (vm.$options._propKeys = []);
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false);
    }
    var _loop_1 = function (key) {
        keys.push(key);
        var value = validateProp(key, propsOptions, propsData, vm);
        /* istanbul ignore else */
        if (true) {
            var hyphenatedKey = hyphenate(key);
            if (isReservedAttribute(hyphenatedKey) ||
                config.isReservedAttr(hyphenatedKey)) {
                warn("\"".concat(hyphenatedKey, "\" is a reserved attribute and cannot be used as component prop."), vm);
            }
            defineReactive(props, key, value, function () {
                if (!isRoot && !isUpdatingChildComponent) {
                    warn("Avoid mutating a prop directly since the value will be " +
                        "overwritten whenever the parent component re-renders. " +
                        "Instead, use a data or computed property based on the prop's " +
                        "value. Prop being mutated: \"".concat(key, "\""), vm);
                }
            });
        }
        else {}
        // static props are already proxied on the component's prototype
        // during Vue.extend(). We only need to proxy props defined at
        // instantiation here.
        if (!(key in vm)) {
            proxy(vm, "_props", key);
        }
    };
    for (var key in propsOptions) {
        _loop_1(key);
    }
    toggleObserving(true);
}
function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
        data = {};
         true &&
            warn('data functions should return an object:\n' +
                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
        var key = keys[i];
        if (true) {
            if (methods && hasOwn(methods, key)) {
                warn("Method \"".concat(key, "\" has already been defined as a data property."), vm);
            }
        }
        if (props && hasOwn(props, key)) {
             true &&
                warn("The data property \"".concat(key, "\" is already declared as a prop. ") +
                    "Use prop default value instead.", vm);
        }
        else if (!isReserved(key)) {
            proxy(vm, "_data", key);
        }
    }
    // observe data
    var ob = observe(data);
    ob && ob.vmCount++;
}
function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
        return data.call(vm, vm);
    }
    catch (e) {
        handleError(e, vm, "data()");
        return {};
    }
    finally {
        popTarget();
    }
}
var computedWatcherOptions = { lazy: true };
function initComputed$1(vm, computed) {
    // $flow-disable-line
    var watchers = (vm._computedWatchers = Object.create(null));
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();
    for (var key in computed) {
        var userDef = computed[key];
        var getter = isFunction(userDef) ? userDef : userDef.get;
        if ( true && getter == null) {
            warn("Getter is missing for computed property \"".concat(key, "\"."), vm);
        }
        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
        }
        // component-defined computed properties are already defined on the
        // component prototype. We only need to define computed properties defined
        // at instantiation here.
        if (!(key in vm)) {
            defineComputed(vm, key, userDef);
        }
        else if (true) {
            if (key in vm.$data) {
                warn("The computed property \"".concat(key, "\" is already defined in data."), vm);
            }
            else if (vm.$options.props && key in vm.$options.props) {
                warn("The computed property \"".concat(key, "\" is already defined as a prop."), vm);
            }
            else if (vm.$options.methods && key in vm.$options.methods) {
                warn("The computed property \"".concat(key, "\" is already defined as a method."), vm);
            }
        }
    }
}
function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (isFunction(userDef)) {
        sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop;
    }
    else {
        sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
                ? createComputedGetter(key)
                : createGetterInvoker(userDef.get)
            : noop;
        sharedPropertyDefinition.set = userDef.set || noop;
    }
    if ( true && sharedPropertyDefinition.set === noop) {
        sharedPropertyDefinition.set = function () {
            warn("Computed property \"".concat(key, "\" was assigned to but it has no setter."), this);
        };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
    return function computedGetter() {
        var watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                if ( true && Dep.target.onTrack) {
                    Dep.target.onTrack({
                        effect: Dep.target,
                        target: this,
                        type: "get" /* TrackOpTypes.GET */,
                        key: key
                    });
                }
                watcher.depend();
            }
            return watcher.value;
        }
    };
}
function createGetterInvoker(fn) {
    return function computedGetter() {
        return fn.call(this, this);
    };
}
function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
        if (true) {
            if (typeof methods[key] !== 'function') {
                warn("Method \"".concat(key, "\" has type \"").concat(typeof methods[key], "\" in the component definition. ") +
                    "Did you reference the function correctly?", vm);
            }
            if (props && hasOwn(props, key)) {
                warn("Method \"".concat(key, "\" has already been defined as a prop."), vm);
            }
            if (key in vm && isReserved(key)) {
                warn("Method \"".concat(key, "\" conflicts with an existing Vue instance method. ") +
                    "Avoid defining component methods that start with _ or $.");
            }
        }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
}
function initWatch(vm, watch) {
    for (var key in watch) {
        var handler = watch[key];
        if (isArray(handler)) {
            for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
            }
        }
        else {
            createWatcher(vm, key, handler);
        }
    }
}
function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
    }
    if (typeof handler === 'string') {
        handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
        return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
        return this._props;
    };
    if (true) {
        dataDef.set = function () {
            warn('Avoid replacing instance root $data. ' +
                'Use nested data properties instead.', this);
        };
        propsDef.set = function () {
            warn("$props is readonly.", this);
        };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);
    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;
    Vue.prototype.$watch = function (expOrFn, cb, options) {
        var vm = this;
        if (isPlainObject(cb)) {
            return createWatcher(vm, expOrFn, cb, options);
        }
        options = options || {};
        options.user = true;
        var watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
            var info = "callback for immediate watcher \"".concat(watcher.expression, "\"");
            pushTarget();
            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
            popTarget();
        }
        return function unwatchFn() {
            watcher.teardown();
        };
    };
}

var uid = 0;
function initMixin$1(Vue) {
    Vue.prototype._init = function (options) {
        var vm = this;
        // a uid
        vm._uid = uid++;
        var startTag, endTag;
        /* istanbul ignore if */
        if ( true && config.performance && mark) {
            startTag = "vue-perf-start:".concat(vm._uid);
            endTag = "vue-perf-end:".concat(vm._uid);
            mark(startTag);
        }
        // a flag to mark this as a Vue instance without having to do instanceof
        // check
        vm._isVue = true;
        // avoid instances from being observed
        vm.__v_skip = true;
        // effect scope
        vm._scope = new EffectScope(true /* detached */);
        vm._scope._vm = true;
        // merge options
        if (options && options._isComponent) {
            // optimize internal component instantiation
            // since dynamic options merging is pretty slow, and none of the
            // internal component options needs special treatment.
            initInternalComponent(vm, options);
        }
        else {
            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
        }
        /* istanbul ignore else */
        if (true) {
            initProxy(vm);
        }
        else {}
        // expose real self
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);
        initInjections(vm); // resolve injections before data/props
        initState(vm);
        initProvide(vm); // resolve provide after data/props
        callHook$1(vm, 'created');
        /* istanbul ignore if */
        if ( true && config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure("vue ".concat(vm._name, " init"), startTag, endTag);
        }
        if (vm.$options.el) {
            vm.$mount(vm.$options.el);
        }
    };
}
function initInternalComponent(vm, options) {
    var opts = (vm.$options = Object.create(vm.constructor.options));
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;
    if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
    }
}
function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
        var superOptions = resolveConstructorOptions(Ctor.super);
        var cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
            // super option changed,
            // need to resolve new options.
            Ctor.superOptions = superOptions;
            // check if there are any late-modified/attached options (#4976)
            var modifiedOptions = resolveModifiedOptions(Ctor);
            // update base extend options
            if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
                options.components[options.name] = Ctor;
            }
        }
    }
    return options;
}
function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
        if (latest[key] !== sealed[key]) {
            if (!modified)
                modified = {};
            modified[key] = latest[key];
        }
    }
    return modified;
}

function Vue(options) {
    if ( true && !(this instanceof Vue)) {
        warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
}
//@ts-expect-error Vue has function type
initMixin$1(Vue);
//@ts-expect-error Vue has function type
stateMixin(Vue);
//@ts-expect-error Vue has function type
eventsMixin(Vue);
//@ts-expect-error Vue has function type
lifecycleMixin(Vue);
//@ts-expect-error Vue has function type
renderMixin(Vue);

function initUse(Vue) {
    Vue.use = function (plugin) {
        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
        if (installedPlugins.indexOf(plugin) > -1) {
            return this;
        }
        // additional parameters
        var args = toArray(arguments, 1);
        args.unshift(this);
        if (isFunction(plugin.install)) {
            plugin.install.apply(plugin, args);
        }
        else if (isFunction(plugin)) {
            plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this;
    };
}

function initMixin(Vue) {
    Vue.mixin = function (mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this;
    };
}

function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;
    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        var Super = this;
        var SuperId = Super.cid;
        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId];
        }
        var name = getComponentName(extendOptions) || getComponentName(Super.options);
        if ( true && name) {
            validateComponentName(name);
        }
        var Sub = function VueComponent(options) {
            this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub['super'] = Super;
        // For props and computed properties, we define the proxy getters on
        // the Vue instances at extension time, on the extended prototype. This
        // avoids Object.defineProperty calls for each instance created.
        if (Sub.options.props) {
            initProps(Sub);
        }
        if (Sub.options.computed) {
            initComputed(Sub);
        }
        // allow further extension/mixin/plugin usage
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;
        // create asset registers, so extended classes
        // can have their private assets too.
        ASSET_TYPES.forEach(function (type) {
            Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
            Sub.options.components[name] = Sub;
        }
        // keep a reference to the super options at extension time.
        // later at instantiation we can check if Super's options have
        // been updated.
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend({}, Sub.options);
        // cache constructor
        cachedCtors[SuperId] = Sub;
        return Sub;
    };
}
function initProps(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
        proxy(Comp.prototype, "_props", key);
    }
}
function initComputed(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
        defineComputed(Comp.prototype, key, computed[key]);
    }
}

function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
        // @ts-expect-error function is not exact same type
        Vue[type] = function (id, definition) {
            if (!definition) {
                return this.options[type + 's'][id];
            }
            else {
                /* istanbul ignore if */
                if ( true && type === 'component') {
                    validateComponentName(id);
                }
                if (type === 'component' && isPlainObject(definition)) {
                    // @ts-expect-error
                    definition.name = definition.name || id;
                    definition = this.options._base.extend(definition);
                }
                if (type === 'directive' && isFunction(definition)) {
                    definition = { bind: definition, update: definition };
                }
                this.options[type + 's'][id] = definition;
                return definition;
            }
        };
    });
}

function _getComponentName(opts) {
    return opts && (getComponentName(opts.Ctor.options) || opts.tag);
}
function matches(pattern, name) {
    if (isArray(pattern)) {
        return pattern.indexOf(name) > -1;
    }
    else if (typeof pattern === 'string') {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (isRegExp(pattern)) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
        var entry = cache[key];
        if (entry) {
            var name_1 = entry.name;
            if (name_1 && !filter(name_1)) {
                pruneCacheEntry(cache, key, keys, _vnode);
            }
        }
    }
}
function pruneCacheEntry(cache, key, keys, current) {
    var entry = cache[key];
    if (entry && (!current || entry.tag !== current.tag)) {
        // @ts-expect-error can be undefined
        entry.componentInstance.$destroy();
    }
    cache[key] = null;
    remove$2(keys, key);
}
var patternTypes = [String, RegExp, Array];
// TODO defineComponent
var KeepAlive = {
    name: 'keep-alive',
    abstract: true,
    props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
    },
    methods: {
        cacheVNode: function () {
            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;
            if (vnodeToCache) {
                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;
                cache[keyToCache] = {
                    name: _getComponentName(componentOptions),
                    tag: tag,
                    componentInstance: componentInstance
                };
                keys.push(keyToCache);
                // prune oldest entry
                if (this.max && keys.length > parseInt(this.max)) {
                    pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
                this.vnodeToCache = null;
            }
        }
    },
    created: function () {
        this.cache = Object.create(null);
        this.keys = [];
    },
    destroyed: function () {
        for (var key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
        }
    },
    mounted: function () {
        var _this = this;
        this.cacheVNode();
        this.$watch('include', function (val) {
            pruneCache(_this, function (name) { return matches(val, name); });
        });
        this.$watch('exclude', function (val) {
            pruneCache(_this, function (name) { return !matches(val, name); });
        });
    },
    updated: function () {
        this.cacheVNode();
    },
    render: function () {
        var slot = this.$slots.default;
        var vnode = getFirstComponentChild(slot);
        var componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
            // check pattern
            var name_2 = _getComponentName(componentOptions);
            var _a = this, include = _a.include, exclude = _a.exclude;
            if (
            // not included
            (include && (!name_2 || !matches(include, name_2))) ||
                // excluded
                (exclude && name_2 && matches(exclude, name_2))) {
                return vnode;
            }
            var _b = this, cache = _b.cache, keys = _b.keys;
            var key = vnode.key == null
                ? // same constructor may get registered as different local components
                    // so cid alone is not enough (#3269)
                    componentOptions.Ctor.cid +
                        (componentOptions.tag ? "::".concat(componentOptions.tag) : '')
                : vnode.key;
            if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance;
                // make current key freshest
                remove$2(keys, key);
                keys.push(key);
            }
            else {
                // delay setting the cache until update
                this.vnodeToCache = vnode;
                this.keyToCache = key;
            }
            // @ts-expect-error can vnode.data can be undefined
            vnode.data.keepAlive = true;
        }
        return vnode || (slot && slot[0]);
    }
};

var builtInComponents = {
    KeepAlive: KeepAlive
};

function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () { return config; };
    if (true) {
        configDef.set = function () {
            warn('Do not replace the Vue.config object, set individual fields instead.');
        };
    }
    Object.defineProperty(Vue, 'config', configDef);
    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
        warn: warn,
        extend: extend,
        mergeOptions: mergeOptions,
        defineReactive: defineReactive
    };
    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;
    // 2.6 explicit observable API
    Vue.observable = function (obj) {
        observe(obj);
        return obj;
    };
    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
        Vue.options[type + 's'] = Object.create(null);
    });
    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;
    extend(Vue.options.components, builtInComponents);
    initUse(Vue);
    initMixin(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function () {
        /* istanbul ignore next */
        return this.$vnode && this.$vnode.ssrContext;
    }
});
// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
});
Vue.version = version;

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');
// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||
        (attr === 'selected' && tag === 'option') ||
        (attr === 'checked' && tag === 'input') ||
        (attr === 'muted' && tag === 'video'));
};
var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
        ? 'false'
        : // allow arbitrary string value for contenteditable
            key === 'contenteditable' && isValidContentEditableValue(value)
                ? value
                : 'true';
};
var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,' +
    'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';
var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};
var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
};
var isFalsyAttrValue = function (val) {
    return val == null || val === false;
};

function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
            data = mergeClassData(childNode.data, data);
        }
    }
    // @ts-expect-error parentNode.parent not VNodeWithData
    while (isDef((parentNode = parentNode.parent))) {
        if (parentNode && parentNode.data) {
            data = mergeClassData(data, parentNode.data);
        }
    }
    return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
    return {
        staticClass: concat(child.staticClass, parent.staticClass),
        class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
}
function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
}
function concat(a, b) {
    return a ? (b ? a + ' ' + b : a) : b || '';
}
function stringifyClass(value) {
    if (Array.isArray(value)) {
        return stringifyArray(value);
    }
    if (isObject(value)) {
        return stringifyObject(value);
    }
    if (typeof value === 'string') {
        return value;
    }
    /* istanbul ignore next */
    return '';
}
function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {
            if (res)
                res += ' ';
            res += stringified;
        }
    }
    return res;
}
function stringifyObject(value) {
    var res = '';
    for (var key in value) {
        if (value[key]) {
            if (res)
                res += ' ';
            res += key;
        }
    }
    return res;
}

var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot');
// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
    if (isSVG(tag)) {
        return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
        return 'math';
    }
}
var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
        return true;
    }
    if (isReservedTag(tag)) {
        return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
        // http://stackoverflow.com/a/28210364/1070244
        return (unknownElementCache[tag] =
            el.constructor === window.HTMLUnknownElement ||
                el.constructor === window.HTMLElement);
    }
    else {
        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));
    }
}
var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
    if (typeof el === 'string') {
        var selected = document.querySelector(el);
        if (!selected) {
             true && warn('Cannot find element: ' + el);
            return document.createElement('div');
        }
        return selected;
    }
    else {
        return el;
    }
}

function createElement(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
        return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data &&
        vnode.data.attrs &&
        vnode.data.attrs.multiple !== undefined) {
        elm.setAttribute('multiple', 'multiple');
    }
    return elm;
}
function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(node) {
    return node.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

var ref = {
    create: function (_, vnode) {
        registerRef(vnode);
    },
    update: function (oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
            registerRef(oldVnode, true);
            registerRef(vnode);
        }
    },
    destroy: function (vnode) {
        registerRef(vnode, true);
    }
};
function registerRef(vnode, isRemoval) {
    var ref = vnode.data.ref;
    if (!isDef(ref))
        return;
    var vm = vnode.context;
    var refValue = vnode.componentInstance || vnode.elm;
    var value = isRemoval ? null : refValue;
    var $refsValue = isRemoval ? undefined : refValue;
    if (isFunction(ref)) {
        invokeWithErrorHandling(ref, vm, [value], vm, "template ref function");
        return;
    }
    var isFor = vnode.data.refInFor;
    var _isString = typeof ref === 'string' || typeof ref === 'number';
    var _isRef = isRef(ref);
    var refs = vm.$refs;
    if (_isString || _isRef) {
        if (isFor) {
            var existing = _isString ? refs[ref] : ref.value;
            if (isRemoval) {
                isArray(existing) && remove$2(existing, refValue);
            }
            else {
                if (!isArray(existing)) {
                    if (_isString) {
                        refs[ref] = [refValue];
                        setSetupRef(vm, ref, refs[ref]);
                    }
                    else {
                        ref.value = [refValue];
                    }
                }
                else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                }
            }
        }
        else if (_isString) {
            if (isRemoval && refs[ref] !== refValue) {
                return;
            }
            refs[ref] = $refsValue;
            setSetupRef(vm, ref, value);
        }
        else if (_isRef) {
            if (isRemoval && ref.value !== refValue) {
                return;
            }
            ref.value = value;
        }
        else if (true) {
            warn("Invalid template ref type: ".concat(typeof ref));
        }
    }
}
function setSetupRef(_a, key, val) {
    var _setupState = _a._setupState;
    if (_setupState && hasOwn(_setupState, key)) {
        if (isRef(_setupState[key])) {
            _setupState[key].value = val;
        }
        else {
            _setupState[key] = val;
        }
    }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */
var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
function sameVnode(a, b) {
    return (a.key === b.key &&
        a.asyncFactory === b.asyncFactory &&
        ((a.tag === b.tag &&
            a.isComment === b.isComment &&
            isDef(a.data) === isDef(b.data) &&
            sameInputType(a, b)) ||
            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));
}
function sameInputType(a, b) {
    if (a.tag !== 'input')
        return true;
    var i;
    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;
    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;
    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key))
            map[key] = i;
    }
    return map;
}
function createPatchFunction(backend) {
    var i, j;
    var cbs = {};
    var modules = backend.modules, nodeOps = backend.nodeOps;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
            }
        }
    }
    function emptyNodeAt(elm) {
        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        function remove() {
            if (--remove.listeners === 0) {
                removeNode(childElm);
            }
        }
        remove.listeners = listeners;
        return remove;
    }
    function removeNode(el) {
        var parent = nodeOps.parentNode(el);
        // element may have already been removed due to v-html / v-text
        if (isDef(parent)) {
            nodeOps.removeChild(parent, el);
        }
    }
    function isUnknownElement(vnode, inVPre) {
        return (!inVPre &&
            !vnode.ns &&
            !(config.ignoredElements.length &&
                config.ignoredElements.some(function (ignore) {
                    return isRegExp(ignore)
                        ? ignore.test(vnode.tag)
                        : ignore === vnode.tag;
                })) &&
            config.isUnknownElement(vnode.tag));
    }
    var creatingElmInVPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // This vnode was used in a previous render!
            // now it's used as a new node, overwriting its elm would cause
            // potential patch errors down the road when it's used as an insertion
            // reference node. Instead, we clone the node on-demand before creating
            // associated DOM element for it.
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        vnode.isRootInsert = !nested; // for transition enter check
        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
            return;
        }
        var data = vnode.data;
        var children = vnode.children;
        var tag = vnode.tag;
        if (isDef(tag)) {
            if (true) {
                if (data && data.pre) {
                    creatingElmInVPre++;
                }
                if (isUnknownElement(vnode, creatingElmInVPre)) {
                    warn('Unknown custom element: <' +
                        tag +
                        '> - did you ' +
                        'register the component correctly? For recursive components, ' +
                        'make sure to provide the "name" option.', vnode.context);
                }
            }
            vnode.elm = vnode.ns
                ? nodeOps.createElementNS(vnode.ns, tag)
                : nodeOps.createElement(tag, vnode);
            setScope(vnode);
            createChildren(vnode, children, insertedVnodeQueue);
            if (isDef(data)) {
                invokeCreateHooks(vnode, insertedVnodeQueue);
            }
            insert(parentElm, vnode.elm, refElm);
            if ( true && data && data.pre) {
                creatingElmInVPre--;
            }
        }
        else if (isTrue(vnode.isComment)) {
            vnode.elm = nodeOps.createComment(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
        else {
            vnode.elm = nodeOps.createTextNode(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
    }
    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        var i = vnode.data;
        if (isDef(i)) {
            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
            if (isDef((i = i.hook)) && isDef((i = i.init))) {
                i(vnode, false /* hydrating */);
            }
            // after calling the init hook, if the vnode is a child component
            // it should've created a child instance and mounted it. the child
            // component also has set the placeholder vnode's elm.
            // in that case we can just return the element and be done.
            if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                insert(parentElm, vnode.elm, refElm);
                if (isTrue(isReactivated)) {
                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }
                return true;
            }
        }
    }
    function initComponent(vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            setScope(vnode);
        }
        else {
            // empty component root.
            // skip all element-related modules except for ref (#3455)
            registerRef(vnode);
            // make sure to invoke the insert hook
            insertedVnodeQueue.push(vnode);
        }
    }
    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        var i;
        // hack for #4339: a reactivated component with inner transition
        // does not trigger because the inner node's created hooks are not called
        // again. It's not ideal to involve module-specific logic in here but
        // there doesn't seem to be a better way to do it.
        var innerNode = vnode;
        while (innerNode.componentInstance) {
            innerNode = innerNode.componentInstance._vnode;
            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
                for (i = 0; i < cbs.activate.length; ++i) {
                    cbs.activate[i](emptyNode, innerNode);
                }
                insertedVnodeQueue.push(innerNode);
                break;
            }
        }
        // unlike a newly created component,
        // a reactivated keep-alive component doesn't insert itself
        insert(parentElm, vnode.elm, refElm);
    }
    function insert(parent, elm, ref) {
        if (isDef(parent)) {
            if (isDef(ref)) {
                if (nodeOps.parentNode(ref) === parent) {
                    nodeOps.insertBefore(parent, elm, ref);
                }
            }
            else {
                nodeOps.appendChild(parent, elm);
            }
        }
    }
    function createChildren(vnode, children, insertedVnodeQueue) {
        if (isArray(children)) {
            if (true) {
                checkDuplicateKeys(children);
            }
            for (var i_1 = 0; i_1 < children.length; ++i_1) {
                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);
            }
        }
        else if (isPrimitive(vnode.text)) {
            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
        }
    }
    function isPatchable(vnode) {
        while (vnode.componentInstance) {
            vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag);
    }
    function invokeCreateHooks(vnode, insertedVnodeQueue) {
        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {
            cbs.create[i_2](emptyNode, vnode);
        }
        i = vnode.data.hook; // Reuse variable
        if (isDef(i)) {
            if (isDef(i.create))
                i.create(emptyNode, vnode);
            if (isDef(i.insert))
                insertedVnodeQueue.push(vnode);
        }
    }
    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
        var i;
        if (isDef((i = vnode.fnScopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
        else {
            var ancestor = vnode;
            while (ancestor) {
                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
                ancestor = ancestor.parent;
            }
        }
        // for slot content they should also get the scopeId from the host instance.
        if (isDef((i = activeInstance)) &&
            i !== vnode.context &&
            i !== vnode.fnContext &&
            isDef((i = i.$options._scopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
    }
    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
    }
    function invokeDestroyHook(vnode) {
        var i, j;
        var data = vnode.data;
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.destroy)))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
        }
        if (isDef((i = vnode.children))) {
            for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
            }
        }
    }
    function removeVnodes(vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isDef(ch)) {
                if (isDef(ch.tag)) {
                    removeAndInvokeRemoveHook(ch);
                    invokeDestroyHook(ch);
                }
                else {
                    // Text node
                    removeNode(ch.elm);
                }
            }
        }
    }
    function removeAndInvokeRemoveHook(vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
            var i_3;
            var listeners = cbs.remove.length + 1;
            if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
            }
            else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
            }
            // recursively invoke hooks on child component root node
            if (isDef((i_3 = vnode.componentInstance)) &&
                isDef((i_3 = i_3._vnode)) &&
                isDef(i_3.data)) {
                removeAndInvokeRemoveHook(i_3, rm);
            }
            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {
                cbs.remove[i_3](vnode, rm);
            }
            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {
                i_3(vnode, rm);
            }
            else {
                rm();
            }
        }
        else {
            removeNode(vnode.elm);
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;
        // removeOnly is a special flag used only by <transition-group>
        // to ensure removed elements stay in correct relative positions
        // during leaving transitions
        var canMove = !removeOnly;
        if (true) {
            checkDuplicateKeys(newCh);
        }
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
            }
            else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (isUndef(oldKeyToIdx))
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                idxInOld = isDef(newStartVnode.key)
                    ? oldKeyToIdx[newStartVnode.key]
                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                if (isUndef(idxInOld)) {
                    // New element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                }
                else {
                    vnodeToMove = oldCh[idxInOld];
                    if (sameVnode(vnodeToMove, newStartVnode)) {
                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        oldCh[idxInOld] = undefined;
                        canMove &&
                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                    }
                    else {
                        // same key but different element. treat as new element
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                    }
                }
                newStartVnode = newCh[++newStartIdx];
            }
        }
        if (oldStartIdx > oldEndIdx) {
            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function checkDuplicateKeys(children) {
        var seenKeys = {};
        for (var i_4 = 0; i_4 < children.length; i_4++) {
            var vnode = children[i_4];
            var key = vnode.key;
            if (isDef(key)) {
                if (seenKeys[key]) {
                    warn("Duplicate keys detected: '".concat(key, "'. This may cause an update error."), vnode.context);
                }
                else {
                    seenKeys[key] = true;
                }
            }
        }
    }
    function findIdxInOld(node, oldCh, start, end) {
        for (var i_5 = start; i_5 < end; i_5++) {
            var c = oldCh[i_5];
            if (isDef(c) && sameVnode(node, c))
                return i_5;
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
        if (oldVnode === vnode) {
            return;
        }
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // clone reused vnode
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        var elm = (vnode.elm = oldVnode.elm);
        if (isTrue(oldVnode.isAsyncPlaceholder)) {
            if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
            }
            else {
                vnode.isAsyncPlaceholder = true;
            }
            return;
        }
        // reuse element for static trees.
        // note we only do this if the vnode is cloned -
        // if the new node is not cloned it means the render functions have been
        // reset by the hot-reload-api and we need to do a proper re-render.
        if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
            vnode.componentInstance = oldVnode.componentInstance;
            return;
        }
        var i;
        var data = vnode.data;
        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
            i(oldVnode, vnode);
        }
        var oldCh = oldVnode.children;
        var ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            if (isDef((i = data.hook)) && isDef((i = i.update)))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
            }
            else if (isDef(ch)) {
                if (true) {
                    checkDuplicateKeys(ch);
                }
                if (isDef(oldVnode.text))
                    nodeOps.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            nodeOps.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))
                i(oldVnode, vnode);
        }
    }
    function invokeInsertHook(vnode, queue, initial) {
        // delay insert hooks for component root nodes, invoke them after the
        // element is really inserted
        if (isTrue(initial) && isDef(vnode.parent)) {
            vnode.parent.data.pendingInsert = queue;
        }
        else {
            for (var i_6 = 0; i_6 < queue.length; ++i_6) {
                queue[i_6].data.hook.insert(queue[i_6]);
            }
        }
    }
    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
        var i;
        var tag = vnode.tag, data = vnode.data, children = vnode.children;
        inVPre = inVPre || (data && data.pre);
        vnode.elm = elm;
        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
            vnode.isAsyncPlaceholder = true;
            return true;
        }
        // assert node match
        if (true) {
            if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
            }
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.init)))
                i(vnode, true /* hydrating */);
            if (isDef((i = vnode.componentInstance))) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true;
            }
        }
        if (isDef(tag)) {
            if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                    createChildren(vnode, children, insertedVnodeQueue);
                }
                else {
                    // v-html and domProps: innerHTML
                    if (isDef((i = data)) &&
                        isDef((i = i.domProps)) &&
                        isDef((i = i.innerHTML))) {
                        if (i !== elm.innerHTML) {
                            /* istanbul ignore if */
                            if ( true &&
                                typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('server innerHTML: ', i);
                                console.warn('client innerHTML: ', elm.innerHTML);
                            }
                            return false;
                        }
                    }
                    else {
                        // iterate and compare children lists
                        var childrenMatch = true;
                        var childNode = elm.firstChild;
                        for (var i_7 = 0; i_7 < children.length; i_7++) {
                            if (!childNode ||
                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {
                                childrenMatch = false;
                                break;
                            }
                            childNode = childNode.nextSibling;
                        }
                        // if childNode is not null, it means the actual childNodes list is
                        // longer than the virtual children list.
                        if (!childrenMatch || childNode) {
                            /* istanbul ignore if */
                            if ( true &&
                                typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                            }
                            return false;
                        }
                    }
                }
            }
            if (isDef(data)) {
                var fullInvoke = false;
                for (var key in data) {
                    if (!isRenderedModule(key)) {
                        fullInvoke = true;
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                        break;
                    }
                }
                if (!fullInvoke && data['class']) {
                    // ensure collecting deps for deep class bindings for future updates
                    traverse(data['class']);
                }
            }
        }
        else if (elm.data !== vnode.text) {
            elm.data = vnode.text;
        }
        return true;
    }
    function assertNodeMatch(node, vnode, inVPre) {
        if (isDef(vnode.tag)) {
            return (vnode.tag.indexOf('vue-component') === 0 ||
                (!isUnknownElement(vnode, inVPre) &&
                    vnode.tag.toLowerCase() ===
                        (node.tagName && node.tagName.toLowerCase())));
        }
        else {
            return node.nodeType === (vnode.isComment ? 8 : 3);
        }
    }
    return function patch(oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
            if (isDef(oldVnode))
                invokeDestroyHook(oldVnode);
            return;
        }
        var isInitialPatch = false;
        var insertedVnodeQueue = [];
        if (isUndef(oldVnode)) {
            // empty mount (likely as component), create new root element
            isInitialPatch = true;
            createElm(vnode, insertedVnodeQueue);
        }
        else {
            var isRealElement = isDef(oldVnode.nodeType);
            if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
            }
            else {
                if (isRealElement) {
                    // mounting to a real element
                    // check if this is server-rendered content and if we can perform
                    // a successful hydration.
                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                        oldVnode.removeAttribute(SSR_ATTR);
                        hydrating = true;
                    }
                    if (isTrue(hydrating)) {
                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                            invokeInsertHook(vnode, insertedVnodeQueue, true);
                            return oldVnode;
                        }
                        else if (true) {
                            warn('The client-side rendered virtual DOM tree is not matching ' +
                                'server-rendered content. This is likely caused by incorrect ' +
                                'HTML markup, for example nesting block-level elements inside ' +
                                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                'full client-side render.');
                        }
                    }
                    // either not server-rendered, or hydration failed.
                    // create an empty node and replace it
                    oldVnode = emptyNodeAt(oldVnode);
                }
                // replacing existing element
                var oldElm = oldVnode.elm;
                var parentElm = nodeOps.parentNode(oldElm);
                // create new node
                createElm(vnode, insertedVnodeQueue, 
                // extremely rare edge case: do not insert if old element is in a
                // leaving transition. Only happens when combining transition +
                // keep-alive + HOCs. (#4590)
                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));
                // update parent placeholder node element, recursively
                if (isDef(vnode.parent)) {
                    var ancestor = vnode.parent;
                    var patchable = isPatchable(vnode);
                    while (ancestor) {
                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {
                            cbs.destroy[i_8](ancestor);
                        }
                        ancestor.elm = vnode.elm;
                        if (patchable) {
                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {
                                cbs.create[i_9](emptyNode, ancestor);
                            }
                            // #6513
                            // invoke insert hooks that may have been merged by create hooks.
                            // e.g. for directives that uses the "inserted" hook.
                            var insert_1 = ancestor.data.hook.insert;
                            if (insert_1.merged) {
                                // start at index 1 to avoid re-invoking component mounted hook
                                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {
                                    insert_1.fns[i_10]();
                                }
                            }
                        }
                        else {
                            registerRef(ancestor);
                        }
                        ancestor = ancestor.parent;
                    }
                }
                // destroy old node
                if (isDef(parentElm)) {
                    removeVnodes([oldVnode], 0, 0);
                }
                else if (isDef(oldVnode.tag)) {
                    invokeDestroyHook(oldVnode);
                }
            }
        }
        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm;
    };
}

var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
        // @ts-expect-error emptyNode is not VNodeWithData
        updateDirectives(vnode, emptyNode);
    }
};
function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
    }
}
function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
    var dirsWithInsert = [];
    var dirsWithPostpatch = [];
    var key, oldDir, dir;
    for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
            // new directive, bind
            callHook(dir, 'bind', vnode, oldVnode);
            if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
            }
        }
        else {
            // existing directive, update
            dir.oldValue = oldDir.value;
            dir.oldArg = oldDir.arg;
            callHook(dir, 'update', vnode, oldVnode);
            if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
            }
        }
    }
    if (dirsWithInsert.length) {
        var callInsert = function () {
            for (var i = 0; i < dirsWithInsert.length; i++) {
                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
            }
        };
        if (isCreate) {
            mergeVNodeHook(vnode, 'insert', callInsert);
        }
        else {
            callInsert();
        }
    }
    if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, 'postpatch', function () {
            for (var i = 0; i < dirsWithPostpatch.length; i++) {
                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
            }
        });
    }
    if (!isCreate) {
        for (key in oldDirs) {
            if (!newDirs[key]) {
                // no longer present, unbind
                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
            }
        }
    }
}
var emptyModifiers = Object.create(null);
function normalizeDirectives(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
        // $flow-disable-line
        return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
            // $flow-disable-line
            dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        if (vm._setupState && vm._setupState.__sfc) {
            var setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);
            if (typeof setupDef === 'function') {
                dir.def = {
                    bind: setupDef,
                    update: setupDef,
                };
            }
            else {
                dir.def = setupDef;
            }
        }
        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
}
function getRawDirName(dir) {
    return (dir.rawName || "".concat(dir.name, ".").concat(Object.keys(dir.modifiers || {}).join('.')));
}
function callHook(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
        try {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        }
        catch (e) {
            handleError(e, vnode.context, "directive ".concat(dir.name, " ").concat(hook, " hook"));
        }
    }
}

var baseModules = [ref, directives];

function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {
        attrs = vnode.data.attrs = extend({}, attrs);
    }
    for (key in attrs) {
        cur = attrs[key];
        old = oldAttrs[key];
        if (old !== cur) {
            setAttr(elm, key, cur, vnode.data.pre);
        }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
        setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
        if (isUndef(attrs[key])) {
            if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
            }
            else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
            }
        }
    }
}
function setAttr(el, key, value, isInPre) {
    if (isInPre || el.tagName.indexOf('-') > -1) {
        baseSetAttr(el, key, value);
    }
    else if (isBooleanAttr(key)) {
        // set attribute for blank value
        // e.g. <option disabled>Select one</option>
        if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
        }
        else {
            // technically allowfullscreen is a boolean attribute for <iframe>,
            // but Flash expects a value of "true" when used on <embed> tag
            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
            el.setAttribute(key, value);
        }
    }
    else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
    }
    else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        baseSetAttr(el, key, value);
    }
}
function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
    }
    else {
        // #7138: IE10 & 11 fires input event when setting placeholder on
        // <textarea>... block the first input event and remove the blocker
        // immediately.
        /* istanbul ignore if */
        if (isIE &&
            !isIE9 &&
            el.tagName === 'TEXTAREA' &&
            key === 'placeholder' &&
            value !== '' &&
            !el.__ieph) {
            var blocker_1 = function (e) {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker_1);
            };
            el.addEventListener('input', blocker_1);
            // $flow-disable-line
            el.__ieph = true; /* IE placeholder patched */
        }
        el.setAttribute(key, value);
    }
}
var attrs = {
    create: updateAttrs,
    update: updateAttrs
};

function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) &&
        isUndef(data.class) &&
        (isUndef(oldData) ||
            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
        return;
    }
    var cls = genClassForVnode(vnode);
    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
        cls = concat(cls, stringifyClass(transitionClass));
    }
    // set the class
    if (cls !== el._prevClass) {
        el.setAttribute('class', cls);
        el._prevClass = cls;
    }
}
var klass = {
    create: updateClass,
    update: updateClass
};

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
        // IE input[type=range] only supports `change` event
        var event_1 = isIE ? 'change' : 'input';
        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);
        delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
    }
}
var target;
function createOnceHandler(event, handler, capture) {
    var _target = target; // save current target element in closure
    return function onceHandler() {
        var res = handler.apply(null, arguments);
        if (res !== null) {
            remove(event, onceHandler, capture, _target);
        }
    };
}
// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(name, handler, capture, passive) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
        var attachedTimestamp_1 = currentFlushTimestamp;
        var original_1 = handler;
        //@ts-expect-error
        handler = original_1._wrapper = function (e) {
            if (
            // no bubbling, should always fire.
            // this is just a safety net in case event.timeStamp is unreliable in
            // certain weird environments...
            e.target === e.currentTarget ||
                // event is fired after handler attachment
                e.timeStamp >= attachedTimestamp_1 ||
                // bail for environments that have buggy event.timeStamp implementations
                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
                // #9681 QtWebEngine event.timeStamp is negative value
                e.timeStamp <= 0 ||
                // #9448 bail if event is fired in another document in a multi-page
                // electron/nw.js app, since event.timeStamp will be using a different
                // starting reference
                e.target.ownerDocument !== document) {
                return original_1.apply(this, arguments);
            }
        };
    }
    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}
function remove(name, handler, capture, _target) {
    (_target || target).removeEventListener(name, 
    //@ts-expect-error
    handler._wrapper || handler, capture);
}
function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    // vnode is empty when removing all listeners,
    // and use old vnode dom element
    target = vnode.elm || oldVnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
    target = undefined;
}
var events = {
    create: updateDOMListeners,
    update: updateDOMListeners,
    // @ts-expect-error emptyNode has actually data
    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }
};

var svgContainer;
function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {
        props = vnode.data.domProps = extend({}, props);
    }
    for (key in oldProps) {
        if (!(key in props)) {
            elm[key] = '';
        }
    }
    for (key in props) {
        cur = props[key];
        // ignore children if the node has textContent or innerHTML,
        // as these will throw away existing DOM nodes and cause removal errors
        // on subsequent patches (#3360)
        if (key === 'textContent' || key === 'innerHTML') {
            if (vnode.children)
                vnode.children.length = 0;
            if (cur === oldProps[key])
                continue;
            // #6601 work around Chrome version <= 55 bug where single textNode
            // replaced by innerHTML/textContent retains its parentNode property
            if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
            }
        }
        if (key === 'value' && elm.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified
            elm._value = cur;
            // avoid resetting cursor position when value is the same
            var strCur = isUndef(cur) ? '' : String(cur);
            if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
            }
        }
        else if (key === 'innerHTML' &&
            isSVG(elm.tagName) &&
            isUndef(elm.innerHTML)) {
            // IE doesn't support innerHTML for SVG elements
            svgContainer = svgContainer || document.createElement('div');
            svgContainer.innerHTML = "<svg>".concat(cur, "</svg>");
            var svg = svgContainer.firstChild;
            while (elm.firstChild) {
                elm.removeChild(elm.firstChild);
            }
            while (svg.firstChild) {
                elm.appendChild(svg.firstChild);
            }
        }
        else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        cur !== oldProps[key]) {
            // some property updates can throw
            // e.g. `value` on <progress> w/ non-finite value
            try {
                elm[key] = cur;
            }
            catch (e) { }
        }
    }
}
function shouldUpdateValue(elm, checkVal) {
    return (
    //@ts-expect-error
    !elm.composing &&
        (elm.tagName === 'OPTION' ||
            isNotInFocusAndDirty(elm, checkVal) ||
            isDirtyWithModifiers(elm, checkVal)));
}
function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
        notInFocus = document.activeElement !== elm;
    }
    catch (e) { }
    return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
        if (modifiers.number) {
            return toNumber(value) !== toNumber(newVal);
        }
        if (modifiers.trim) {
            return value.trim() !== newVal.trim();
        }
    }
    return value !== newVal;
}
var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
};

var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
        if (item) {
            var tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return res;
});
// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
}
// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
        return parseStyleText(bindingStyle);
    }
    return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;
    if (checkChild) {
        var childNode = vnode;
        while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (childNode &&
                childNode.data &&
                (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
            }
        }
    }
    if ((styleData = normalizeStyleData(vnode.data))) {
        extend(res, styleData);
    }
    var parentNode = vnode;
    // @ts-expect-error parentNode.parent not VNodeWithData
    while ((parentNode = parentNode.parent)) {
        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
            extend(res, styleData);
        }
    }
    return res;
}

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
    }
    else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    }
    else {
        var normalizedName = normalize(name);
        if (Array.isArray(val)) {
            // Support values array created by autoprefixer, e.g.
            // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
            // Set them one by one, and the browser will only set those it can recognize
            for (var i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
            }
        }
        else {
            el.style[normalizedName] = val;
        }
    }
};
var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
        return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
        var name_1 = vendorNames[i] + capName;
        if (name_1 in emptyStyle) {
            return name_1;
        }
    }
});
function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticStyle) &&
        isUndef(data.style) &&
        isUndef(oldData.staticStyle) &&
        isUndef(oldData.style)) {
        return;
    }
    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;
    var style = normalizeStyleBinding(vnode.data.style) || {};
    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
    var newStyle = getStyle(vnode, true);
    for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
            setProp(el, name, '');
        }
    }
    for (name in newStyle) {
        cur = newStyle[name];
        if (cur !== oldStyle[name]) {
            // ie9 setting to null has no effect, must use empty string
            setProp(el, name, cur == null ? '' : cur);
        }
    }
}
var style = {
    create: updateStyle,
    update: updateStyle
};

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
        }
        else {
            el.classList.add(cls);
        }
    }
    else {
        var cur = " ".concat(el.getAttribute('class') || '', " ");
        if (cur.indexOf(' ' + cls + ' ') < 0) {
            el.setAttribute('class', (cur + cls).trim());
        }
    }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
        }
        else {
            el.classList.remove(cls);
        }
        if (!el.classList.length) {
            el.removeAttribute('class');
        }
    }
    else {
        var cur = " ".concat(el.getAttribute('class') || '', " ");
        var tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, ' ');
        }
        cur = cur.trim();
        if (cur) {
            el.setAttribute('class', cur);
        }
        else {
            el.removeAttribute('class');
        }
    }
}

function resolveTransition(def) {
    if (!def) {
        return;
    }
    /* istanbul ignore else */
    if (typeof def === 'object') {
        var res = {};
        if (def.css !== false) {
            extend(res, autoCssTransition(def.name || 'v'));
        }
        extend(res, def);
        return res;
    }
    else if (typeof def === 'string') {
        return autoCssTransition(def);
    }
}
var autoCssTransition = cached(function (name) {
    return {
        enterClass: "".concat(name, "-enter"),
        enterToClass: "".concat(name, "-enter-to"),
        enterActiveClass: "".concat(name, "-enter-active"),
        leaveClass: "".concat(name, "-leave"),
        leaveToClass: "".concat(name, "-leave-to"),
        leaveActiveClass: "".concat(name, "-leave-active")
    };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';
// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
        window.onwebkittransitionend !== undefined) {
        transitionProp = 'WebkitTransition';
        transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
        window.onwebkitanimationend !== undefined) {
        animationProp = 'WebkitAnimation';
        animationEndEvent = 'webkitAnimationEnd';
    }
}
// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
    ? window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout
    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };
function nextFrame(fn) {
    raf(function () {
        // @ts-expect-error
        raf(fn);
    });
}
function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass(el, cls);
    }
}
function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
        remove$2(el._transitionClasses, cls);
    }
    removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;
    if (!type)
        return cb();
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
        el.removeEventListener(event, onEnd);
        cb();
    };
    var onEnd = function (e) {
        if (e.target === el) {
            if (++ended >= propCount) {
                end();
            }
        }
    };
    setTimeout(function () {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
}
var transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);
    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
        type: type,
        timeout: timeout,
        propCount: propCount,
        hasTransform: hasTransform
    };
}
function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map(function (d, i) {
        return toMs(d) + toMs(delays[i]);
    }));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}

function enter(vnode, toggleDisplay) {
    var el = vnode.elm;
    // call leave callback now
    if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
        return;
    }
    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
        return;
    }
    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;
    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
    }
    var isAppear = !context._isMounted || !vnode.isRootInsert;
    if (isAppear && !appear && appear !== '') {
        return;
    }
    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear
        ? appearCancelled || enterCancelled
        : enterCancelled;
    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
    if ( true && explicitEnterDuration != null) {
        checkDuration(explicitEnterDuration, 'enter', vnode);
    }
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);
    var cb = (el._enterCb = once(function () {
        if (expectsCSS) {
            removeTransitionClass(el, toClass);
            removeTransitionClass(el, activeClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, startClass);
            }
            enterCancelledHook && enterCancelledHook(el);
        }
        else {
            afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
    }));
    if (!vnode.data.show) {
        // remove pending leave element on enter by injecting an insert hook
        mergeVNodeHook(vnode, 'insert', function () {
            var parent = el.parentNode;
            var pendingNode = parent && parent._pending && parent._pending[vnode.key];
            if (pendingNode &&
                pendingNode.tag === vnode.tag &&
                pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
            }
            enterHook && enterHook(el, cb);
        });
    }
    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(function () {
            removeTransitionClass(el, startClass);
            // @ts-expect-error
            if (!cb.cancelled) {
                addTransitionClass(el, toClass);
                if (!userWantsControl) {
                    if (isValidDuration(explicitEnterDuration)) {
                        setTimeout(cb, explicitEnterDuration);
                    }
                    else {
                        whenTransitionEnds(el, type, cb);
                    }
                }
            }
        });
    }
    if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
    }
    if (!expectsCSS && !userWantsControl) {
        cb();
    }
}
function leave(vnode, rm) {
    var el = vnode.elm;
    // call enter callback now
    if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
    }
    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
        return rm();
    }
    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
        return;
    }
    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;
    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);
    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
    if ( true && isDef(explicitLeaveDuration)) {
        checkDuration(explicitLeaveDuration, 'leave', vnode);
    }
    var cb = (el._leaveCb = once(function () {
        if (el.parentNode && el.parentNode._pending) {
            el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
            }
            leaveCancelled && leaveCancelled(el);
        }
        else {
            rm();
            afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
    }));
    if (delayLeave) {
        delayLeave(performLeave);
    }
    else {
        performLeave();
    }
    function performLeave() {
        // the delayed leave may have already been cancelled
        // @ts-expect-error
        if (cb.cancelled) {
            return;
        }
        // record leaving element
        if (!vnode.data.show && el.parentNode) {
            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
                vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
            addTransitionClass(el, leaveClass);
            addTransitionClass(el, leaveActiveClass);
            nextFrame(function () {
                removeTransitionClass(el, leaveClass);
                // @ts-expect-error
                if (!cb.cancelled) {
                    addTransitionClass(el, leaveToClass);
                    if (!userWantsControl) {
                        if (isValidDuration(explicitLeaveDuration)) {
                            setTimeout(cb, explicitLeaveDuration);
                        }
                        else {
                            whenTransitionEnds(el, type, cb);
                        }
                    }
                }
            });
        }
        leave && leave(el, cb);
        if (!expectsCSS && !userWantsControl) {
            cb();
        }
    }
}
// only used in dev mode
function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
        warn("<transition> explicit ".concat(name, " duration is not a valid number - ") +
            "got ".concat(JSON.stringify(val), "."), vnode.context);
    }
    else if (isNaN(val)) {
        warn("<transition> explicit ".concat(name, " duration is NaN - ") +
            'the duration expression might be incorrect.', vnode.context);
    }
}
function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
        return false;
    }
    // @ts-expect-error
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
        // invoker
        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    }
    else {
        // @ts-expect-error
        return (fn._length || fn.length) > 1;
    }
}
function _enter(_, vnode) {
    if (vnode.data.show !== true) {
        enter(vnode);
    }
}
var transition = inBrowser
    ? {
        create: _enter,
        activate: _enter,
        remove: function (vnode, rm) {
            /* istanbul ignore else */
            if (vnode.data.show !== true) {
                // @ts-expect-error
                leave(vnode, rm);
            }
            else {
                rm();
            }
        }
    }
    : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */
/* istanbul ignore if */
if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
        var el = document.activeElement;
        // @ts-expect-error
        if (el && el.vmodel) {
            trigger(el, 'input');
        }
    });
}
var directive = {
    inserted: function (el, binding, vnode, oldVnode) {
        if (vnode.tag === 'select') {
            // #6903
            if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', function () {
                    directive.componentUpdated(el, binding, vnode);
                });
            }
            else {
                setSelected(el, binding, vnode.context);
            }
            el._vOptions = [].map.call(el.options, getValue);
        }
        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
            el._vModifiers = binding.modifiers;
            if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd);
                // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.
                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */
                if (isIE9) {
                    el.vmodel = true;
                }
            }
        }
    },
    componentUpdated: function (el, binding, vnode) {
        if (vnode.tag === 'select') {
            setSelected(el, binding, vnode.context);
            // in case the options rendered by v-for have changed,
            // it's possible that the value is out-of-sync with the rendered options.
            // detect such cases and filter out values that no longer has a matching
            // option in the DOM.
            var prevOptions_1 = el._vOptions;
            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));
            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {
                // trigger change event if
                // no matching option found for at least one value
                var needReset = el.multiple
                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })
                    : binding.value !== binding.oldValue &&
                        hasNoMatchingOption(binding.value, curOptions_1);
                if (needReset) {
                    trigger(el, 'change');
                }
            }
        }
    }
};
function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
        setTimeout(function () {
            actuallySetSelected(el, binding, vm);
        }, 0);
    }
}
function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
         true &&
            warn("<select multiple v-model=\"".concat(binding.expression, "\"> ") +
                "expects an Array value for its binding, but got ".concat(Object.prototype.toString
                    .call(value)
                    .slice(8, -1)), vm);
        return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
            selected = looseIndexOf(value, getValue(option)) > -1;
            if (option.selected !== selected) {
                option.selected = selected;
            }
        }
        else {
            if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                    el.selectedIndex = i;
                }
                return;
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}
function hasNoMatchingOption(value, options) {
    return options.every(function (o) { return !looseEqual(o, value); });
}
function getValue(option) {
    return '_value' in option ? option._value : option.value;
}
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing)
        return;
    e.target.composing = false;
    trigger(e.target, 'input');
}
function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
    // @ts-expect-error
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
        ? locateNode(vnode.componentInstance._vnode)
        : vnode;
}
var show = {
    bind: function (el, _a, vnode) {
        var value = _a.value;
        vnode = locateNode(vnode);
        var transition = vnode.data && vnode.data.transition;
        var originalDisplay = (el.__vOriginalDisplay =
            el.style.display === 'none' ? '' : el.style.display);
        if (value && transition) {
            vnode.data.show = true;
            enter(vnode, function () {
                el.style.display = originalDisplay;
            });
        }
        else {
            el.style.display = value ? originalDisplay : 'none';
        }
    },
    update: function (el, _a, vnode) {
        var value = _a.value, oldValue = _a.oldValue;
        /* istanbul ignore if */
        if (!value === !oldValue)
            return;
        vnode = locateNode(vnode);
        var transition = vnode.data && vnode.data.transition;
        if (transition) {
            vnode.data.show = true;
            if (value) {
                enter(vnode, function () {
                    el.style.display = el.__vOriginalDisplay;
                });
            }
            else {
                leave(vnode, function () {
                    el.style.display = 'none';
                });
            }
        }
        else {
            el.style.display = value ? el.__vOriginalDisplay : 'none';
        }
    },
    unbind: function (el, binding, vnode, oldVnode, isDestroy) {
        if (!isDestroy) {
            el.style.display = el.__vOriginalDisplay;
        }
    }
};

var platformDirectives = {
    model: directive,
    show: show
};

// Provides transition support for a single element/component.
var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
};
// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children));
    }
    else {
        return vnode;
    }
}
function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
        data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key in listeners) {
        data[camelize(key)] = listeners[key];
    }
    return data;
}
function placeholder(h, rawChild) {
    // @ts-expect-error
    if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h('keep-alive', {
            props: rawChild.componentOptions.propsData
        });
    }
}
function hasParentTransition(vnode) {
    while ((vnode = vnode.parent)) {
        if (vnode.data.transition) {
            return true;
        }
    }
}
function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
}
var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };
var isVShowDirective = function (d) { return d.name === 'show'; };
var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,
    render: function (h) {
        var _this = this;
        var children = this.$slots.default;
        if (!children) {
            return;
        }
        // filter out text nodes (possible whitespaces)
        children = children.filter(isNotTextNode);
        /* istanbul ignore if */
        if (!children.length) {
            return;
        }
        // warn multiple elements
        if ( true && children.length > 1) {
            warn('<transition> can only be used on a single element. Use ' +
                '<transition-group> for lists.', this.$parent);
        }
        var mode = this.mode;
        // warn invalid mode
        if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {
            warn('invalid <transition> mode: ' + mode, this.$parent);
        }
        var rawChild = children[0];
        // if this is a component root node and the component's
        // parent container node also has transition, skip.
        if (hasParentTransition(this.$vnode)) {
            return rawChild;
        }
        // apply transition data to child
        // use getRealChild() to ignore abstract components e.g. keep-alive
        var child = getRealChild(rawChild);
        /* istanbul ignore if */
        if (!child) {
            return rawChild;
        }
        if (this._leaving) {
            return placeholder(h, rawChild);
        }
        // ensure a key that is unique to the vnode type and to this transition
        // component instance. This key will be used to remove pending leaving nodes
        // during entering.
        var id = "__transition-".concat(this._uid, "-");
        child.key =
            child.key == null
                ? child.isComment
                    ? id + 'comment'
                    : id + child.tag
                : isPrimitive(child.key)
                    ? String(child.key).indexOf(id) === 0
                        ? child.key
                        : id + child.key
                    : child.key;
        var data = ((child.data || (child.data = {})).transition =
            extractTransitionData(this));
        var oldRawChild = this._vnode;
        var oldChild = getRealChild(oldRawChild);
        // mark v-show
        // so that the transition module can hand over the control to the directive
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
            child.data.show = true;
        }
        if (oldChild &&
            oldChild.data &&
            !isSameChild(child, oldChild) &&
            !isAsyncPlaceholder(oldChild) &&
            // #6687 component root is a comment node
            !(oldChild.componentInstance &&
                oldChild.componentInstance._vnode.isComment)) {
            // replace old child transition data with fresh one
            // important for dynamic transitions!
            var oldData = (oldChild.data.transition = extend({}, data));
            // handle transition mode
            if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', function () {
                    _this._leaving = false;
                    _this.$forceUpdate();
                });
                return placeholder(h, rawChild);
            }
            else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                    return oldRawChild;
                }
                var delayedLeave_1;
                var performLeave = function () {
                    delayedLeave_1();
                };
                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', function (leave) {
                    delayedLeave_1 = leave;
                });
            }
        }
        return rawChild;
    }
};

// Provides transition support for list items.
var props = extend({
    tag: String,
    moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
    props: props,
    beforeMount: function () {
        var _this = this;
        var update = this._update;
        this._update = function (vnode, hydrating) {
            var restoreActiveInstance = setActiveInstance(_this);
            // force removing pass
            _this.__patch__(_this._vnode, _this.kept, false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
            );
            _this._vnode = _this.kept;
            restoreActiveInstance();
            update.call(_this, vnode, hydrating);
        };
    },
    render: function (h) {
        var tag = this.tag || this.$vnode.data.tag || 'span';
        var map = Object.create(null);
        var prevChildren = (this.prevChildren = this.children);
        var rawChildren = this.$slots.default || [];
        var children = (this.children = []);
        var transitionData = extractTransitionData(this);
        for (var i = 0; i < rawChildren.length; i++) {
            var c = rawChildren[i];
            if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                    children.push(c);
                    map[c.key] = c;
                    (c.data || (c.data = {})).transition = transitionData;
                }
                else if (true) {
                    var opts = c.componentOptions;
                    var name_1 = opts
                        ? getComponentName(opts.Ctor.options) || opts.tag || ''
                        : c.tag;
                    warn("<transition-group> children must be keyed: <".concat(name_1, ">"));
                }
            }
        }
        if (prevChildren) {
            var kept = [];
            var removed = [];
            for (var i = 0; i < prevChildren.length; i++) {
                var c = prevChildren[i];
                c.data.transition = transitionData;
                // @ts-expect-error .getBoundingClientRect is not typed in Node
                c.data.pos = c.elm.getBoundingClientRect();
                if (map[c.key]) {
                    kept.push(c);
                }
                else {
                    removed.push(c);
                }
            }
            this.kept = h(tag, null, kept);
            this.removed = removed;
        }
        return h(tag, null, children);
    },
    updated: function () {
        var children = this.prevChildren;
        var moveClass = this.moveClass || (this.name || 'v') + '-move';
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
            return;
        }
        // we divide the work into three loops to avoid mixing DOM reads and writes
        // in each iteration - which helps prevent layout thrashing.
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);
        // force reflow to put everything in position
        // assign to this to avoid being removed in tree-shaking
        // $flow-disable-line
        this._reflow = document.body.offsetHeight;
        children.forEach(function (c) {
            if (c.data.moved) {
                var el_1 = c.elm;
                var s = el_1.style;
                addTransitionClass(el_1, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {
                    if (e && e.target !== el_1) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el_1.removeEventListener(transitionEndEvent, cb);
                        el_1._moveCb = null;
                        removeTransitionClass(el_1, moveClass);
                    }
                }));
            }
        });
    },
    methods: {
        hasMove: function (el, moveClass) {
            /* istanbul ignore if */
            if (!hasTransition) {
                return false;
            }
            /* istanbul ignore if */
            if (this._hasMove) {
                return this._hasMove;
            }
            // Detect whether an element with the move class applied has
            // CSS transitions. Since the element may be inside an entering
            // transition at this very moment, we make a clone of it and remove
            // all other transition classes applied to ensure only the move class
            // is applied.
            var clone = el.cloneNode();
            if (el._transitionClasses) {
                el._transitionClasses.forEach(function (cls) {
                    removeClass(clone, cls);
                });
            }
            addClass(clone, moveClass);
            clone.style.display = 'none';
            this.$el.appendChild(clone);
            var info = getTransitionInfo(clone);
            this.$el.removeChild(clone);
            return (this._hasMove = info.hasTransform);
        }
    }
};
function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
        c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
        c.elm._enterCb();
    }
}
function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
        c.data.moved = true;
        var s = c.elm.style;
        s.transform = s.WebkitTransform = "translate(".concat(dx, "px,").concat(dy, "px)");
        s.transitionDuration = '0s';
    }
}

var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
};

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;
// public mount method
Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
};
// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
    setTimeout(function () {
        if (config.devtools) {
            if (devtools) {
                devtools.emit('init', Vue);
            }
            else if (true) {
                // @ts-expect-error
                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' +
                    'https://github.com/vuejs/vue-devtools');
            }
        }
        if ( true &&
            config.productionTip !== false &&
            typeof console !== 'undefined') {
            // @ts-expect-error
            console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" +
                "Make sure to turn on production mode when deploying for production.\n" +
                "See more tips at https://vuejs.org/guide/deployment.html");
        }
    }, 0);
}




/***/ }),
/* 16 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NavigationFailureType": function() { return /* binding */ NavigationFailureType; },
/* harmony export */   "RouterLink": function() { return /* binding */ Link; },
/* harmony export */   "RouterView": function() { return /* binding */ View; },
/* harmony export */   "START_LOCATION": function() { return /* binding */ START; },
/* harmony export */   "default": function() { return /* binding */ VueRouter$1; },
/* harmony export */   "isNavigationFailure": function() { return /* binding */ isNavigationFailure; },
/* harmony export */   "version": function() { return /* binding */ version; }
/* harmony export */ });
/*!
  * vue-router v3.6.5
  * (c) 2022 Evan You
  * @license MIT
  */
/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if (!condition) {
    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
  }
}

function extend (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
    .replace(encodeReserveRE, encodeReserveReplacer)
    .replace(commaRE, ','); };

function decode (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    if (true) {
      warn(false, ("Error decoding \"" + str + "\". Leaving it intact."));
    }
  }
  return str
}

function resolveQuery (
  query,
  extraQuery,
  _parseQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
     true && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    var value = extraQuery[key];
    parsedQuery[key] = Array.isArray(value)
      ? value.map(castQueryParamValue)
      : castQueryParamValue(value);
  }
  return parsedQuery
}

var castQueryParamValue = function (value) { return (value == null || typeof value === 'object' ? value : String(value)); };

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj
    ? Object.keys(obj)
      .map(function (key) {
        var val = obj[key];

        if (val === undefined) {
          return ''
        }

        if (val === null) {
          return encode(key)
        }

        if (Array.isArray(val)) {
          var result = [];
          val.forEach(function (val2) {
            if (val2 === undefined) {
              return
            }
            if (val2 === null) {
              result.push(encode(key));
            } else {
              result.push(encode(key) + '=' + encode(val2));
            }
          });
          return result.join('&')
        }

        return encode(key) + '=' + encode(val)
      })
      .filter(function (x) { return x.length > 0; })
      .join('&')
    : null;
  return res ? ("?" + res) : ''
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom,
  router
) {
  var stringifyQuery = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);
  }
  return Object.freeze(route)
}

function clone (value) {
  if (Array.isArray(value)) {
    return value.map(clone)
  } else if (value && typeof value === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res
  } else {
    return value
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (
  ref,
  _stringifyQuery
) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash
}

function isSameRoute (a, b, onlyPath) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && (onlyPath ||
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query))
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      (onlyPath || (
        a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params))
      )
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  // handle null value #1566
  if (!a || !b) { return a === b }
  var aKeys = Object.keys(a).sort();
  var bKeys = Object.keys(b).sort();
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key, i) {
    var aVal = a[key];
    var bKey = bKeys[i];
    if (bKey !== key) { return false }
    var bVal = b[key];
    // query values can be null and undefined
    if (aVal == null || bVal == null) { return aVal === bVal }
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

function handleRouteEntered (route) {
  for (var i = 0; i < route.matched.length; i++) {
    var record = route.matched[i];
    for (var name in record.instances) {
      var instance = record.instances[name];
      var cbs = record.enteredCbs[name];
      if (!instance || !cbs) { continue }
      delete record.enteredCbs[name];
      for (var i$1 = 0; i$1 < cbs.length; i$1++) {
        if (!instance._isBeingDestroyed) { cbs[i$1](instance); }
      }
    }
  }
}

var View = {
  name: 'RouterView',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    // used by devtools to display a router-view badge
    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      var vnodeData = parent.$vnode ? parent.$vnode.data : {};
      if (vnodeData.routerView) {
        depth++;
      }
      if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      var cachedData = cache[name];
      var cachedComponent = cachedData && cachedData.component;
      if (cachedComponent) {
        // #2301
        // pass props
        if (cachedData.configProps) {
          fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);
        }
        return h(cachedComponent, data, children)
      } else {
        // render previous empty view
        return h()
      }
    }

    var matched = route.matched[depth];
    var component = matched && matched.components[name];

    // render empty node if no matched route or no config component
    if (!matched || !component) {
      cache[name] = null;
      return h()
    }

    // cache component
    cache[name] = { component: component };

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // register instance in init hook
    // in case kept-alive component be actived when routes changed
    data.hook.init = function (vnode) {
      if (vnode.data.keepAlive &&
        vnode.componentInstance &&
        vnode.componentInstance !== matched.instances[name]
      ) {
        matched.instances[name] = vnode.componentInstance;
      }

      // if the route transition has already been confirmed then we weren't
      // able to call the cbs during confirmation as the component was not
      // registered yet, so we call it here.
      handleRouteEntered(route);
    };

    var configProps = matched.props && matched.props[name];
    // save route and configProps in cache
    if (configProps) {
      extend(cache[name], {
        route: route,
        configProps: configProps
      });
      fillPropsinData(component, data, route, configProps);
    }

    return h(component, data, children)
  }
};

function fillPropsinData (component, data, route, configProps) {
  // resolve props
  var propsToPass = data.props = resolveProps(route, configProps);
  if (propsToPass) {
    // clone to prevent mutation
    propsToPass = data.props = extend({}, propsToPass);
    // pass non-declared props as attrs
    var attrs = data.attrs = data.attrs || {};
    for (var key in propsToPass) {
      if (!component.props || !(key in component.props)) {
        attrs[key] = propsToPass[key];
        delete propsToPass[key];
      }
    }
  }
}

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      if (true) {
        warn(
          false,
          "props in \"" + (route.path) + "\" is a " + (typeof config) + ", " +
          "expecting an object, function or boolean."
        );
      }
  }
}

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/(?:\s*\/)+/g, '/')
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}
pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  params = params || {};
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = pathToRegexp_1.compile(path));

    // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}
    // and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string
    if (typeof params.pathMatch === 'string') { params[0] = params.pathMatch; }

    return filler(params, { pretty: true })
  } catch (e) {
    if (true) {
      // Fix #3072 no warn if `pathMatch` is string
      warn(typeof params.pathMatch === 'string', ("missing param for " + routeMsg + ": " + (e.message)));
    }
    return ''
  } finally {
    // delete the 0 if it was added
    delete params[0];
  }
}

/*  */

function normalizeLocation (
  raw,
  current,
  append,
  router
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next._normalized) {
    return next
  } else if (next.name) {
    next = extend({}, raw);
    var params = next.params;
    if (params && typeof params === 'object') {
      next.params = extend({}, params);
    }
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = extend({}, next);
    next._normalized = true;
    var params$1 = extend(extend({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params$1;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params$1, ("path " + (current.path)));
    } else if (true) {
      warn(false, "relative params navigation requires a current route.");
    }
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath;

  var query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  );

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var noop = function () {};

var warnedCustomSlot;
var warnedTagProp;
var warnedEventProp;

var Link = {
  name: 'RouterLink',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    custom: Boolean,
    exact: Boolean,
    exactPath: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    ariaCurrentValue: {
      type: String,
      default: 'page'
    },
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(
      this.to,
      current,
      this.append
    );
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback =
      globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback =
      globalExactActiveClass == null
        ? 'router-link-exact-active'
        : globalExactActiveClass;
    var activeClass =
      this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass =
      this.exactActiveClass == null
        ? exactActiveClassFallback
        : this.exactActiveClass;

    var compareTarget = route.redirectedFrom
      ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)
      : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget, this.exactPath);
    classes[activeClass] = this.exact || this.exactPath
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget);

    var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1$1.replace) {
          router.replace(location, noop);
        } else {
          router.push(location, noop);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = { class: classes };

    var scopedSlot =
      !this.$scopedSlots.$hasNormal &&
      this.$scopedSlots.default &&
      this.$scopedSlots.default({
        href: href,
        route: route,
        navigate: handler,
        isActive: classes[activeClass],
        isExactActive: classes[exactActiveClass]
      });

    if (scopedSlot) {
      if ( true && !this.custom) {
        !warnedCustomSlot && warn(false, 'In Vue Router 4, the v-slot API will by default wrap its content with an <a> element. Use the custom prop to remove this warning:\n<router-link v-slot="{ navigate, href }" custom></router-link>\n');
        warnedCustomSlot = true;
      }
      if (scopedSlot.length === 1) {
        return scopedSlot[0]
      } else if (scopedSlot.length > 1 || !scopedSlot.length) {
        if (true) {
          warn(
            false,
            ("<router-link> with to=\"" + (this.to) + "\" is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.")
          );
        }
        return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)
      }
    }

    if (true) {
      if ('tag' in this.$options.propsData && !warnedTagProp) {
        warn(
          false,
          "<router-link>'s tag prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link."
        );
        warnedTagProp = true;
      }
      if ('event' in this.$options.propsData && !warnedEventProp) {
        warn(
          false,
          "<router-link>'s event prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link."
        );
        warnedEventProp = true;
      }
    }

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href, 'aria-current': ariaCurrentValue };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var aData = (a.data = extend({}, a.data));
        aData.on = aData.on || {};
        // transform existing events in both objects into arrays so we can push later
        for (var event in aData.on) {
          var handler$1 = aData.on[event];
          if (event in on) {
            aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];
          }
        }
        // append new listeners for router-link
        for (var event$1 in on) {
          if (event$1 in aData.on) {
            // on[event] is always a function
            aData.on[event$1].push(on[event$1]);
          } else {
            aData.on[event$1] = handler;
          }
        }

        var aAttrs = (a.data.attrs = extend({}, a.data.attrs));
        aAttrs.href = href;
        aAttrs['aria-current'] = ariaCurrentValue;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed && _Vue === Vue) { return }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) { return v !== undefined; };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed () {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this._routerRoot._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this._routerRoot._route }
  });

  Vue.component('RouterView', View);
  Vue.component('RouterLink', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function createRouteMap (
  routes,
  oldPathList,
  oldPathMap,
  oldNameMap,
  parentRoute
) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route, parentRoute);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  if (true) {
    // warn if routes do not include leading slashes
    var found = pathList
    // check for missing leading slash
      .filter(function (path) { return path && path.charAt(0) !== '*' && path.charAt(0) !== '/'; });

    if (found.length > 0) {
      var pathNames = found.map(function (path) { return ("- " + path); }).join('\n');
      warn(false, ("Non-nested routes must include a leading slash character. Fix the following routes: \n" + pathNames));
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathList,
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if (true) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(
      typeof route.component !== 'string',
      "route config \"component\" for path: " + (String(
        path || name
      )) + " cannot be a " + "string id. Use an actual component instead."
    );

    warn(
      // eslint-disable-next-line no-control-regex
      !/[^\u0000-\u007F]+/.test(path),
      "Route with path \"" + path + "\" contains unencoded characters, make sure " +
        "your path is correctly encoded before passing it to the router. Use " +
        "encodeURI to encode static segments of your path."
    );
  }

  var pathToRegexpOptions =
    route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    alias: route.alias
      ? typeof route.alias === 'string'
        ? [route.alias]
        : route.alias
      : [],
    instances: {},
    enteredCbs: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props:
      route.props == null
        ? {}
        : route.components
          ? route.props
          : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (true) {
      if (
        route.name &&
        !route.redirect &&
        route.children.some(function (child) { return /^\/?$/.test(child.path); })
      ) {
        warn(
          false,
          "Named Route '" + (route.name) + "' has a default child route. " +
            "When navigating to this named route (:to=\"{name: '" + (route.name) + "'}\"), " +
            "the default child route will not be rendered. Remove the name from " +
            "this route and use the name of the default child route for named " +
            "links instead."
        );
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];
    for (var i = 0; i < aliases.length; ++i) {
      var alias = aliases[i];
      if ( true && alias === path) {
        warn(
          false,
          ("Found an alias with the same value as the path: \"" + path + "\". You have to remove that alias. It will be ignored in development.")
        );
        // skip in dev to make it work
        continue
      }

      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      );
    }
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ( true && !matchAs) {
      warn(
        false,
        "Duplicate named routes definition: " +
          "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
      );
    }
  }
}

function compileRouteRegex (
  path,
  pathToRegexpOptions
) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if (true) {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(
        !keys[key.name],
        ("Duplicate param keys in route with path: \"" + path + "\"")
      );
      keys[key.name] = true;
    });
  }
  return regex
}

function normalizePath (
  path,
  parent,
  strict
) {
  if (!strict) { path = path.replace(/\/$/, ''); }
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

/*  */



function createMatcher (
  routes,
  router
) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function addRoute (parentOrRoute, route) {
    var parent = (typeof parentOrRoute !== 'object') ? nameMap[parentOrRoute] : undefined;
    // $flow-disable-line
    createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent);

    // add aliases of parent
    if (parent && parent.alias.length) {
      createRouteMap(
        // $flow-disable-line route is defined if parent is
        parent.alias.map(function (alias) { return ({ path: alias, children: [route] }); }),
        pathList,
        pathMap,
        nameMap,
        parent
      );
    }
  }

  function getRoutes () {
    return pathList.map(function (path) { return pathMap[path]; })
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (true) {
        warn(record, ("Route with name '" + name + "' does not exist"));
      }
      if (!record) { return _createRoute(null, location) }
      var paramNames = record.regex.keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
      return _createRoute(record, location, redirectedFrom)
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
      ? originalRedirect(createRoute(record, location, null, router))
      : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if (true) {
        warn(
          false, ("invalid redirect option: " + (JSON.stringify(redirect)))
        );
      }
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (true) {
        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      if (true) {
        warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
      }
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match: match,
    addRoute: addRoute,
    getRoutes: getRoutes,
    addRoutes: addRoutes
  }
}

function matchRoute (
  regex,
  path,
  params
) {
  var m = path.match(regex);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    if (key) {
      // Fix #1994: using * with props: true generates a param named 0
      params[key.name || 'pathMatch'] = typeof m[i] === 'string' ? decode(m[i]) : m[i];
    }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */

// use User Timing api (if present) for more accurate key precision
var Time =
  inBrowser && window.performance && window.performance.now
    ? window.performance
    : Date;

function genStateKey () {
  return Time.now().toFixed(3)
}

var _key = genStateKey();

function getStateKey () {
  return _key
}

function setStateKey (key) {
  return (_key = key)
}

/*  */

var positionStore = Object.create(null);

function setupScroll () {
  // Prevent browser scroll behavior on History popstate
  if ('scrollRestoration' in window.history) {
    window.history.scrollRestoration = 'manual';
  }
  // Fix for #1585 for Firefox
  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678
  // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with
  // window.location.protocol + '//' + window.location.host
  // location.host contains the port and location.hostname doesn't
  var protocolAndPath = window.location.protocol + '//' + window.location.host;
  var absolutePath = window.location.href.replace(protocolAndPath, '');
  // preserve existing history state as it could be overriden by the user
  var stateCopy = extend({}, window.history.state);
  stateCopy.key = getStateKey();
  window.history.replaceState(stateCopy, '', absolutePath);
  window.addEventListener('popstate', handlePopState);
  return function () {
    window.removeEventListener('popstate', handlePopState);
  }
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if (true) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior.call(
      router,
      to,
      from,
      isPop ? position : null
    );

    if (!shouldScroll) {
      return
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll
        .then(function (shouldScroll) {
          scrollToPosition((shouldScroll), position);
        })
        .catch(function (err) {
          if (true) {
            assert(false, err.toString());
          }
        });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function handlePopState (e) {
  saveScrollPosition();
  if (e.state && e.state.key) {
    setStateKey(e.state.key);
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function normalizeOffset (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

var hashStartsWithNumberRE = /^#\d/;

function scrollToPosition (shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]
    // but at the same time, it doesn't make much sense to select an element with an id and an extra selector
    var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line
      ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line
      : document.querySelector(shouldScroll.selector);

    if (el) {
      var offset =
        shouldScroll.offset && typeof shouldScroll.offset === 'object'
          ? shouldScroll.offset
          : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    // $flow-disable-line
    if ('scrollBehavior' in document.documentElement.style) {
      window.scrollTo({
        left: position.x,
        top: position.y,
        // $flow-disable-line
        behavior: shouldScroll.behavior
      });
    } else {
      window.scrollTo(position.x, position.y);
    }
  }
}

/*  */

var supportsPushState =
  inBrowser &&
  (function () {
    var ua = window.navigator.userAgent;

    if (
      (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
      ua.indexOf('Mobile Safari') !== -1 &&
      ua.indexOf('Chrome') === -1 &&
      ua.indexOf('Windows Phone') === -1
    ) {
      return false
    }

    return window.history && typeof window.history.pushState === 'function'
  })();

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      // preserve existing history state as it could be overriden by the user
      var stateCopy = extend({}, history.state);
      stateCopy.key = getStateKey();
      history.replaceState(stateCopy, '', url);
    } else {
      history.pushState({ key: setStateKey(genStateKey()) }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

// When changing thing, also edit router.d.ts
var NavigationFailureType = {
  redirected: 2,
  aborted: 4,
  cancelled: 8,
  duplicated: 16
};

function createNavigationRedirectedError (from, to) {
  return createRouterError(
    from,
    to,
    NavigationFailureType.redirected,
    ("Redirected when going from \"" + (from.fullPath) + "\" to \"" + (stringifyRoute(
      to
    )) + "\" via a navigation guard.")
  )
}

function createNavigationDuplicatedError (from, to) {
  var error = createRouterError(
    from,
    to,
    NavigationFailureType.duplicated,
    ("Avoided redundant navigation to current location: \"" + (from.fullPath) + "\".")
  );
  // backwards compatible with the first introduction of Errors
  error.name = 'NavigationDuplicated';
  return error
}

function createNavigationCancelledError (from, to) {
  return createRouterError(
    from,
    to,
    NavigationFailureType.cancelled,
    ("Navigation cancelled from \"" + (from.fullPath) + "\" to \"" + (to.fullPath) + "\" with a new navigation.")
  )
}

function createNavigationAbortedError (from, to) {
  return createRouterError(
    from,
    to,
    NavigationFailureType.aborted,
    ("Navigation aborted from \"" + (from.fullPath) + "\" to \"" + (to.fullPath) + "\" via a navigation guard.")
  )
}

function createRouterError (from, to, type, message) {
  var error = new Error(message);
  error._isRouter = true;
  error.from = from;
  error.to = to;
  error.type = type;

  return error
}

var propertiesToLog = ['params', 'query', 'hash'];

function stringifyRoute (to) {
  if (typeof to === 'string') { return to }
  if ('path' in to) { return to.path }
  var location = {};
  propertiesToLog.forEach(function (key) {
    if (key in to) { location[key] = to[key]; }
  });
  return JSON.stringify(location, null, 2)
}

function isError (err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1
}

function isNavigationFailure (err, errorType) {
  return (
    isError(err) &&
    err._isRouter &&
    (errorType == null || err.type === errorType)
  )
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents (matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
           true && warn(false, msg);
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) { next(); }
  }
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

var hasSymbol =
  typeof Symbol === 'function' &&
  typeof Symbol.toStringTag === 'symbol';

function isESModule (obj) {
  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (called) { return }
    called = true;
    return fn.apply(this, args)
  }
}

/*  */

var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
  this.listeners = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError (errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo (
  location,
  onComplete,
  onAbort
) {
    var this$1$1 = this;

  var route;
  // catch redirect option https://github.com/vuejs/vue-router/issues/3201
  try {
    route = this.router.match(location, this.current);
  } catch (e) {
    this.errorCbs.forEach(function (cb) {
      cb(e);
    });
    // Exception should still be thrown
    throw e
  }
  var prev = this.current;
  this.confirmTransition(
    route,
    function () {
      this$1$1.updateRoute(route);
      onComplete && onComplete(route);
      this$1$1.ensureURL();
      this$1$1.router.afterHooks.forEach(function (hook) {
        hook && hook(route, prev);
      });

      // fire ready cbs once
      if (!this$1$1.ready) {
        this$1$1.ready = true;
        this$1$1.readyCbs.forEach(function (cb) {
          cb(route);
        });
      }
    },
    function (err) {
      if (onAbort) {
        onAbort(err);
      }
      if (err && !this$1$1.ready) {
        // Initial redirection should not mark the history as ready yet
        // because it's triggered by the redirection instead
        // https://github.com/vuejs/vue-router/issues/3225
        // https://github.com/vuejs/vue-router/issues/3331
        if (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) {
          this$1$1.ready = true;
          this$1$1.readyErrorCbs.forEach(function (cb) {
            cb(err);
          });
        }
      }
    }
  );
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1$1 = this;

  var current = this.current;
  this.pending = route;
  var abort = function (err) {
    // changed after adding errors with
    // https://github.com/vuejs/vue-router/pull/3047 before that change,
    // redirect and aborted navigation would produce an err == null
    if (!isNavigationFailure(err) && isError(err)) {
      if (this$1$1.errorCbs.length) {
        this$1$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        if (true) {
          warn(false, 'uncaught error during route navigation:');
        }
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  var lastRouteIndex = route.matched.length - 1;
  var lastCurrentIndex = current.matched.length - 1;
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    lastRouteIndex === lastCurrentIndex &&
    route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]
  ) {
    this.ensureURL();
    if (route.hash) {
      handleScroll(this.router, current, route, false);
    }
    return abort(createNavigationDuplicatedError(current, route))
  }

  var ref = resolveQueue(
    this.current.matched,
    route.matched
  );
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  var iterator = function (hook, next) {
    if (this$1$1.pending !== route) {
      return abort(createNavigationCancelledError(current, route))
    }
    try {
      hook(route, current, function (to) {
        if (to === false) {
          // next(false) -> abort navigation, ensure current URL
          this$1$1.ensureURL(true);
          abort(createNavigationAbortedError(current, route));
        } else if (isError(to)) {
          this$1$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' &&
            (typeof to.path === 'string' || typeof to.name === 'string'))
        ) {
          // next('/') or next({ path: '/' }) -> redirect
          abort(createNavigationRedirectedError(current, route));
          if (typeof to === 'object' && to.replace) {
            this$1$1.replace(to);
          } else {
            this$1$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated);
    var queue = enterGuards.concat(this$1$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1$1.pending !== route) {
        return abort(createNavigationCancelledError(current, route))
      }
      this$1$1.pending = null;
      onComplete(route);
      if (this$1$1.router.app) {
        this$1$1.router.app.$nextTick(function () {
          handleRouteEntered(route);
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  this.current = route;
  this.cb && this.cb(route);
};

History.prototype.setupListeners = function setupListeners () {
  // Default implementation is empty
};

History.prototype.teardown = function teardown () {
  // clean up event listeners
  // https://github.com/vuejs/vue-router/issues/2341
  this.listeners.forEach(function (cleanupListener) {
    cleanupListener();
  });
  this.listeners = [];

  // reset current history route
  // https://github.com/vuejs/vue-router/issues/3294
  this.current = START;
  this.pending = null;
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated
) {
  return extractGuards(
    activated,
    'beforeRouteEnter',
    function (guard, _, match, key) {
      return bindEnterGuard(guard, match, key)
    }
  )
}

function bindEnterGuard (
  guard,
  match,
  key
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      if (typeof cb === 'function') {
        if (!match.enteredCbs[key]) {
          match.enteredCbs[key] = [];
        }
        match.enteredCbs[key].push(cb);
      }
      next(cb);
    })
  }
}

/*  */

var HTML5History = /*@__PURE__*/(function (History) {
  function HTML5History (router, base) {
    History.call(this, router, base);

    this._startLocation = getLocation(this.base);
  }

  if ( History ) HTML5History.__proto__ = History;
  HTML5History.prototype = Object.create( History && History.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.setupListeners = function setupListeners () {
    var this$1$1 = this;

    if (this.listeners.length > 0) {
      return
    }

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      this.listeners.push(setupScroll());
    }

    var handleRoutingEvent = function () {
      var current = this$1$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1$1.base);
      if (this$1$1.current === START && location === this$1$1._startLocation) {
        return
      }

      this$1$1.transitionTo(location, function (route) {
        if (supportsScroll) {
          handleScroll(router, route, current, true);
        }
      });
    };
    window.addEventListener('popstate', handleRoutingEvent);
    this.listeners.push(function () {
      window.removeEventListener('popstate', handleRoutingEvent);
    });
  };

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1$1.base + route.fullPath));
      handleScroll(this$1$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1$1.base + route.fullPath));
      handleScroll(this$1$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = window.location.pathname;
  var pathLowerCase = path.toLowerCase();
  var baseLowerCase = base.toLowerCase();
  // base="/a" shouldn't turn path="/app" into "/a/pp"
  // https://github.com/vuejs/vue-router/issues/3555
  // so we ensure the trailing slash in the base
  if (base && ((pathLowerCase === baseLowerCase) ||
    (pathLowerCase.indexOf(cleanPath(baseLowerCase + '/')) === 0))) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */

var HashHistory = /*@__PURE__*/(function (History) {
  function HashHistory (router, base, fallback) {
    History.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History ) HashHistory.__proto__ = History;
  HashHistory.prototype = Object.create( History && History.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1$1 = this;

    if (this.listeners.length > 0) {
      return
    }

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      this.listeners.push(setupScroll());
    }

    var handleRoutingEvent = function () {
      var current = this$1$1.current;
      if (!ensureSlash()) {
        return
      }
      this$1$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1$1.router, route, current, true);
        }
        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    };
    var eventType = supportsPushState ? 'popstate' : 'hashchange';
    window.addEventListener(
      eventType,
      handleRoutingEvent
    );
    this.listeners.push(function () {
      window.removeEventListener(eventType, handleRoutingEvent);
    });
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(
      location,
      function (route) {
        pushHash(route.fullPath);
        handleScroll(this$1$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(
      location,
      function (route) {
        replaceHash(route.fullPath);
        handleScroll(this$1$1.router, route, fromRoute, false);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  // empty path
  if (index < 0) { return '' }

  href = href.slice(index + 1);

  return href
}

function getUrl (path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return (base + "#" + path)
}

function pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */

var AbstractHistory = /*@__PURE__*/(function (History) {
  function AbstractHistory (router, base) {
    History.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History ) AbstractHistory.__proto__ = History;
  AbstractHistory.prototype = Object.create( History && History.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1$1 = this;

    this.transitionTo(
      location,
      function (route) {
        this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index + 1).concat(route);
        this$1$1.index++;
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1$1 = this;

    this.transitionTo(
      location,
      function (route) {
        this$1$1.stack = this$1$1.stack.slice(0, this$1$1.index).concat(route);
        onComplete && onComplete(route);
      },
      onAbort
    );
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(
      route,
      function () {
        var prev = this$1$1.current;
        this$1$1.index = targetIndex;
        this$1$1.updateRoute(route);
        this$1$1.router.afterHooks.forEach(function (hook) {
          hook && hook(route, prev);
        });
      },
      function (err) {
        if (isNavigationFailure(err, NavigationFailureType.duplicated)) {
          this$1$1.index = targetIndex;
        }
      }
    );
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */



var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  if (true) {
    warn(this instanceof VueRouter, "Router must be called with the new operator.");
  }
  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback =
    mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if (true) {
        assert(false, ("invalid mode: " + mode));
      }
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match (raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1$1 = this;

   true &&
    assert(
      install.installed,
      "not installed. Make sure to call `Vue.use(VueRouter)` " +
        "before creating root instance."
    );

  this.apps.push(app);

  // set up app destroyed handler
  // https://github.com/vuejs/vue-router/issues/2639
  app.$once('hook:destroyed', function () {
    // clean out app from this.apps array once destroyed
    var index = this$1$1.apps.indexOf(app);
    if (index > -1) { this$1$1.apps.splice(index, 1); }
    // ensure we still have a main app or null if no apps
    // we do not release the router so it can be reused
    if (this$1$1.app === app) { this$1$1.app = this$1$1.apps[0] || null; }

    if (!this$1$1.app) { this$1$1.history.teardown(); }
  });

  // main app previously initialized
  // return as we don't need to set up new history listener
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History || history instanceof HashHistory) {
    var handleInitialScroll = function (routeOrError) {
      var from = history.current;
      var expectScroll = this$1$1.options.scrollBehavior;
      var supportsScroll = supportsPushState && expectScroll;

      if (supportsScroll && 'fullPath' in routeOrError) {
        handleScroll(this$1$1, routeOrError, from, false);
      }
    };
    var setupListeners = function (routeOrError) {
      history.setupListeners();
      handleInitialScroll(routeOrError);
    };
    history.transitionTo(
      history.getCurrentLocation(),
      setupListeners,
      setupListeners
    );
  }

  history.listen(function (route) {
    this$1$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  return registerHook(this.beforeHooks, fn)
};

VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
  return registerHook(this.resolveHooks, fn)
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  return registerHook(this.afterHooks, fn)
};

VueRouter.prototype.onReady = function onReady (cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError (errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
    var this$1$1 = this;

  // $flow-disable-line
  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1$1.history.push(location, resolve, reject);
    })
  } else {
    this.history.push(location, onComplete, onAbort);
  }
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1$1 = this;

  // $flow-disable-line
  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {
    return new Promise(function (resolve, reject) {
      this$1$1.history.replace(location, resolve, reject);
    })
  } else {
    this.history.replace(location, onComplete, onAbort);
  }
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply(
    [],
    route.matched.map(function (m) {
      return Object.keys(m.components).map(function (key) {
        return m.components[key]
      })
    })
  )
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  current = current || this.history.current;
  var location = normalizeLocation(to, current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.getRoutes = function getRoutes () {
  return this.matcher.getRoutes()
};

VueRouter.prototype.addRoute = function addRoute (parentOrRoute, route) {
  this.matcher.addRoute(parentOrRoute, route);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  if (true) {
    warn(false, 'router.addRoutes() is deprecated and has been removed in Vue Router 4. Use router.addRoute() instead.');
  }
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

var VueRouter$1 = VueRouter;

function registerHook (list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) { list.splice(i, 1); }
  }
}

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

// We cannot remove this as it would be a breaking change
VueRouter.install = install;
VueRouter.version = '3.6.5';
VueRouter.isNavigationFailure = isNavigationFailure;
VueRouter.NavigationFailureType = NavigationFailureType;
VueRouter.START_LOCATION = START;

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

var version = '3.6.5';




/***/ }),
/* 17 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*!
 * vue-i18n v8.28.2 
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */
/*  */

/**
 * constants
 */

var numberFormatKeys = [
  'compactDisplay',
  'currency',
  'currencyDisplay',
  'currencySign',
  'localeMatcher',
  'notation',
  'numberingSystem',
  'signDisplay',
  'style',
  'unit',
  'unitDisplay',
  'useGrouping',
  'minimumIntegerDigits',
  'minimumFractionDigits',
  'maximumFractionDigits',
  'minimumSignificantDigits',
  'maximumSignificantDigits'
];

var dateTimeFormatKeys = [
  'dateStyle',
  'timeStyle',
  'calendar',
  'localeMatcher',
  "hour12",
  "hourCycle",
  "timeZone",
  "formatMatcher",
  'weekday',
  'era',
  'year',
  'month',
  'day',
  'hour',
  'minute',
  'second',
  'timeZoneName' ];

/**
 * utilities
 */

function warn (msg, err) {
  if (typeof console !== 'undefined') {
    console.warn('[vue-i18n] ' + msg);
    /* istanbul ignore if */
    if (err) {
      console.warn(err.stack);
    }
  }
}

function error (msg, err) {
  if (typeof console !== 'undefined') {
    console.error('[vue-i18n] ' + msg);
    /* istanbul ignore if */
    if (err) {
      console.error(err.stack);
    }
  }
}

var isArray = Array.isArray;

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isBoolean (val) {
  return typeof val === 'boolean'
}

function isString (val) {
  return typeof val === 'string'
}

var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject (obj) {
  return toString.call(obj) === OBJECT_STRING
}

function isNull (val) {
  return val === null || val === undefined
}

function isFunction (val) {
  return typeof val === 'function'
}

function parseArgs () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  var locale = null;
  var params = null;
  if (args.length === 1) {
    if (isObject(args[0]) || isArray(args[0])) {
      params = args[0];
    } else if (typeof args[0] === 'string') {
      locale = args[0];
    }
  } else if (args.length === 2) {
    if (typeof args[0] === 'string') {
      locale = args[0];
    }
    /* istanbul ignore if */
    if (isObject(args[1]) || isArray(args[1])) {
      params = args[1];
    }
  }

  return { locale: locale, params: params }
}

function looseClone (obj) {
  return JSON.parse(JSON.stringify(obj))
}

function remove (arr, item) {
  if (arr.delete(item)) {
    return arr
  }
}

function arrayFrom (arr) {
  var ret = [];
  arr.forEach(function (a) { return ret.push(a); });
  return ret
}

function includes (arr, item) {
  return !!~arr.indexOf(item)
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

function merge (target) {
  var arguments$1 = arguments;

  var output = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      var key = (void 0);
      for (key in source) {
        if (hasOwn(source, key)) {
          if (isObject(source[key])) {
            output[key] = merge(output[key], source[key]);
          } else {
            output[key] = source[key];
          }
        }
      }
    }
  }
  return output
}

function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = isArray(a);
      var isArrayB = isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Sanitizes html special characters from input strings. For mitigating risk of XSS attacks.
 * @param rawText The raw input from the user that should be escaped.
 */
function escapeHtml(rawText) {
  return rawText
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
}

/**
 * Escapes html tags and special symbols from all provided params which were returned from parseArgs().params.
 * This method performs an in-place operation on the params object.
 *
 * @param {any} params Parameters as provided from `parseArgs().params`.
 *                     May be either an array of strings or a string->any map.
 *
 * @returns The manipulated `params` object.
 */
function escapeParams(params) {
  if(params != null) {
    Object.keys(params).forEach(function (key) {
      if(typeof(params[key]) == 'string') {
        params[key] = escapeHtml(params[key]);
      }
    });
  }
  return params
}

/*  */

function extend (Vue) {
  if (!Vue.prototype.hasOwnProperty('$i18n')) {
    // $FlowFixMe
    Object.defineProperty(Vue.prototype, '$i18n', {
      get: function get () { return this._i18n }
    });
  }

  Vue.prototype.$t = function (key) {
    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

    var i18n = this.$i18n;
    return i18n._t.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this ].concat( values ))
  };

  Vue.prototype.$tc = function (key, choice) {
    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];

    var i18n = this.$i18n;
    return i18n._tc.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this, choice ].concat( values ))
  };

  Vue.prototype.$te = function (key, locale) {
    var i18n = this.$i18n;
    return i18n._te(key, i18n.locale, i18n._getMessages(), locale)
  };

  Vue.prototype.$d = function (value) {
    var ref;

    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
    return (ref = this.$i18n).d.apply(ref, [ value ].concat( args ))
  };

  Vue.prototype.$n = function (value) {
    var ref;

    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
    return (ref = this.$i18n).n.apply(ref, [ value ].concat( args ))
  };
}

/*  */

/**
 * Mixin
 * 
 * If `bridge` mode, empty mixin is returned,
 * else regulary mixin implementation is returned.
 */
function defineMixin (bridge) {
  if ( bridge === void 0 ) bridge = false;

  function mounted () {
    if (this !== this.$root && this.$options.__INTLIFY_META__ && this.$el) {
      this.$el.setAttribute('data-intlify', this.$options.__INTLIFY_META__);
    }
  }

  return bridge
    ? { mounted: mounted } // delegate `vue-i18n-bridge` mixin implementation
    : { // regulary 
    beforeCreate: function beforeCreate () {
      var options = this.$options;
      options.i18n = options.i18n || ((options.__i18nBridge || options.__i18n) ? {} : null);

      if (options.i18n) {
        if (options.i18n instanceof VueI18n) {
          // init locale messages via custom blocks
          if ((options.__i18nBridge || options.__i18n)) {
            try {
              var localeMessages = options.i18n && options.i18n.messages ? options.i18n.messages : {};
              var _i18n = options.__i18nBridge || options.__i18n;
              _i18n.forEach(function (resource) {
                localeMessages = merge(localeMessages, JSON.parse(resource));
              });
              Object.keys(localeMessages).forEach(function (locale) {
                options.i18n.mergeLocaleMessage(locale, localeMessages[locale]);
              });
            } catch (e) {
              if (true) {
                error("Cannot parse locale messages via custom blocks.", e);
              }
            }
          }
          this._i18n = options.i18n;
          this._i18nWatcher = this._i18n.watchI18nData();
        } else if (isPlainObject(options.i18n)) {
          var rootI18n = this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n
            ? this.$root.$i18n
            : null;
          // component local i18n
          if (rootI18n) {
            options.i18n.root = this.$root;
            options.i18n.formatter = rootI18n.formatter;
            options.i18n.fallbackLocale = rootI18n.fallbackLocale;
            options.i18n.formatFallbackMessages = rootI18n.formatFallbackMessages;
            options.i18n.silentTranslationWarn = rootI18n.silentTranslationWarn;
            options.i18n.silentFallbackWarn = rootI18n.silentFallbackWarn;
            options.i18n.pluralizationRules = rootI18n.pluralizationRules;
            options.i18n.preserveDirectiveContent = rootI18n.preserveDirectiveContent;
          }

          // init locale messages via custom blocks
          if ((options.__i18nBridge || options.__i18n)) {
            try {
              var localeMessages$1 = options.i18n && options.i18n.messages ? options.i18n.messages : {};
              var _i18n$1 = options.__i18nBridge || options.__i18n;
              _i18n$1.forEach(function (resource) {
                localeMessages$1 = merge(localeMessages$1, JSON.parse(resource));
              });
              options.i18n.messages = localeMessages$1;
            } catch (e) {
              if (true) {
                warn("Cannot parse locale messages via custom blocks.", e);
              }
            }
          }

          var ref = options.i18n;
          var sharedMessages = ref.sharedMessages;
          if (sharedMessages && isPlainObject(sharedMessages)) {
            options.i18n.messages = merge(options.i18n.messages, sharedMessages);
          }

          this._i18n = new VueI18n(options.i18n);
          this._i18nWatcher = this._i18n.watchI18nData();

          if (options.i18n.sync === undefined || !!options.i18n.sync) {
            this._localeWatcher = this.$i18n.watchLocale();
          }

          if (rootI18n) {
            rootI18n.onComponentInstanceCreated(this._i18n);
          }
        } else {
          if (true) {
            warn("Cannot be interpreted 'i18n' option.");
          }
        }
      } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
        // root i18n
        this._i18n = this.$root.$i18n;
      } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {
        // parent i18n
        this._i18n = options.parent.$i18n;
      }
    },

    beforeMount: function beforeMount () {
      var options = this.$options;
      options.i18n = options.i18n || ((options.__i18nBridge || options.__i18n) ? {} : null);

      if (options.i18n) {
        if (options.i18n instanceof VueI18n) {
          // init locale messages via custom blocks
          this._i18n.subscribeDataChanging(this);
          this._subscribing = true;
        } else if (isPlainObject(options.i18n)) {
          this._i18n.subscribeDataChanging(this);
          this._subscribing = true;
        } else {
          if (true) {
            warn("Cannot be interpreted 'i18n' option.");
          }
        }
      } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
        this._i18n.subscribeDataChanging(this);
        this._subscribing = true;
      } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {
        this._i18n.subscribeDataChanging(this);
        this._subscribing = true;
      }
    },

    mounted: mounted,

    beforeDestroy: function beforeDestroy () {
      if (!this._i18n) { return }

      var self = this;
      this.$nextTick(function () {
        if (self._subscribing) {
          self._i18n.unsubscribeDataChanging(self);
          delete self._subscribing;
        }

        if (self._i18nWatcher) {
          self._i18nWatcher();
          self._i18n.destroyVM();
          delete self._i18nWatcher;
        }

        if (self._localeWatcher) {
          self._localeWatcher();
          delete self._localeWatcher;
        }
      });
    }
  }
}

/*  */

var interpolationComponent = {
  name: 'i18n',
  functional: true,
  props: {
    tag: {
      type: [String, Boolean, Object],
      default: 'span'
    },
    path: {
      type: String,
      required: true
    },
    locale: {
      type: String
    },
    places: {
      type: [Array, Object]
    }
  },
  render: function render (h, ref) {
    var data = ref.data;
    var parent = ref.parent;
    var props = ref.props;
    var slots = ref.slots;

    var $i18n = parent.$i18n;
    if (!$i18n) {
      if (true) {
        warn('Cannot find VueI18n instance!');
      }
      return
    }

    var path = props.path;
    var locale = props.locale;
    var places = props.places;
    var params = slots();
    var children = $i18n.i(
      path,
      locale,
      onlyHasDefaultPlace(params) || places
        ? useLegacyPlaces(params.default, places)
        : params
    );

    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';
    return tag ? h(tag, data, children) : children
  }
};

function onlyHasDefaultPlace (params) {
  var prop;
  for (prop in params) {
    if (prop !== 'default') { return false }
  }
  return Boolean(prop)
}

function useLegacyPlaces (children, places) {
  var params = places ? createParamsFromPlaces(places) : {};

  if (!children) { return params }

  // Filter empty text nodes
  children = children.filter(function (child) {
    return child.tag || child.text.trim() !== ''
  });

  var everyPlace = children.every(vnodeHasPlaceAttribute);
  if ( true && everyPlace) {
    warn('`place` attribute is deprecated in next major version. Please switch to Vue slots.');
  }

  return children.reduce(
    everyPlace ? assignChildPlace : assignChildIndex,
    params
  )
}

function createParamsFromPlaces (places) {
  if (true) {
    warn('`places` prop is deprecated in next major version. Please switch to Vue slots.');
  }

  return Array.isArray(places)
    ? places.reduce(assignChildIndex, {})
    : Object.assign({}, places)
}

function assignChildPlace (params, child) {
  if (child.data && child.data.attrs && child.data.attrs.place) {
    params[child.data.attrs.place] = child;
  }
  return params
}

function assignChildIndex (params, child, index) {
  params[index] = child;
  return params
}

function vnodeHasPlaceAttribute (vnode) {
  return Boolean(vnode.data && vnode.data.attrs && vnode.data.attrs.place)
}

/*  */

var numberComponent = {
  name: 'i18n-n',
  functional: true,
  props: {
    tag: {
      type: [String, Boolean, Object],
      default: 'span'
    },
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    },
    locale: {
      type: String
    }
  },
  render: function render (h, ref) {
    var props = ref.props;
    var parent = ref.parent;
    var data = ref.data;

    var i18n = parent.$i18n;

    if (!i18n) {
      if (true) {
        warn('Cannot find VueI18n instance!');
      }
      return null
    }

    var key = null;
    var options = null;

    if (isString(props.format)) {
      key = props.format;
    } else if (isObject(props.format)) {
      if (props.format.key) {
        key = props.format.key;
      }

      // Filter out number format options only
      options = Object.keys(props.format).reduce(function (acc, prop) {
        var obj;

        if (includes(numberFormatKeys, prop)) {
          return Object.assign({}, acc, ( obj = {}, obj[prop] = props.format[prop], obj ))
        }
        return acc
      }, null);
    }

    var locale = props.locale || i18n.locale;
    var parts = i18n._ntp(props.value, locale, key, options);

    var values = parts.map(function (part, index) {
      var obj;

      var slot = data.scopedSlots && data.scopedSlots[part.type];
      return slot ? slot(( obj = {}, obj[part.type] = part.value, obj.index = index, obj.parts = parts, obj )) : part.value
    });

    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';
    return tag
      ? h(tag, {
        attrs: data.attrs,
        'class': data['class'],
        staticClass: data.staticClass
      }, values)
      : values
  }
};

/*  */

function bind (el, binding, vnode) {
  if (!assert(el, vnode)) { return }

  t(el, binding, vnode);
}

function update (el, binding, vnode, oldVNode) {
  if (!assert(el, vnode)) { return }

  var i18n = vnode.context.$i18n;
  if (localeEqual(el, vnode) &&
    (looseEqual(binding.value, binding.oldValue) &&
     looseEqual(el._localeMessage, i18n.getLocaleMessage(i18n.locale)))) { return }

  t(el, binding, vnode);
}

function unbind (el, binding, vnode, oldVNode) {
  var vm = vnode.context;
  if (!vm) {
    warn('Vue instance does not exists in VNode context');
    return
  }

  var i18n = vnode.context.$i18n || {};
  if (!binding.modifiers.preserve && !i18n.preserveDirectiveContent) {
    el.textContent = '';
  }
  el._vt = undefined;
  delete el['_vt'];
  el._locale = undefined;
  delete el['_locale'];
  el._localeMessage = undefined;
  delete el['_localeMessage'];
}

function assert (el, vnode) {
  var vm = vnode.context;
  if (!vm) {
    warn('Vue instance does not exists in VNode context');
    return false
  }

  if (!vm.$i18n) {
    warn('VueI18n instance does not exists in Vue instance');
    return false
  }

  return true
}

function localeEqual (el, vnode) {
  var vm = vnode.context;
  return el._locale === vm.$i18n.locale
}

function t (el, binding, vnode) {
  var ref$1, ref$2;

  var value = binding.value;

  var ref = parseValue(value);
  var path = ref.path;
  var locale = ref.locale;
  var args = ref.args;
  var choice = ref.choice;
  if (!path && !locale && !args) {
    warn('value type not supported');
    return
  }

  if (!path) {
    warn('`path` is required in v-t directive');
    return
  }

  var vm = vnode.context;
  if (choice != null) {
    el._vt = el.textContent = (ref$1 = vm.$i18n).tc.apply(ref$1, [ path, choice ].concat( makeParams(locale, args) ));
  } else {
    el._vt = el.textContent = (ref$2 = vm.$i18n).t.apply(ref$2, [ path ].concat( makeParams(locale, args) ));
  }
  el._locale = vm.$i18n.locale;
  el._localeMessage = vm.$i18n.getLocaleMessage(vm.$i18n.locale);
}

function parseValue (value) {
  var path;
  var locale;
  var args;
  var choice;

  if (isString(value)) {
    path = value;
  } else if (isPlainObject(value)) {
    path = value.path;
    locale = value.locale;
    args = value.args;
    choice = value.choice;
  }

  return { path: path, locale: locale, args: args, choice: choice }
}

function makeParams (locale, args) {
  var params = [];

  locale && params.push(locale);
  if (args && (Array.isArray(args) || isPlainObject(args))) {
    params.push(args);
  }

  return params
}

var Vue;

function install (_Vue, options) {
  if ( options === void 0 ) options = { bridge: false };

  /* istanbul ignore if */
  if ( true && install.installed && _Vue === Vue) {
    warn('already installed.');
    return
  }
  install.installed = true;

  Vue = _Vue;

  var version = (Vue.version && Number(Vue.version.split('.')[0])) || -1;
  /* istanbul ignore if */
  if ( true && version < 2) {
    warn(("vue-i18n (" + (install.version) + ") need to use Vue 2.0 or later (Vue: " + (Vue.version) + ")."));
    return
  }

  extend(Vue);
  Vue.mixin(defineMixin(options.bridge));
  Vue.directive('t', { bind: bind, update: update, unbind: unbind });
  Vue.component(interpolationComponent.name, interpolationComponent);
  Vue.component(numberComponent.name, numberComponent);

  // use simple mergeStrategies to prevent i18n instance lose '__proto__'
  var strats = Vue.config.optionMergeStrategies;
  strats.i18n = function (parentVal, childVal) {
    return childVal === undefined
      ? parentVal
      : childVal
  };
}

/*  */

var BaseFormatter = function BaseFormatter () {
  this._caches = Object.create(null);
};

BaseFormatter.prototype.interpolate = function interpolate (message, values) {
  if (!values) {
    return [message]
  }
  var tokens = this._caches[message];
  if (!tokens) {
    tokens = parse(message);
    this._caches[message] = tokens;
  }
  return compile(tokens, values)
};



var RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
var RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;

function parse (format) {
  var tokens = [];
  var position = 0;

  var text = '';
  while (position < format.length) {
    var char = format[position++];
    if (char === '{') {
      if (text) {
        tokens.push({ type: 'text', value: text });
      }

      text = '';
      var sub = '';
      char = format[position++];
      while (char !== undefined && char !== '}') {
        sub += char;
        char = format[position++];
      }
      var isClosed = char === '}';

      var type = RE_TOKEN_LIST_VALUE.test(sub)
        ? 'list'
        : isClosed && RE_TOKEN_NAMED_VALUE.test(sub)
          ? 'named'
          : 'unknown';
      tokens.push({ value: sub, type: type });
    } else if (char === '%') {
      // when found rails i18n syntax, skip text capture
      if (format[(position)] !== '{') {
        text += char;
      }
    } else {
      text += char;
    }
  }

  text && tokens.push({ type: 'text', value: text });

  return tokens
}

function compile (tokens, values) {
  var compiled = [];
  var index = 0;

  var mode = Array.isArray(values)
    ? 'list'
    : isObject(values)
      ? 'named'
      : 'unknown';
  if (mode === 'unknown') { return compiled }

  while (index < tokens.length) {
    var token = tokens[index];
    switch (token.type) {
      case 'text':
        compiled.push(token.value);
        break
      case 'list':
        compiled.push(values[parseInt(token.value, 10)]);
        break
      case 'named':
        if (mode === 'named') {
          compiled.push((values)[token.value]);
        } else {
          if (true) {
            warn(("Type of token '" + (token.type) + "' and format of value '" + mode + "' don't match!"));
          }
        }
        break
      case 'unknown':
        if (true) {
          warn("Detect 'unknown' type of token!");
        }
        break
    }
    index++;
  }

  return compiled
}

/*  */

/**
 *  Path parser
 *  - Inspired:
 *    Vue.js Path parser
 */

// actions
var APPEND = 0;
var PUSH = 1;
var INC_SUB_PATH_DEPTH = 2;
var PUSH_SUB_PATH = 3;

// states
var BEFORE_PATH = 0;
var IN_PATH = 1;
var BEFORE_IDENT = 2;
var IN_IDENT = 3;
var IN_SUB_PATH = 4;
var IN_SINGLE_QUOTE = 5;
var IN_DOUBLE_QUOTE = 6;
var AFTER_PATH = 7;
var ERROR = 8;

var pathStateMachine = [];

pathStateMachine[BEFORE_PATH] = {
  'ws': [BEFORE_PATH],
  'ident': [IN_IDENT, APPEND],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[IN_PATH] = {
  'ws': [IN_PATH],
  '.': [BEFORE_IDENT],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[BEFORE_IDENT] = {
  'ws': [BEFORE_IDENT],
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND]
};

pathStateMachine[IN_IDENT] = {
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND],
  'ws': [IN_PATH, PUSH],
  '.': [BEFORE_IDENT, PUSH],
  '[': [IN_SUB_PATH, PUSH],
  'eof': [AFTER_PATH, PUSH]
};

pathStateMachine[IN_SUB_PATH] = {
  "'": [IN_SINGLE_QUOTE, APPEND],
  '"': [IN_DOUBLE_QUOTE, APPEND],
  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
  ']': [IN_PATH, PUSH_SUB_PATH],
  'eof': ERROR,
  'else': [IN_SUB_PATH, APPEND]
};

pathStateMachine[IN_SINGLE_QUOTE] = {
  "'": [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_SINGLE_QUOTE, APPEND]
};

pathStateMachine[IN_DOUBLE_QUOTE] = {
  '"': [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_DOUBLE_QUOTE, APPEND]
};

/**
 * Check if an expression is a literal value.
 */

var literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral (exp) {
  return literalValueRE.test(exp)
}

/**
 * Strip quotes from a string
 */

function stripQuotes (str) {
  var a = str.charCodeAt(0);
  var b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27)
    ? str.slice(1, -1)
    : str
}

/**
 * Determine the type of a character in a keypath.
 */

function getPathCharType (ch) {
  if (ch === undefined || ch === null) { return 'eof' }

  var code = ch.charCodeAt(0);

  switch (code) {
    case 0x5B: // [
    case 0x5D: // ]
    case 0x2E: // .
    case 0x22: // "
    case 0x27: // '
      return ch

    case 0x5F: // _
    case 0x24: // $
    case 0x2D: // -
      return 'ident'

    case 0x09: // Tab
    case 0x0A: // Newline
    case 0x0D: // Return
    case 0xA0:  // No-break space
    case 0xFEFF:  // Byte Order Mark
    case 0x2028:  // Line Separator
    case 0x2029:  // Paragraph Separator
      return 'ws'
  }

  return 'ident'
}

/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 */

function formatSubPath (path) {
  var trimmed = path.trim();
  // invalid leading 0
  if (path.charAt(0) === '0' && isNaN(path)) { return false }

  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed
}

/**
 * Parse a string path into an array of segments
 */

function parse$1 (path) {
  var keys = [];
  var index = -1;
  var mode = BEFORE_PATH;
  var subPathDepth = 0;
  var c;
  var key;
  var newChar;
  var type;
  var transition;
  var action;
  var typeMap;
  var actions = [];

  actions[PUSH] = function () {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[APPEND] = function () {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[INC_SUB_PATH_DEPTH] = function () {
    actions[APPEND]();
    subPathDepth++;
  };

  actions[PUSH_SUB_PATH] = function () {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = IN_SUB_PATH;
      actions[APPEND]();
    } else {
      subPathDepth = 0;
      if (key === undefined) { return false }
      key = formatSubPath(key);
      if (key === false) {
        return false
      } else {
        actions[PUSH]();
      }
    }
  };

  function maybeUnescapeQuote () {
    var nextChar = path[index + 1];
    if ((mode === IN_SINGLE_QUOTE && nextChar === "'") ||
      (mode === IN_DOUBLE_QUOTE && nextChar === '"')) {
      index++;
      newChar = '\\' + nextChar;
      actions[APPEND]();
      return true
    }
  }

  while (mode !== null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap['else'] || ERROR;

    if (transition === ERROR) {
      return // parse error
    }

    mode = transition[0];
    action = actions[transition[1]];
    if (action) {
      newChar = transition[2];
      newChar = newChar === undefined
        ? c
        : newChar;
      if (action() === false) {
        return
      }
    }

    if (mode === AFTER_PATH) {
      return keys
    }
  }
}





var I18nPath = function I18nPath () {
  this._cache = Object.create(null);
};

/**
 * External parse that check for a cache hit first
 */
I18nPath.prototype.parsePath = function parsePath (path) {
  var hit = this._cache[path];
  if (!hit) {
    hit = parse$1(path);
    if (hit) {
      this._cache[path] = hit;
    }
  }
  return hit || []
};

/**
 * Get path value from path string
 */
I18nPath.prototype.getPathValue = function getPathValue (obj, path) {
  if (!isObject(obj)) { return null }

  var paths = this.parsePath(path);
  if (paths.length === 0) {
    return null
  } else {
    var length = paths.length;
    var last = obj;
    var i = 0;
    while (i < length) {
      var value = last[paths[i]];
      if (value === undefined || value === null) {
        return null
      }
      last = value;
      i++;
    }

    return last
  }
};

/*  */



var htmlTagMatcher = /<\/?[\w\s="/.':;#-\/]+>/;
var linkKeyMatcher = /(?:@(?:\.[a-zA-Z]+)?:(?:[\w\-_|./]+|\([\w\-_:|./]+\)))/g;
var linkKeyPrefixMatcher = /^@(?:\.([a-zA-Z]+))?:/;
var bracketsMatcher = /[()]/g;
var defaultModifiers = {
  'upper': function (str) { return str.toLocaleUpperCase(); },
  'lower': function (str) { return str.toLocaleLowerCase(); },
  'capitalize': function (str) { return ("" + (str.charAt(0).toLocaleUpperCase()) + (str.substr(1))); }
};

var defaultFormatter = new BaseFormatter();

var VueI18n = function VueI18n (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #290
  /* istanbul ignore if */
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  var locale = options.locale || 'en-US';
  var fallbackLocale = options.fallbackLocale === false
    ? false
    : options.fallbackLocale || 'en-US';
  var messages = options.messages || {};
  var dateTimeFormats = options.dateTimeFormats || options.datetimeFormats || {};
  var numberFormats = options.numberFormats || {};

  this._vm = null;
  this._formatter = options.formatter || defaultFormatter;
  this._modifiers = options.modifiers || {};
  this._missing = options.missing || null;
  this._root = options.root || null;
  this._sync = options.sync === undefined ? true : !!options.sync;
  this._fallbackRoot = options.fallbackRoot === undefined
    ? true
    : !!options.fallbackRoot;
  this._fallbackRootWithEmptyString = options.fallbackRootWithEmptyString === undefined
    ? true
    : !!options.fallbackRootWithEmptyString;
  this._formatFallbackMessages = options.formatFallbackMessages === undefined
    ? false
    : !!options.formatFallbackMessages;
  this._silentTranslationWarn = options.silentTranslationWarn === undefined
    ? false
    : options.silentTranslationWarn;
  this._silentFallbackWarn = options.silentFallbackWarn === undefined
    ? false
    : !!options.silentFallbackWarn;
  this._dateTimeFormatters = {};
  this._numberFormatters = {};
  this._path = new I18nPath();
  this._dataListeners = new Set();
  this._componentInstanceCreatedListener = options.componentInstanceCreatedListener || null;
  this._preserveDirectiveContent = options.preserveDirectiveContent === undefined
    ? false
    : !!options.preserveDirectiveContent;
  this.pluralizationRules = options.pluralizationRules || {};
  this._warnHtmlInMessage = options.warnHtmlInMessage || 'off';
  this._postTranslation = options.postTranslation || null;
  this._escapeParameterHtml = options.escapeParameterHtml || false;

  if ('__VUE_I18N_BRIDGE__' in options) {
    this.__VUE_I18N_BRIDGE__ = options.__VUE_I18N_BRIDGE__;
  }

  /**
   * @param choice {number} a choice index given by the input to $tc: `$tc('path.to.rule', choiceIndex)`
   * @param choicesLength {number} an overall amount of available choices
   * @returns a final choice index
  */
  this.getChoiceIndex = function (choice, choicesLength) {
    var thisPrototype = Object.getPrototypeOf(this$1);
    if (thisPrototype && thisPrototype.getChoiceIndex) {
      var prototypeGetChoiceIndex = (thisPrototype.getChoiceIndex);
      return (prototypeGetChoiceIndex).call(this$1, choice, choicesLength)
    }

    // Default (old) getChoiceIndex implementation - english-compatible
    var defaultImpl = function (_choice, _choicesLength) {
      _choice = Math.abs(_choice);

      if (_choicesLength === 2) {
        return _choice
          ? _choice > 1
            ? 1
            : 0
          : 1
      }

      return _choice ? Math.min(_choice, 2) : 0
    };

    if (this$1.locale in this$1.pluralizationRules) {
      return this$1.pluralizationRules[this$1.locale].apply(this$1, [choice, choicesLength])
    } else {
      return defaultImpl(choice, choicesLength)
    }
  };


  this._exist = function (message, key) {
    if (!message || !key) { return false }
    if (!isNull(this$1._path.getPathValue(message, key))) { return true }
    // fallback for flat key
    if (message[key]) { return true }
    return false
  };

  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    Object.keys(messages).forEach(function (locale) {
      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);
    });
  }

  this._initVM({
    locale: locale,
    fallbackLocale: fallbackLocale,
    messages: messages,
    dateTimeFormats: dateTimeFormats,
    numberFormats: numberFormats
  });
};

var prototypeAccessors = { vm: { configurable: true },messages: { configurable: true },dateTimeFormats: { configurable: true },numberFormats: { configurable: true },availableLocales: { configurable: true },locale: { configurable: true },fallbackLocale: { configurable: true },formatFallbackMessages: { configurable: true },missing: { configurable: true },formatter: { configurable: true },silentTranslationWarn: { configurable: true },silentFallbackWarn: { configurable: true },preserveDirectiveContent: { configurable: true },warnHtmlInMessage: { configurable: true },postTranslation: { configurable: true },sync: { configurable: true } };

VueI18n.prototype._checkLocaleMessage = function _checkLocaleMessage (locale, level, message) {
  var paths = [];

  var fn = function (level, locale, message, paths) {
    if (isPlainObject(message)) {
      Object.keys(message).forEach(function (key) {
        var val = message[key];
        if (isPlainObject(val)) {
          paths.push(key);
          paths.push('.');
          fn(level, locale, val, paths);
          paths.pop();
          paths.pop();
        } else {
          paths.push(key);
          fn(level, locale, val, paths);
          paths.pop();
        }
      });
    } else if (isArray(message)) {
      message.forEach(function (item, index) {
        if (isPlainObject(item)) {
          paths.push(("[" + index + "]"));
          paths.push('.');
          fn(level, locale, item, paths);
          paths.pop();
          paths.pop();
        } else {
          paths.push(("[" + index + "]"));
          fn(level, locale, item, paths);
          paths.pop();
        }
      });
    } else if (isString(message)) {
      var ret = htmlTagMatcher.test(message);
      if (ret) {
        var msg = "Detected HTML in message '" + message + "' of keypath '" + (paths.join('')) + "' at '" + locale + "'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";
        if (level === 'warn') {
          warn(msg);
        } else if (level === 'error') {
          error(msg);
        }
      }
    }
  };

  fn(level, locale, message, paths);
};

VueI18n.prototype._initVM = function _initVM (data) {
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  this._vm = new Vue({ data: data, __VUE18N__INSTANCE__: true });
  Vue.config.silent = silent;
};

VueI18n.prototype.destroyVM = function destroyVM () {
  this._vm.$destroy();
};

VueI18n.prototype.subscribeDataChanging = function subscribeDataChanging (vm) {
  this._dataListeners.add(vm);
};

VueI18n.prototype.unsubscribeDataChanging = function unsubscribeDataChanging (vm) {
  remove(this._dataListeners, vm);
};

VueI18n.prototype.watchI18nData = function watchI18nData () {
    var this$1 = this;
  return this._vm.$watch('$data', function () {
    var listeners = arrayFrom(this$1._dataListeners);
    var i = listeners.length;
    while(i--) {
      Vue.nextTick(function () {
        listeners[i] && listeners[i].$forceUpdate();
      });
    }
  }, { deep: true })
};

VueI18n.prototype.watchLocale = function watchLocale (composer) {
  if (!composer) {
    /* istanbul ignore if */
    if (!this._sync || !this._root) { return null }
    var target = this._vm;
    return this._root.$i18n.vm.$watch('locale', function (val) {
      target.$set(target, 'locale', val);
      target.$forceUpdate();
    }, { immediate: true })
  } else {
    // deal with vue-i18n-bridge
    if (!this.__VUE_I18N_BRIDGE__) { return null }
    var self = this;
    var target$1 = this._vm;
    return this.vm.$watch('locale', function (val) {
      target$1.$set(target$1, 'locale', val);
      if (self.__VUE_I18N_BRIDGE__ && composer) {
        composer.locale.value = val;
      }
      target$1.$forceUpdate();
    }, { immediate: true })
  }
};

VueI18n.prototype.onComponentInstanceCreated = function onComponentInstanceCreated (newI18n) {
  if (this._componentInstanceCreatedListener) {
    this._componentInstanceCreatedListener(newI18n, this);
  }
};

prototypeAccessors.vm.get = function () { return this._vm };

prototypeAccessors.messages.get = function () { return looseClone(this._getMessages()) };
prototypeAccessors.dateTimeFormats.get = function () { return looseClone(this._getDateTimeFormats()) };
prototypeAccessors.numberFormats.get = function () { return looseClone(this._getNumberFormats()) };
prototypeAccessors.availableLocales.get = function () { return Object.keys(this.messages).sort() };

prototypeAccessors.locale.get = function () { return this._vm.locale };
prototypeAccessors.locale.set = function (locale) {
  this._vm.$set(this._vm, 'locale', locale);
};

prototypeAccessors.fallbackLocale.get = function () { return this._vm.fallbackLocale };
prototypeAccessors.fallbackLocale.set = function (locale) {
  this._localeChainCache = {};
  this._vm.$set(this._vm, 'fallbackLocale', locale);
};

prototypeAccessors.formatFallbackMessages.get = function () { return this._formatFallbackMessages };
prototypeAccessors.formatFallbackMessages.set = function (fallback) { this._formatFallbackMessages = fallback; };

prototypeAccessors.missing.get = function () { return this._missing };
prototypeAccessors.missing.set = function (handler) { this._missing = handler; };

prototypeAccessors.formatter.get = function () { return this._formatter };
prototypeAccessors.formatter.set = function (formatter) { this._formatter = formatter; };

prototypeAccessors.silentTranslationWarn.get = function () { return this._silentTranslationWarn };
prototypeAccessors.silentTranslationWarn.set = function (silent) { this._silentTranslationWarn = silent; };

prototypeAccessors.silentFallbackWarn.get = function () { return this._silentFallbackWarn };
prototypeAccessors.silentFallbackWarn.set = function (silent) { this._silentFallbackWarn = silent; };

prototypeAccessors.preserveDirectiveContent.get = function () { return this._preserveDirectiveContent };
prototypeAccessors.preserveDirectiveContent.set = function (preserve) { this._preserveDirectiveContent = preserve; };

prototypeAccessors.warnHtmlInMessage.get = function () { return this._warnHtmlInMessage };
prototypeAccessors.warnHtmlInMessage.set = function (level) {
    var this$1 = this;

  var orgLevel = this._warnHtmlInMessage;
  this._warnHtmlInMessage = level;
  if (orgLevel !== level && (level === 'warn' || level === 'error')) {
    var messages = this._getMessages();
    Object.keys(messages).forEach(function (locale) {
      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);
    });
  }
};

prototypeAccessors.postTranslation.get = function () { return this._postTranslation };
prototypeAccessors.postTranslation.set = function (handler) { this._postTranslation = handler; };

prototypeAccessors.sync.get = function () { return this._sync };
prototypeAccessors.sync.set = function (val) { this._sync = val; };

VueI18n.prototype._getMessages = function _getMessages () { return this._vm.messages };
VueI18n.prototype._getDateTimeFormats = function _getDateTimeFormats () { return this._vm.dateTimeFormats };
VueI18n.prototype._getNumberFormats = function _getNumberFormats () { return this._vm.numberFormats };

VueI18n.prototype._warnDefault = function _warnDefault (locale, key, result, vm, values, interpolateMode) {
  if (!isNull(result)) { return result }
  if (this._missing) {
    var missingRet = this._missing.apply(null, [locale, key, vm, values]);
    if (isString(missingRet)) {
      return missingRet
    }
  } else {
    if ( true && !this._isSilentTranslationWarn(key)) {
      warn(
        "Cannot translate the value of keypath '" + key + "'. " +
        'Use the value of keypath as default.'
      );
    }
  }

  if (this._formatFallbackMessages) {
    var parsedArgs = parseArgs.apply(void 0, values);
    return this._render(key, interpolateMode, parsedArgs.params, key)
  } else {
    return key
  }
};

VueI18n.prototype._isFallbackRoot = function _isFallbackRoot (val) {
  return (this._fallbackRootWithEmptyString? !val : isNull(val)) && !isNull(this._root) && this._fallbackRoot
};

VueI18n.prototype._isSilentFallbackWarn = function _isSilentFallbackWarn (key) {
  return this._silentFallbackWarn instanceof RegExp
    ? this._silentFallbackWarn.test(key)
    : this._silentFallbackWarn
};

VueI18n.prototype._isSilentFallback = function _isSilentFallback (locale, key) {
  return this._isSilentFallbackWarn(key) && (this._isFallbackRoot() || locale !== this.fallbackLocale)
};

VueI18n.prototype._isSilentTranslationWarn = function _isSilentTranslationWarn (key) {
  return this._silentTranslationWarn instanceof RegExp
    ? this._silentTranslationWarn.test(key)
    : this._silentTranslationWarn
};

VueI18n.prototype._interpolate = function _interpolate (
  locale,
  message,
  key,
  host,
  interpolateMode,
  values,
  visitedLinkStack
) {
  if (!message) { return null }

  var pathRet = this._path.getPathValue(message, key);
  if (isArray(pathRet) || isPlainObject(pathRet)) { return pathRet }

  var ret;
  if (isNull(pathRet)) {
    /* istanbul ignore else */
    if (isPlainObject(message)) {
      ret = message[key];
      if (!(isString(ret) || isFunction(ret))) {
        if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallback(locale, key)) {
          warn(("Value of key '" + key + "' is not a string or function !"));
        }
        return null
      }
    } else {
      return null
    }
  } else {
    /* istanbul ignore else */
    if (isString(pathRet) || isFunction(pathRet)) {
      ret = pathRet;
    } else {
      if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallback(locale, key)) {
        warn(("Value of key '" + key + "' is not a string or function!"));
      }
      return null
    }
  }

  // Check for the existence of links within the translated string
  if (isString(ret) && (ret.indexOf('@:') >= 0 || ret.indexOf('@.') >= 0)) {
    ret = this._link(locale, message, ret, host, 'raw', values, visitedLinkStack);
  }

  return this._render(ret, interpolateMode, values, key)
};

VueI18n.prototype._link = function _link (
  locale,
  message,
  str,
  host,
  interpolateMode,
  values,
  visitedLinkStack
) {
  var ret = str;

  // Match all the links within the local
  // We are going to replace each of
  // them with its translation
  var matches = ret.match(linkKeyMatcher);

  // eslint-disable-next-line no-autofix/prefer-const
  for (var idx in matches) {
    // ie compatible: filter custom array
    // prototype method
    if (!matches.hasOwnProperty(idx)) {
      continue
    }
    var link = matches[idx];
    var linkKeyPrefixMatches = link.match(linkKeyPrefixMatcher);
    var linkPrefix = linkKeyPrefixMatches[0];
      var formatterName = linkKeyPrefixMatches[1];

    // Remove the leading @:, @.case: and the brackets
    var linkPlaceholder = link.replace(linkPrefix, '').replace(bracketsMatcher, '');

    if (includes(visitedLinkStack, linkPlaceholder)) {
      if (true) {
        warn(("Circular reference found. \"" + link + "\" is already visited in the chain of " + (visitedLinkStack.reverse().join(' <- '))));
      }
      return ret
    }
    visitedLinkStack.push(linkPlaceholder);

    // Translate the link
    var translated = this._interpolate(
      locale, message, linkPlaceholder, host,
      interpolateMode === 'raw' ? 'string' : interpolateMode,
      interpolateMode === 'raw' ? undefined : values,
      visitedLinkStack
    );

    if (this._isFallbackRoot(translated)) {
      if ( true && !this._isSilentTranslationWarn(linkPlaceholder)) {
        warn(("Fall back to translate the link placeholder '" + linkPlaceholder + "' with root locale."));
      }
      /* istanbul ignore if */
      if (!this._root) { throw Error('unexpected error') }
      var root = this._root.$i18n;
      translated = root._translate(
        root._getMessages(), root.locale, root.fallbackLocale,
        linkPlaceholder, host, interpolateMode, values
      );
    }
    translated = this._warnDefault(
      locale, linkPlaceholder, translated, host,
      isArray(values) ? values : [values],
      interpolateMode
    );

    if (this._modifiers.hasOwnProperty(formatterName)) {
      translated = this._modifiers[formatterName](translated);
    } else if (defaultModifiers.hasOwnProperty(formatterName)) {
      translated = defaultModifiers[formatterName](translated);
    }

    visitedLinkStack.pop();

    // Replace the link with the translated
    ret = !translated ? ret : ret.replace(link, translated);
  }

  return ret
};

VueI18n.prototype._createMessageContext = function _createMessageContext (values, formatter, path, interpolateMode) {
    var this$1 = this;

  var _list = isArray(values) ? values : [];
  var _named = isObject(values) ? values : {};
  var list = function (index) { return _list[index]; };
  var named = function (key) { return _named[key]; };
  var messages = this._getMessages();
  var locale = this.locale;

  return {
    list: list,
    named: named,
    values: values,
    formatter: formatter,
    path: path,
    messages: messages,
    locale: locale,
    linked: function (linkedKey) { return this$1._interpolate(locale, messages[locale] || {}, linkedKey, null, interpolateMode, undefined, [linkedKey]); }
  }
};

VueI18n.prototype._render = function _render (message, interpolateMode, values, path) {
  if (isFunction(message)) {
    return message(
      this._createMessageContext(values, this._formatter || defaultFormatter, path, interpolateMode)
    )
  }

  var ret = this._formatter.interpolate(message, values, path);

  // If the custom formatter refuses to work - apply the default one
  if (!ret) {
    ret = defaultFormatter.interpolate(message, values, path);
  }

  // if interpolateMode is **not** 'string' ('row'),
  // return the compiled data (e.g. ['foo', VNode, 'bar']) with formatter
  return interpolateMode === 'string' && !isString(ret) ? ret.join('') : ret
};

VueI18n.prototype._appendItemToChain = function _appendItemToChain (chain, item, blocks) {
  var follow = false;
  if (!includes(chain, item)) {
    follow = true;
    if (item) {
      follow = item[item.length - 1] !== '!';
      item = item.replace(/!/g, '');
      chain.push(item);
      if (blocks && blocks[item]) {
        follow = blocks[item];
      }
    }
  }
  return follow
};

VueI18n.prototype._appendLocaleToChain = function _appendLocaleToChain (chain, locale, blocks) {
  var follow;
  var tokens = locale.split('-');
  do {
    var item = tokens.join('-');
    follow = this._appendItemToChain(chain, item, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && (follow === true))
  return follow
};

VueI18n.prototype._appendBlockToChain = function _appendBlockToChain (chain, block, blocks) {
  var follow = true;
  for (var i = 0; (i < block.length) && (isBoolean(follow)); i++) {
    var locale = block[i];
    if (isString(locale)) {
      follow = this._appendLocaleToChain(chain, locale, blocks);
    }
  }
  return follow
};

VueI18n.prototype._getLocaleChain = function _getLocaleChain (start, fallbackLocale) {
  if (start === '') { return [] }

  if (!this._localeChainCache) {
    this._localeChainCache = {};
  }

  var chain = this._localeChainCache[start];
  if (!chain) {
    if (!fallbackLocale) {
      fallbackLocale = this.fallbackLocale;
    }
    chain = [];

    // first block defined by start
    var block = [start];

    // while any intervening block found
    while (isArray(block)) {
      block = this._appendBlockToChain(
        chain,
        block,
        fallbackLocale
      );
    }

    // last block defined by default
    var defaults;
    if (isArray(fallbackLocale)) {
      defaults = fallbackLocale;
    } else if (isObject(fallbackLocale)) {
      /* $FlowFixMe */
      if (fallbackLocale['default']) {
        defaults = fallbackLocale['default'];
      } else {
        defaults = null;
      }
    } else {
      defaults = fallbackLocale;
    }

    // convert defaults to array
    if (isString(defaults)) {
      block = [defaults];
    } else {
      block = defaults;
    }
    if (block) {
      this._appendBlockToChain(
        chain,
        block,
        null
      );
    }
    this._localeChainCache[start] = chain;
  }
  return chain
};

VueI18n.prototype._translate = function _translate (
  messages,
  locale,
  fallback,
  key,
  host,
  interpolateMode,
  args
) {
  var chain = this._getLocaleChain(locale, fallback);
  var res;
  for (var i = 0; i < chain.length; i++) {
    var step = chain[i];
    res =
      this._interpolate(step, messages[step], key, host, interpolateMode, args, [key]);
    if (!isNull(res)) {
      if (step !== locale && "development" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to translate the keypath '" + key + "' with '" + step + "' locale."));
      }
      return res
    }
  }
  return null
};

VueI18n.prototype._t = function _t (key, _locale, messages, host) {
    var ref;

    var values = [], len = arguments.length - 4;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 4 ];
  if (!key) { return '' }

  var parsedArgs = parseArgs.apply(void 0, values);
  if(this._escapeParameterHtml) {
    parsedArgs.params = escapeParams(parsedArgs.params);
  }

  var locale = parsedArgs.locale || _locale;

  var ret = this._translate(
    messages, locale, this.fallbackLocale, key,
    host, 'string', parsedArgs.params
  );
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
      warn(("Fall back to translate the keypath '" + key + "' with root locale."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return (ref = this._root).$t.apply(ref, [ key ].concat( values ))
  } else {
    ret = this._warnDefault(locale, key, ret, host, values, 'string');
    if (this._postTranslation && ret !== null && ret !== undefined) {
      ret = this._postTranslation(ret, key);
    }
    return ret
  }
};

VueI18n.prototype.t = function t (key) {
    var ref;

    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];
  return (ref = this)._t.apply(ref, [ key, this.locale, this._getMessages(), null ].concat( values ))
};

VueI18n.prototype._i = function _i (key, locale, messages, host, values) {
  var ret =
    this._translate(messages, locale, this.fallbackLocale, key, host, 'raw', values);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key)) {
      warn(("Fall back to interpolate the keypath '" + key + "' with root locale."));
    }
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.i(key, locale, values)
  } else {
    return this._warnDefault(locale, key, ret, host, [values], 'raw')
  }
};

VueI18n.prototype.i = function i (key, locale, values) {
  /* istanbul ignore if */
  if (!key) { return '' }

  if (!isString(locale)) {
    locale = this.locale;
  }

  return this._i(key, locale, this._getMessages(), null, values)
};

VueI18n.prototype._tc = function _tc (
  key,
  _locale,
  messages,
  host,
  choice
) {
    var ref;

    var values = [], len = arguments.length - 5;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 5 ];
  if (!key) { return '' }
  if (choice === undefined) {
    choice = 1;
  }

  var predefined = { 'count': choice, 'n': choice };
  var parsedArgs = parseArgs.apply(void 0, values);
  parsedArgs.params = Object.assign(predefined, parsedArgs.params);
  values = parsedArgs.locale === null ? [parsedArgs.params] : [parsedArgs.locale, parsedArgs.params];
  return this.fetchChoice((ref = this)._t.apply(ref, [ key, _locale, messages, host ].concat( values )), choice)
};

VueI18n.prototype.fetchChoice = function fetchChoice (message, choice) {
  /* istanbul ignore if */
  if (!message || !isString(message)) { return null }
  var choices = message.split('|');

  choice = this.getChoiceIndex(choice, choices.length);
  if (!choices[choice]) { return message }
  return choices[choice].trim()
};

VueI18n.prototype.tc = function tc (key, choice) {
    var ref;

    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];
  return (ref = this)._tc.apply(ref, [ key, this.locale, this._getMessages(), null, choice ].concat( values ))
};

VueI18n.prototype._te = function _te (key, locale, messages) {
    var args = [], len = arguments.length - 3;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

  var _locale = parseArgs.apply(void 0, args).locale || locale;
  return this._exist(messages[_locale], key)
};

VueI18n.prototype.te = function te (key, locale) {
  return this._te(key, this.locale, this._getMessages(), locale)
};

VueI18n.prototype.getLocaleMessage = function getLocaleMessage (locale) {
  return looseClone(this._vm.messages[locale] || {})
};

VueI18n.prototype.setLocaleMessage = function setLocaleMessage (locale, message) {
  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);
  }
  this._vm.$set(this._vm.messages, locale, message);
};

VueI18n.prototype.mergeLocaleMessage = function mergeLocaleMessage (locale, message) {
  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);
  }
  this._vm.$set(this._vm.messages, locale, merge(
    typeof this._vm.messages[locale] !== 'undefined' && Object.keys(this._vm.messages[locale]).length
      ? Object.assign({}, this._vm.messages[locale])
      : {},
    message
  ));
};

VueI18n.prototype.getDateTimeFormat = function getDateTimeFormat (locale) {
  return looseClone(this._vm.dateTimeFormats[locale] || {})
};

VueI18n.prototype.setDateTimeFormat = function setDateTimeFormat (locale, format) {
  this._vm.$set(this._vm.dateTimeFormats, locale, format);
  this._clearDateTimeFormat(locale, format);
};

VueI18n.prototype.mergeDateTimeFormat = function mergeDateTimeFormat (locale, format) {
  this._vm.$set(this._vm.dateTimeFormats, locale, merge(this._vm.dateTimeFormats[locale] || {}, format));
  this._clearDateTimeFormat(locale, format);
};

VueI18n.prototype._clearDateTimeFormat = function _clearDateTimeFormat (locale, format) {
  // eslint-disable-next-line no-autofix/prefer-const
  for (var key in format) {
    var id = locale + "__" + key;

    if (!this._dateTimeFormatters.hasOwnProperty(id)) {
      continue
    }

    delete this._dateTimeFormatters[id];
  }
};

VueI18n.prototype._localizeDateTime = function _localizeDateTime (
  value,
  locale,
  fallback,
  dateTimeFormats,
  key,
  options
) {
  var _locale = locale;
  var formats = dateTimeFormats[_locale];

  var chain = this._getLocaleChain(locale, fallback);
  for (var i = 0; i < chain.length; i++) {
    var current = _locale;
    var step = chain[i];
    formats = dateTimeFormats[step];
    _locale = step;
    // fallback locale
    if (isNull(formats) || isNull(formats[key])) {
      if (step !== locale && "development" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to '" + step + "' datetime formats from '" + current + "' datetime formats."));
      }
    } else {
      break
    }
  }

  if (isNull(formats) || isNull(formats[key])) {
    return null
  } else {
    var format = formats[key];

    var formatter;
    if (options) {
      formatter = new Intl.DateTimeFormat(_locale, Object.assign({}, format, options));
    } else {
      var id = _locale + "__" + key;
      formatter = this._dateTimeFormatters[id];
      if (!formatter) {
        formatter = this._dateTimeFormatters[id] = new Intl.DateTimeFormat(_locale, format);
      }
    }

    return formatter.format(value)
  }
};

VueI18n.prototype._d = function _d (value, locale, key, options) {
  /* istanbul ignore if */
  if ( true && !VueI18n.availabilities.dateTimeFormat) {
    warn('Cannot format a Date value due to not supported Intl.DateTimeFormat.');
    return ''
  }

  if (!key) {
    var dtf = !options ? new Intl.DateTimeFormat(locale) : new Intl.DateTimeFormat(locale, options);
    return dtf.format(value)
  }

  var ret =
    this._localizeDateTime(value, locale, this.fallbackLocale, this._getDateTimeFormats(), key, options);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
      warn(("Fall back to datetime localization of root: key '" + key + "'."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.d(value, key, locale)
  } else {
    return ret || ''
  }
};

VueI18n.prototype.d = function d (value) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  var locale = this.locale;
  var key = null;
  var options = null;

  if (args.length === 1) {
    if (isString(args[0])) {
      key = args[0];
    } else if (isObject(args[0])) {
      if (args[0].locale) {
        locale = args[0].locale;
      }
      if (args[0].key) {
        key = args[0].key;
      }
    }

    options = Object.keys(args[0]).reduce(function (acc, key) {
        var obj;

      if (includes(dateTimeFormatKeys, key)) {
        return Object.assign({}, acc, ( obj = {}, obj[key] = args[0][key], obj ))
      }
      return acc
    }, null);

  } else if (args.length === 2) {
    if (isString(args[0])) {
      key = args[0];
    }
    if (isString(args[1])) {
      locale = args[1];
    }
  }

  return this._d(value, locale, key, options)
};

VueI18n.prototype.getNumberFormat = function getNumberFormat (locale) {
  return looseClone(this._vm.numberFormats[locale] || {})
};

VueI18n.prototype.setNumberFormat = function setNumberFormat (locale, format) {
  this._vm.$set(this._vm.numberFormats, locale, format);
  this._clearNumberFormat(locale, format);
};

VueI18n.prototype.mergeNumberFormat = function mergeNumberFormat (locale, format) {
  this._vm.$set(this._vm.numberFormats, locale, merge(this._vm.numberFormats[locale] || {}, format));
  this._clearNumberFormat(locale, format);
};

VueI18n.prototype._clearNumberFormat = function _clearNumberFormat (locale, format) {
  // eslint-disable-next-line no-autofix/prefer-const
  for (var key in format) {
    var id = locale + "__" + key;

    if (!this._numberFormatters.hasOwnProperty(id)) {
      continue
    }

    delete this._numberFormatters[id];
  }
};

VueI18n.prototype._getNumberFormatter = function _getNumberFormatter (
  value,
  locale,
  fallback,
  numberFormats,
  key,
  options
) {
  var _locale = locale;
  var formats = numberFormats[_locale];

  var chain = this._getLocaleChain(locale, fallback);
  for (var i = 0; i < chain.length; i++) {
    var current = _locale;
    var step = chain[i];
    formats = numberFormats[step];
    _locale = step;
    // fallback locale
    if (isNull(formats) || isNull(formats[key])) {
      if (step !== locale && "development" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to '" + step + "' number formats from '" + current + "' number formats."));
      }
    } else {
      break
    }
  }

  if (isNull(formats) || isNull(formats[key])) {
    return null
  } else {
    var format = formats[key];

    var formatter;
    if (options) {
      // If options specified - create one time number formatter
      formatter = new Intl.NumberFormat(_locale, Object.assign({}, format, options));
    } else {
      var id = _locale + "__" + key;
      formatter = this._numberFormatters[id];
      if (!formatter) {
        formatter = this._numberFormatters[id] = new Intl.NumberFormat(_locale, format);
      }
    }
    return formatter
  }
};

VueI18n.prototype._n = function _n (value, locale, key, options) {
  /* istanbul ignore if */
  if (!VueI18n.availabilities.numberFormat) {
    if (true) {
      warn('Cannot format a Number value due to not supported Intl.NumberFormat.');
    }
    return ''
  }

  if (!key) {
    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);
    return nf.format(value)
  }

  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);
  var ret = formatter && formatter.format(value);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
      warn(("Fall back to number localization of root: key '" + key + "'."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.n(value, Object.assign({}, { key: key, locale: locale }, options))
  } else {
    return ret || ''
  }
};

VueI18n.prototype.n = function n (value) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  var locale = this.locale;
  var key = null;
  var options = null;

  if (args.length === 1) {
    if (isString(args[0])) {
      key = args[0];
    } else if (isObject(args[0])) {
      if (args[0].locale) {
        locale = args[0].locale;
      }
      if (args[0].key) {
        key = args[0].key;
      }

      // Filter out number format options only
      options = Object.keys(args[0]).reduce(function (acc, key) {
          var obj;

        if (includes(numberFormatKeys, key)) {
          return Object.assign({}, acc, ( obj = {}, obj[key] = args[0][key], obj ))
        }
        return acc
      }, null);
    }
  } else if (args.length === 2) {
    if (isString(args[0])) {
      key = args[0];
    }
    if (isString(args[1])) {
      locale = args[1];
    }
  }

  return this._n(value, locale, key, options)
};

VueI18n.prototype._ntp = function _ntp (value, locale, key, options) {
  /* istanbul ignore if */
  if (!VueI18n.availabilities.numberFormat) {
    if (true) {
      warn('Cannot format to parts a Number value due to not supported Intl.NumberFormat.');
    }
    return []
  }

  if (!key) {
    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);
    return nf.formatToParts(value)
  }

  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);
  var ret = formatter && formatter.formatToParts(value);
  if (this._isFallbackRoot(ret)) {
    if ( true && !this._isSilentTranslationWarn(key)) {
      warn(("Fall back to format number to parts of root: key '" + key + "' ."));
    }
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n._ntp(value, locale, key, options)
  } else {
    return ret || []
  }
};

Object.defineProperties( VueI18n.prototype, prototypeAccessors );

var availabilities;
// $FlowFixMe
Object.defineProperty(VueI18n, 'availabilities', {
  get: function get () {
    if (!availabilities) {
      var intlDefined = typeof Intl !== 'undefined';
      availabilities = {
        dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',
        numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'
      };
    }

    return availabilities
  }
});

VueI18n.install = install;
VueI18n.version = '8.28.2';

/* harmony default export */ __webpack_exports__["default"] = (VueI18n);


/***/ }),
/* 18 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// log MPX i18n 因为是在node环境下引入文件 所以需要使用commonjs规范
// import cn from './cn'
// import en from './en'
var en = __webpack_require__(19);
var cn = __webpack_require__(20);
/**
 * 语言类型由端传来，key为lang，可能的值有：zh-CN, en-US, pt-BR, en-BR, zh-HK, zh-TW
 */

// export default {
//   'zh-CN': cn,
//   'en-US': en
// }
module.exports = {
  'zh-CN': cn,
  'en-US': en
};

/***/ }),
/* 19 */
/***/ (function(module) {

/* eslint-disable */
var en = {
  'page_title': 'i18n test==='
};
module.exports = en;

/***/ }),
/* 20 */
/***/ (function(module) {

/* eslint-disable */
var cn = {
  'page_title': '测试'
};
module.exports = cn;

/***/ }),
/* 21 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DatetimeFormat": function() { return /* binding */ DatetimeFormat; },
/* harmony export */   "I18nInjectionKey": function() { return /* binding */ I18nInjectionKey; },
/* harmony export */   "NumberFormat": function() { return /* binding */ NumberFormat; },
/* harmony export */   "Translation": function() { return /* binding */ Translation; },
/* harmony export */   "VERSION": function() { return /* binding */ VERSION; },
/* harmony export */   "castToVueI18n": function() { return /* binding */ castToVueI18n; },
/* harmony export */   "createI18n": function() { return /* binding */ createI18n; },
/* harmony export */   "useI18n": function() { return /* binding */ useI18n; }
/* harmony export */ });
/* harmony import */ var _intlify_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _intlify_core_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);
/*!
  * vue-i18n-bridge v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */




/**
 * Vue I18n Version
 *
 * @remarks
 * Semver format. Same format as the package.json `version` field.
 *
 * @VueI18nGeneral
 */
const VERSION = '9.2.2';
/**
 * This is only called in esm-bundler builds.
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    let needWarn = false;
    if (typeof __VUE_I18N_FULL_INSTALL__ !== 'boolean') {
        needWarn = true;
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_I18N_FULL_INSTALL__ = true;
    }
    if (typeof __VUE_I18N_LEGACY_API__ !== 'boolean') {
        needWarn = true;
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__VUE_I18N_LEGACY_API__ = true;
    }
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
    if (( true) && needWarn) {
        console.warn(`You are running the esm-bundler build of vue-i18n. It is recommended to ` +
            `configure your bundler to explicitly replace feature flag globals ` +
            `with boolean literals to get proper tree-shaking in the final bundle.`);
    }
}

let code$1 = _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = () => ++code$1;
const I18nWarnCodes = {
    FALLBACK_TO_ROOT: code$1,
    NOT_SUPPORTED_PRESERVE: inc$1(),
    NOT_SUPPORTED_FORMATTER: inc$1(),
    NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
    NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
    COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
    NOT_FOUND_PARENT_SCOPE: inc$1() // 13
};
const warnMessages = {
    [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
    [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
    [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
    [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
    [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
    [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
    [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`
};
function getWarnMessage(code, ...args) {
    return (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.format)(warnMessages[code], ...args);
}

let code = _intlify_core_base__WEBPACK_IMPORTED_MODULE_3__.CompileErrorCodes.__EXTEND_POINT__;
const inc = () => ++code;
const I18nErrorCodes = {
    // composer module errors
    UNEXPECTED_RETURN_TYPE: code,
    // legacy module errors
    INVALID_ARGUMENT: inc(),
    // i18n module errors
    MUST_BE_CALL_SETUP_TOP: inc(),
    NOT_INSLALLED: inc(),
    NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
    // directive module errors
    REQUIRED_VALUE: inc(),
    INVALID_VALUE: inc(),
    // vue-devtools errors
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
    NOT_INSLALLED_WITH_PROVIDE: inc(),
    // unexpected error
    UNEXPECTED_ERROR: inc(),
    // not compatible legacy vue-i18n constructor
    NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
    // bridge support vue 2.x only
    BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
    // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
    // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
    // for enhancement
    __EXTEND_POINT__: inc() // 29
};
function createI18nError(code, ...args) {
    return (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_3__.createCompileError)(code, null, ( true) ? { messages: errorMessages, args } : 0);
}
const errorMessages = {
    [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: 'Unexpected return type in composer',
    [I18nErrorCodes.INVALID_ARGUMENT]: 'Invalid argument',
    [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: 'Must be called at the top of a `setup` function',
    [I18nErrorCodes.NOT_INSLALLED]: 'Need to install with `app.use` function',
    [I18nErrorCodes.UNEXPECTED_ERROR]: 'Unexpected error',
    [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: 'Not available in legacy mode',
    [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
    [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
    [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
    [I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE]: 'Need to install with `provide` function',
    [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: 'Not compatible legacy VueI18n.',
    [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: 'vue-i18n-bridge support Vue 2.x only',
    [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: 'Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode',
    [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: 'Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly'
};

const TransrateVNodeSymbol = 
/* #__PURE__*/ (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('__transrateVNode');
const DatetimePartsSymbol = /* #__PURE__*/ (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('__datetimeParts');
const NumberPartsSymbol = /* #__PURE__*/ (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('__numberParts');
const SetPluralRulesSymbol = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('__setPluralRules');
(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('__intlifyMeta');
const LegacyInstanceSymbol = /* #__PURE__*/ (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('__legacyVueI18n');
const InejctWithOption = /* #__PURE__*/ (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('__injectWithOption');
const __VUE_I18N_BRIDGE__ =  '__VUE_I18N_BRIDGE__';

/* eslint-disable @typescript-eslint/no-explicit-any */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function isLegacyVueI18n(VueI18n) {
    if (VueI18n == null || VueI18n.version == null) {
        return false;
    }
    return (Number(VueI18n.version.split('.')[0]) || -1) >= 8;
}
/**
 * Transform flat json in obj to normal json in obj
 */
function handleFlatJson(obj) {
    // check obj
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return obj;
    }
    for (const key in obj) {
        // check key
        if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(obj, key)) {
            continue;
        }
        // handle for normal json
        if (!key.includes('.')) {
            // recursive process value if value is also a object
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj[key])) {
                handleFlatJson(obj[key]);
            }
        }
        // handle for flat json, transform to normal json
        else {
            // go to the last object
            const subKeys = key.split('.');
            const lastIndex = subKeys.length - 1;
            let currentObj = obj;
            for (let i = 0; i < lastIndex; i++) {
                if (!(subKeys[i] in currentObj)) {
                    currentObj[subKeys[i]] = {};
                }
                currentObj = currentObj[subKeys[i]];
            }
            // update last object value, delete old property
            currentObj[subKeys[lastIndex]] = obj[key];
            delete obj[key];
            // recursive process value if value is also a object
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(currentObj[subKeys[lastIndex]])) {
                handleFlatJson(currentObj[subKeys[lastIndex]]);
            }
        }
    }
    return obj;
}
function getLocaleMessages(locale, options) {
    const { messages, __i18n, messageResolver, flatJson } = options;
    // prettier-ignore
    const ret = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(messages)
        ? messages
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(__i18n)
            ? {}
            : { [locale]: {} };
    // merge locale messages of i18n custom block
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(__i18n)) {
        __i18n.forEach(custom => {
            if ('locale' in custom && 'resource' in custom) {
                const { locale, resource } = custom;
                if (locale) {
                    ret[locale] = ret[locale] || {};
                    deepCopy(resource, ret[locale]);
                }
                else {
                    deepCopy(resource, ret);
                }
            }
            else {
                (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(custom) && deepCopy(JSON.parse(custom), ret);
            }
        });
    }
    // handle messages for flat json
    if (messageResolver == null && flatJson) {
        for (const key in ret) {
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(ret, key)) {
                handleFlatJson(ret[key]);
            }
        }
    }
    return ret;
}
const isNotObjectOrIsArray = (val) => !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val);
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function deepCopy(src, des) {
    // src and des should both be objects, and non of then can be a array
    if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
        throw createI18nError(I18nErrorCodes.INVALID_VALUE);
    }
    for (const key in src) {
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(src, key)) {
            if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
                // replace with src[key] when:
                // src[key] or des[key] is not a object, or
                // src[key] or des[key] is a array
                des[key] = src[key];
            }
            else {
                // src[key] and des[key] are both object, merge them
                deepCopy(src[key], des[key]);
            }
        }
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getComponentOptions(instance) {
    return instance.proxy.$options;
}
function adjustI18nResources(global, options, componentOptions // eslint-disable-line @typescript-eslint/no-explicit-any
) {
    let messages = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.messages) ? options.messages : {};
    if ('__i18nGlobal' in componentOptions) {
        messages = getLocaleMessages(global.locale.value, {
            messages,
            __i18n: componentOptions.__i18nGlobal
        });
    }
    // merge locale messages
    const locales = Object.keys(messages);
    if (locales.length) {
        locales.forEach(locale => {
            global.mergeLocaleMessage(locale, messages[locale]);
        });
    }
    {
        // merge datetime formats
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.datetimeFormats)) {
            const locales = Object.keys(options.datetimeFormats);
            if (locales.length) {
                locales.forEach(locale => {
                    global.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
                });
            }
        }
        // merge number formats
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.numberFormats)) {
            const locales = Object.keys(options.numberFormats);
            if (locales.length) {
                locales.forEach(locale => {
                    global.mergeNumberFormat(locale, options.numberFormats[locale]);
                });
            }
        }
    }
}
function createTextNode(key) {
    return createVNodeVue2Compatible(key);
}
function createVNodeVue2Compatible(key) {
    // shim Vue2 VNode interface
    // see the https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js
    const componentInstance = undefined;
    return {
        tag: undefined,
        data: undefined,
        children: undefined,
        text: key,
        elm: undefined,
        ns: undefined,
        context: undefined,
        fnContext: undefined,
        fnOptions: undefined,
        fnScopeId: undefined,
        key: undefined,
        componentOptions: undefined,
        componentInstance,
        parent: undefined,
        raw: false,
        isStatic: false,
        isRootInsert: true,
        isComment: false,
        isCloned: false,
        isOnce: false,
        asyncFactory: undefined,
        asyncMeta: undefined,
        isAsyncPlaceholder: false,
        child: () => componentInstance
    };
}
/* eslint-enable @typescript-eslint/no-explicit-any */

/* eslint-disable @typescript-eslint/no-explicit-any */
// extend VNode interface
const DEVTOOLS_META = '__INTLIFY_META__';
let composerID = 0;
function defineCoreMissingHandler(missing) {
    return ((ctx, locale, key, type) => {
        return missing(locale, key, (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)() || undefined, type);
    });
}
// for Intlify DevTools
const getMetaInfo =  () => {
    const instance = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    let meta = null; // eslint-disable-line @typescript-eslint/no-explicit-any
    return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META])
        ? { [DEVTOOLS_META]: meta } // eslint-disable-line @typescript-eslint/no-explicit-any
        : null;
};
/**
 * Create composer interface factory
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function createComposer(options = {}, VueI18nLegacy) {
    const { __root } = options;
    const _isGlobal = __root === undefined;
    let _inheritLocale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.inheritLocale)
        ? options.inheritLocale
        : true;
    const _locale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(
    // prettier-ignore
    __root && _inheritLocale
        ? __root.locale.value
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.locale)
            ? options.locale
            : _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE);
    const _fallbackLocale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(
    // prettier-ignore
    __root && _inheritLocale
        ? __root.fallbackLocale.value
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.fallbackLocale) ||
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(options.fallbackLocale) ||
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.fallbackLocale) ||
            options.fallbackLocale === false
            ? options.fallbackLocale
            : _locale.value);
    const _messages = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(getLocaleMessages(_locale.value, options));
    // prettier-ignore
    const _datetimeFormats = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.datetimeFormats)
            ? options.datetimeFormats
            : { [_locale.value]: {} })
        ;
    // prettier-ignore
    const _numberFormats = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.numberFormats)
            ? options.numberFormats
            : { [_locale.value]: {} })
        ;
    // warning suppress options
    // prettier-ignore
    let _missingWarn = __root
        ? __root.missingWarn
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.missingWarn) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(options.missingWarn)
            ? options.missingWarn
            : true;
    // prettier-ignore
    let _fallbackWarn = __root
        ? __root.fallbackWarn
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackWarn) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(options.fallbackWarn)
            ? options.fallbackWarn
            : true;
    // prettier-ignore
    let _fallbackRoot = __root
        ? __root.fallbackRoot
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackRoot)
            ? options.fallbackRoot
            : true;
    // configure fall back to root
    let _fallbackFormat = !!options.fallbackFormat;
    // runtime missing
    let _missing = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.missing) ? options.missing : null;
    let _runtimeMissing = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.missing)
        ? defineCoreMissingHandler(options.missing)
        : null;
    // postTranslation handler
    let _postTranslation = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.postTranslation)
        ? options.postTranslation
        : null;
    // prettier-ignore
    let _warnHtmlMessage = __root
        ? __root.warnHtmlMessage
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.warnHtmlMessage)
            ? options.warnHtmlMessage
            : true;
    let _escapeParameter = !!options.escapeParameter;
    // custom linked modifiers
    // prettier-ignore
    const _modifiers = __root
        ? __root.modifiers
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.modifiers)
            ? options.modifiers
            : {};
    // pluralRules
    let _pluralRules = options.pluralRules || (__root && __root.pluralRules);
    // for bridge
    let __legacy;
    {
        if (!isLegacyVueI18n(VueI18nLegacy)) {
            createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
        }
        const legacyOptions = {
            locale: _locale.value,
            fallbackLocale: _fallbackLocale.value,
            messages: _messages.value,
            dateTimeFormats: _datetimeFormats.value,
            numberFormats: _numberFormats.value,
            modifiers: _modifiers,
            missing: _missing,
            fallbackRoot: _fallbackRoot,
            postTranslation: _postTranslation,
            pluralizationRules: _pluralRules,
            escapeParameterHtml: _escapeParameter,
            sync: _inheritLocale,
            silentFallbackWarn: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(_fallbackWarn)
                ? !_fallbackWarn
                : _fallbackWarn,
            silentTranslationWarn: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(_missingWarn)
                ? !_missingWarn
                : _missingWarn,
            formatFallbackMessages: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(_fallbackFormat)
                ? !_fallbackFormat
                : _fallbackFormat,
            warnHtmlInMessage: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(_warnHtmlMessage)
                ? _warnHtmlMessage
                    ? 'warn'
                    : 'off'
                : 'off',
            __VUE_I18N_BRIDGE__
        };
        __legacy = new VueI18nLegacy(legacyOptions);
    }
    // runtime context
    // eslint-disable-next-line prefer-const
    let _context;
    const getCoreContext = () => {
        _isGlobal && (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.setFallbackContext)(null);
        const ctxOptions = {
            version: VERSION,
            locale: _locale.value,
            fallbackLocale: _fallbackLocale.value,
            messages: _messages.value,
            modifiers: _modifiers,
            pluralRules: _pluralRules,
            missing: _runtimeMissing === null ? undefined : _runtimeMissing,
            missingWarn: _missingWarn,
            fallbackWarn: _fallbackWarn,
            fallbackFormat: _fallbackFormat,
            unresolving: true,
            postTranslation: _postTranslation === null ? undefined : _postTranslation,
            warnHtmlMessage: _warnHtmlMessage,
            escapeParameter: _escapeParameter,
            messageResolver: options.messageResolver,
            __meta: { framework: 'vue' }
        };
        {
            ctxOptions.datetimeFormats = _datetimeFormats.value;
            ctxOptions.numberFormats = _numberFormats.value;
            ctxOptions.__datetimeFormatters = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(_context)
                ? _context.__datetimeFormatters
                : undefined;
            ctxOptions.__numberFormatters = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(_context)
                ? _context.__numberFormatters
                : undefined;
        }
        const ctx = (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.createCoreContext)(ctxOptions);
        _isGlobal && (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.setFallbackContext)(ctx);
        return ctx;
    };
    _context = getCoreContext();
    (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.updateFallbackLocale)(_context, _locale.value, _fallbackLocale.value);
    // track reactivity
    function trackReactivityValues() {
        return [
                _locale.value,
                _fallbackLocale.value,
                _messages.value,
                _datetimeFormats.value,
                _numberFormats.value
            ]
            ;
    }
    // locale
    const locale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)({
        get: () => _locale.value,
        set: val => {
            _locale.value = val;
            {
                if (__legacy && !_isGlobal) {
                    __legacy.locale = val;
                }
            }
            _context.locale = _locale.value;
        }
    });
    // fallbackLocale
    const fallbackLocale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)({
        get: () => _fallbackLocale.value,
        set: val => {
            _fallbackLocale.value = val;
            {
                if (__legacy && !_isGlobal) {
                    __legacy.fallbackLocale = val;
                }
            }
            _context.fallbackLocale = _fallbackLocale.value;
            (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.updateFallbackLocale)(_context, _locale.value, val);
        }
    });
    // messages
    const messages = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => _messages.value);
    // datetimeFormats
    const datetimeFormats = /* #__PURE__*/ (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => _datetimeFormats.value);
    // numberFormats
    const numberFormats = /* #__PURE__*/ (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => _numberFormats.value);
    // getPostTranslationHandler
    function getPostTranslationHandler() {
        return (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_postTranslation) ? _postTranslation : null;
    }
    // setPostTranslationHandler
    function setPostTranslationHandler(handler) {
        _postTranslation = handler;
        _context.postTranslation = handler;
    }
    // getMissingHandler
    function getMissingHandler() {
        return _missing;
    }
    // setMissingHandler
    function setMissingHandler(handler) {
        if (handler !== null) {
            _runtimeMissing = defineCoreMissingHandler(handler);
        }
        _missing = handler;
        _context.missing = _runtimeMissing;
    }
    function isResolvedTranslateMessage(type, arg // eslint-disable-line @typescript-eslint/no-explicit-any
    ) {
        return type !== 'translate' || !arg.resolvedMessage;
    }
    const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
        trackReactivityValues(); // track reactive dependency
        // NOTE: experimental !!
        let ret;
        if (true) {
            try {
                (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.setAdditionalMeta)(getMetaInfo());
                if (!_isGlobal) {
                    _context.fallbackContext = __root
                        ? (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.getFallbackContext)()
                        : undefined;
                }
                ret = fn(_context);
            }
            finally {
                (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.setAdditionalMeta)(null);
                if (!_isGlobal) {
                    _context.fallbackContext = undefined;
                }
            }
        }
        else {}
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(ret) && ret === _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.NOT_REOSLVED) {
            const [key, arg2] = argumentParser();
            if (( true) &&
                __root &&
                (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) &&
                isResolvedTranslateMessage(warnType, arg2)) {
                if (_fallbackRoot &&
                    ((0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.isTranslateFallbackWarn)(_fallbackWarn, key) ||
                        (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.isTranslateMissingWarn)(_missingWarn, key))) {
                    (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn)(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
                        key,
                        type: warnType
                    }));
                }
            }
            return __root && _fallbackRoot
                ? fallbackSuccess(__root)
                : fallbackFail(key);
        }
        else if (successCondition(ret)) {
            return ret;
        }
        else {
            /* istanbul ignore next */
            throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
        }
    };
    // t
    function t(...args) {
        return wrapWithDeps(context => Reflect.apply(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.translate, null, [context, ...args]), () => (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.parseTranslateArgs)(...args), 'translate', root => Reflect.apply(root.t, root, [...args]), key => key, val => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val));
    }
    // rt
    function rt(...args) {
        const [arg1, arg2, arg3] = args;
        if (arg3 && !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(arg3)) {
            throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        return t(...[arg1, arg2, (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({ resolvedMessage: true }, arg3 || {})]);
    }
    // d
    function d(...args) {
        return wrapWithDeps(context => Reflect.apply(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.datetime, null, [context, ...args]), () => (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.parseDateTimeArgs)(...args), 'datetime format', root => Reflect.apply(root.d, root, [...args]), () => _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.MISSING_RESOLVE_VALUE, val => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val));
    }
    // n
    function n(...args) {
        return wrapWithDeps(context => Reflect.apply(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.number, null, [context, ...args]), () => (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.parseNumberArgs)(...args), 'number format', root => Reflect.apply(root.n, root, [...args]), () => _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.MISSING_RESOLVE_VALUE, val => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val));
    }
    // for custom processor
    function normalize(values) {
        return values.map(val => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(val) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(val)
            ? createTextNode(String(val))
            : val);
    }
    const interpolate = (val) => val;
    const processor = {
        normalize,
        interpolate,
        type: 'vnode'
    };
    // transrateVNode, using for `i18n-t` component
    function transrateVNode(...args) {
        return wrapWithDeps(context => {
            let ret;
            const _context = context;
            try {
                _context.processor = processor;
                ret = Reflect.apply(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.translate, null, [_context, ...args]);
            }
            finally {
                _context.processor = null;
            }
            return ret;
        }, () => (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.parseTranslateArgs)(...args), 'translate', 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        root => root[TransrateVNodeSymbol](...args), key => [createTextNode(key)], val => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val));
    }
    // numberParts, using for `i18n-n` component
    function numberParts(...args) {
        return wrapWithDeps(context => Reflect.apply(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.number, null, [context, ...args]), () => (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.parseNumberArgs)(...args), 'number format', 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        root => root[NumberPartsSymbol](...args), () => [], val => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val));
    }
    // datetimeParts, using for `i18n-d` component
    function datetimeParts(...args) {
        return wrapWithDeps(context => Reflect.apply(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.datetime, null, [context, ...args]), () => (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.parseDateTimeArgs)(...args), 'datetime format', 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        root => root[DatetimePartsSymbol](...args), () => [], val => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(val));
    }
    function setPluralRules(rules) {
        _pluralRules = rules;
        _context.pluralRules = _pluralRules;
    }
    // te
    function te(key, locale) {
        const targetLocale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(locale) ? locale : _locale.value;
        const message = getLocaleMessage(targetLocale);
        return _context.messageResolver(message, key) !== null;
    }
    function resolveMessages(key) {
        let messages = null;
        const locales = (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.fallbackWithLocaleChain)(_context, _fallbackLocale.value, _locale.value);
        for (let i = 0; i < locales.length; i++) {
            const targetLocaleMessages = _messages.value[locales[i]] || {};
            const messageValue = _context.messageResolver(targetLocaleMessages, key);
            if (messageValue != null) {
                messages = messageValue;
                break;
            }
        }
        return messages;
    }
    // tm
    function tm(key) {
        const messages = resolveMessages(key);
        // prettier-ignore
        return messages != null
            ? messages
            : __root
                ? __root.tm(key) || {}
                : {};
    }
    // getLocaleMessage
    function getLocaleMessage(locale) {
        return (_messages.value[locale] || {});
    }
    // setLocaleMessage
    function setLocaleMessage(locale, message) {
        _messages.value[locale] = message;
        {
            __legacy && __legacy.setLocaleMessage(locale, message);
        }
        _context.messages = _messages.value;
    }
    // mergeLocaleMessage
    function mergeLocaleMessage(locale, message) {
        _messages.value[locale] = _messages.value[locale] || {};
        {
            __legacy && __legacy.mergeLocaleMessage(locale, message);
        }
        deepCopy(message, _messages.value[locale]);
        _context.messages = _messages.value;
    }
    // getDateTimeFormat
    function getDateTimeFormat(locale) {
        return _datetimeFormats.value[locale] || {};
    }
    // setDateTimeFormat
    function setDateTimeFormat(locale, format) {
        _datetimeFormats.value[locale] = format;
        {
            __legacy && __legacy.setDateTimeFormat(locale, format);
        }
        _context.datetimeFormats = _datetimeFormats.value;
        (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.clearDateTimeFormat)(_context, locale, format);
    }
    // mergeDateTimeFormat
    function mergeDateTimeFormat(locale, format) {
        _datetimeFormats.value[locale] = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)(_datetimeFormats.value[locale] || {}, format);
        {
            __legacy && __legacy.mergeDateTimeFormat(locale, format);
        }
        _context.datetimeFormats = _datetimeFormats.value;
        (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.clearDateTimeFormat)(_context, locale, format);
    }
    // getNumberFormat
    function getNumberFormat(locale) {
        return _numberFormats.value[locale] || {};
    }
    // setNumberFormat
    function setNumberFormat(locale, format) {
        _numberFormats.value[locale] = format;
        {
            __legacy && __legacy.setNumberFormat(locale, format);
        }
        _context.numberFormats = _numberFormats.value;
        (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.clearNumberFormat)(_context, locale, format);
    }
    // mergeNumberFormat
    function mergeNumberFormat(locale, format) {
        _numberFormats.value[locale] = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)(_numberFormats.value[locale] || {}, format);
        {
            __legacy && __legacy.mergeNumberFormat(locale, format);
        }
        _context.numberFormats = _numberFormats.value;
        (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.clearNumberFormat)(_context, locale, format);
    }
    // for debug
    composerID++;
    // watch root locale & fallbackLocale
    if (__root && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(__root.locale, (val) => {
            if (_inheritLocale) {
                _locale.value = val;
                {
                    if (__legacy && !_isGlobal) {
                        __legacy.locale = val;
                    }
                }
                _context.locale = val;
                (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.updateFallbackLocale)(_context, _locale.value, _fallbackLocale.value);
            }
        });
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.watch)(__root.fallbackLocale, (val) => {
            if (_inheritLocale) {
                _fallbackLocale.value = val;
                {
                    if (__legacy && !_isGlobal) {
                        __legacy.fallbackLocale = val;
                    }
                }
                _context.fallbackLocale = val;
                (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.updateFallbackLocale)(_context, _locale.value, _fallbackLocale.value);
            }
        });
    }
    // define basic composition API!
    const composer = {
        id: composerID,
        locale,
        fallbackLocale,
        get inheritLocale() {
            return _inheritLocale;
        },
        set inheritLocale(val) {
            _inheritLocale = val;
            {
                if (__legacy) {
                    __legacy._sync = val;
                }
            }
            if (val && __root) {
                _locale.value = __root.locale.value;
                _fallbackLocale.value = __root.fallbackLocale.value;
                {
                    if (__legacy) {
                        __legacy.locale = __root.locale.value;
                        __legacy.fallbackLocale = __root.fallbackLocale.value;
                    }
                }
                (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.updateFallbackLocale)(_context, _locale.value, _fallbackLocale.value);
            }
        },
        get availableLocales() {
            return Object.keys(_messages.value).sort();
        },
        messages,
        get modifiers() {
            return _modifiers;
        },
        get pluralRules() {
            return _pluralRules || {};
        },
        get isGlobal() {
            return _isGlobal;
        },
        get missingWarn() {
            return _missingWarn;
        },
        set missingWarn(val) {
            _missingWarn = val;
            _context.missingWarn = _missingWarn;
        },
        get fallbackWarn() {
            return _fallbackWarn;
        },
        set fallbackWarn(val) {
            _fallbackWarn = val;
            _context.fallbackWarn = _fallbackWarn;
        },
        get fallbackRoot() {
            return _fallbackRoot;
        },
        set fallbackRoot(val) {
            _fallbackRoot = val;
        },
        get fallbackFormat() {
            return _fallbackFormat;
        },
        set fallbackFormat(val) {
            _fallbackFormat = val;
            _context.fallbackFormat = _fallbackFormat;
        },
        get warnHtmlMessage() {
            return _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
            _warnHtmlMessage = val;
            _context.warnHtmlMessage = val;
        },
        get escapeParameter() {
            return _escapeParameter;
        },
        set escapeParameter(val) {
            _escapeParameter = val;
            _context.escapeParameter = val;
        },
        t,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        [SetPluralRulesSymbol]: setPluralRules
    };
    {
        composer.datetimeFormats = datetimeFormats;
        composer.numberFormats = numberFormats;
        composer.rt = rt;
        composer.te = te;
        composer.tm = tm;
        composer.d = d;
        composer.n = n;
        composer.getDateTimeFormat = getDateTimeFormat;
        composer.setDateTimeFormat = setDateTimeFormat;
        composer.mergeDateTimeFormat = mergeDateTimeFormat;
        composer.getNumberFormat = getNumberFormat;
        composer.setNumberFormat = setNumberFormat;
        composer.mergeNumberFormat = mergeNumberFormat;
        composer[InejctWithOption] = options.__injectWithOption;
        composer[TransrateVNodeSymbol] = transrateVNode;
        composer[DatetimePartsSymbol] = datetimeParts;
        composer[NumberPartsSymbol] = numberParts;
    }
    {
        composer[LegacyInstanceSymbol] = __legacy;
    }
    return composer;
}
/* eslint-enable @typescript-eslint/no-explicit-any */

const baseFormatProps = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
        validator: (val /* ComponetI18nScope */) => val === 'parent' || val === 'global',
        default: 'parent' /* ComponetI18nScope */
    },
    i18n: {
        type: Object
    }
};

function getInterpolateArg(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
{ slots }, // SetupContext,
keys) {
    if (keys.length === 1 && keys[0] === 'default') {
        // default slot with list
        const ret = slots.default ? slots.default() : [];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return ret.reduce((slot, current) => {
            return (slot = [
                ...slot,
                ...((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(current.children) ? current.children : [current])
            ]);
        }, []);
    }
    else {
        // named slots
        return keys.reduce((arg, key) => {
            const slot = slots[key];
            if (slot) {
                arg[key] = slot();
            }
            return arg;
        }, {});
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getFragmentableTag(tag) {
    return tag;
}

/**
 * Translation Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [TranslationProps](component#translationprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Component Interpolation](../guide/advanced/component)
 *
 * @example
 * ```html
 * <div id="app">
 *   <!-- ... -->
 *   <i18n path="term" tag="label" for="tos">
 *     <a :href="url" target="_blank">{{ $t('tos') }}</a>
 *   </i18n>
 *   <!-- ... -->
 * </div>
 * ```
 * ```js
 * import { createApp } from 'vue'
 * import { createI18n } from 'vue-i18n'
 *
 * const messages = {
 *   en: {
 *     tos: 'Term of Service',
 *     term: 'I accept xxx {0}.'
 *   },
 *   ja: {
 *     tos: '利用規約',
 *     term: '私は xxx の{0}に同意します。'
 *   }
 * }
 *
 * const i18n = createI18n({
 *   locale: 'en',
 *   messages
 * })
 *
 * const app = createApp({
 *   data: {
 *     url: '/term'
 *   }
 * }).use(i18n).mount('#app')
 * ```
 *
 * @VueI18nComponent
 */
const Translation =  /* defineComponent */ {
    /* eslint-disable */
    name: 'i18n-t',
    props: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({
        keypath: {
            type: String,
            required: true
        },
        plural: {
            type: [Number, String],
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            validator: (val) => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(val) || !isNaN(val)
        }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
        const { slots, attrs } = context;
        // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
        const i18n = props.i18n ||
            useI18n({
                useScope: props.scope,
                __useComponent: true
            });
        return () => {
            const keys = Object.keys(slots).filter(key => key !== '_');
            const options = {};
            if (props.locale) {
                options.locale = props.locale;
            }
            if (props.plural !== undefined) {
                options.plural = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(props.plural) ? +props.plural : props.plural;
            }
            const arg = getInterpolateArg(context, keys);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const children = i18n[TransrateVNodeSymbol](props.keypath, arg, options);
            const assignedAttrs = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, attrs);
            const tag = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(props.tag) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(props.tag)
                ? props.tag
                : getFragmentableTag('span');
            return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.h)(tag, assignedAttrs, children);
        };
    }
};

function isVNode(target) {
    return (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(target) && !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
    const { slots, attrs } = context;
    return () => {
        const options = { part: true };
        let overrides = {};
        if (props.locale) {
            options.locale = props.locale;
        }
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(props.format)) {
            options.key = props.format;
        }
        else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(props.format)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(props.format.key)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                options.key = props.format.key;
            }
            // Filter out number format options only
            overrides = Object.keys(props.format).reduce((options, prop) => {
                return slotKeys.includes(prop)
                    ? (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options, { [prop]: props.format[prop] }) // eslint-disable-line @typescript-eslint/no-explicit-any
                    : options;
            }, {});
        }
        const parts = partFormatter(...[props.value, options, overrides]);
        let children = [options.key];
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(parts)) {
            children = parts.map((part, index) => {
                const slot = slots[part.type];
                const node = slot
                    ? slot({ [part.type]: part.value, index, parts })
                    : [part.value];
                if (isVNode(node)) {
                    node[0].key = `${part.type}-${index}`;
                }
                return node;
            });
        }
        else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(parts)) {
            children = [parts];
        }
        const assignedAttrs = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, attrs);
        const tag = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(props.tag) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(props.tag)
            ? props.tag
            : getFragmentableTag('span');
        return (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.h)(tag, assignedAttrs, children);
    };
}

/**
 * Number Format Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [FormattableProps](component#formattableprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Custom Formatting](../guide/essentials/number#custom-formatting)
 *
 * @VueI18nDanger
 * Not supported IE, due to no support `Intl.NumberFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/formatToParts)
 *
 * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-numberformat)
 *
 * @VueI18nComponent
 */
const NumberFormat =  /* defineComponent */ {
    /* eslint-disable */
    name: 'i18n-n',
    props: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({
        value: {
            type: Number,
            required: true
        },
        format: {
            type: [String, Object]
        }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
        const i18n = props.i18n ||
            useI18n({ useScope: 'parent', __useComponent: true });
        return renderFormatter(props, context, _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.NUMBER_FORMAT_OPTIONS_KEYS, (...args) => 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n[NumberPartsSymbol](...args));
    }
};

/**
 * Datetime Format Component
 *
 * @remarks
 * See the following items for property about details
 *
 * @VueI18nSee [FormattableProps](component#formattableprops)
 * @VueI18nSee [BaseFormatProps](component#baseformatprops)
 * @VueI18nSee [Custom Formatting](../guide/essentials/datetime#custom-formatting)
 *
 * @VueI18nDanger
 * Not supported IE, due to no support `Intl.DateTimeFormat#formatToParts` in [IE](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts)
 *
 * If you want to use it, you need to use [polyfill](https://github.com/formatjs/formatjs/tree/main/packages/intl-datetimeformat)
 *
 * @VueI18nComponent
 */
const DatetimeFormat =  /*defineComponent */ {
    /* eslint-disable */
    name: 'i18n-d',
    props: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({
        value: {
            type: [Number, Date],
            required: true
        },
        format: {
            type: [String, Object]
        }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
        const i18n = props.i18n ||
            useI18n({ useScope: 'parent', __useComponent: true });
        return renderFormatter(props, context, _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.DATETIME_FORMAT_OPTIONS_KEYS, (...args) => 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n[DatetimePartsSymbol](...args));
    }
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function apply(Vue, ...options) {
    const pluginOptions = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options[0])
        ? options[0]
        : {};
    const globalInstall = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(pluginOptions.globalInstall)
        ? pluginOptions.globalInstall
        : true;
    if (globalInstall) {
        // install components
        Vue.component(Translation.name, Translation);
        Vue.component(NumberFormat.name, NumberFormat);
        Vue.component(DatetimeFormat.name, DatetimeFormat);
    }
}

/**
 * Port from vue-i18n@v8.x
 * This mixin is used when we use vue-i18n-bridge
 */
function defineMixin(i18n, VueI18n // eslint-disable-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
) {
    return {
        beforeCreate() {
            const options = this.$options; // eslint-disable-line @typescript-eslint/no-explicit-any
            if (options.__VUE18N__INSTANCE__) {
                return;
            }
            options.i18n = options.i18n || (options.__i18nBridge ? {} : null);
            this._i18nBridgeRoot = i18n;
            if (i18n.mode === 'composition') {
                this._i18n = i18n;
                return;
            }
            if (options.i18n) {
                if (options.i18n instanceof VueI18n) {
                    // init locale messages via custom blocks
                    if (options.__i18nBridge) {
                        try {
                            const localeMessages = options.i18n && options.i18n.messages
                                ? options.i18n.messages
                                : {};
                            options.__i18nBridge.forEach(resource => deepCopy(JSON.parse(resource), localeMessages));
                            Object.keys(localeMessages).forEach((locale) => {
                                options.i18n.mergeLocaleMessage(locale, localeMessages[locale]);
                            });
                        }
                        catch (e) {
                            if ((true)) {
                                console.error(`Cannot parse locale messages via custom blocks.`, e);
                            }
                        }
                    }
                    this._i18n = options.i18n;
                    this._i18nWatcher = this._i18n.watchI18nData();
                }
                else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.i18n)) {
                    const rootI18n = this.$root &&
                        this.$root.$i18n &&
                        this.$root.$i18n instanceof VueI18n
                        ? this.$root.$i18n
                        : null;
                    // component local i18n
                    if (rootI18n) {
                        options.i18n.root = this.$root;
                        options.i18n.formatter = rootI18n.formatter;
                        options.i18n.fallbackLocale = rootI18n.fallbackLocale;
                        options.i18n.formatFallbackMessages =
                            rootI18n.formatFallbackMessages;
                        options.i18n.silentTranslationWarn = rootI18n.silentTranslationWarn;
                        options.i18n.silentFallbackWarn = rootI18n.silentFallbackWarn;
                        options.i18n.pluralizationRules = rootI18n.pluralizationRules;
                        options.i18n.preserveDirectiveContent =
                            rootI18n.preserveDirectiveContent;
                    }
                    // init locale messages via custom blocks
                    if (options.__i18nBridge) {
                        try {
                            const localeMessages = options.i18n && options.i18n.messages
                                ? options.i18n.messages
                                : {};
                            options.__i18nBridge.forEach(resource => deepCopy(JSON.parse(resource), localeMessages));
                            options.i18n.messages = localeMessages;
                        }
                        catch (e) {
                            if ((true)) {
                                (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn)(`Cannot parse locale messages via custom blocks.`, e);
                            }
                        }
                    }
                    const { sharedMessages } = options.i18n;
                    if (sharedMessages && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(sharedMessages)) {
                        deepCopy(sharedMessages, options.i18n.messages);
                    }
                    this._i18n = new VueI18n(options.i18n);
                    this._i18nWatcher = this._i18n.watchI18nData();
                    if (options.i18n.sync === undefined || !!options.i18n.sync) {
                        this._localeWatcher = this.$i18n.watchLocale();
                    }
                    if (rootI18n) {
                        rootI18n.onComponentInstanceCreated(this._i18n);
                    }
                }
                else {
                    if ((true)) {
                        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn)(`Cannot be interpreted 'i18n' option.`);
                    }
                }
            }
            else if (this.$root &&
                this.$root.$i18n &&
                this.$root.$i18n instanceof VueI18n) {
                // root i18n
                this._i18n = this.$root.$i18n;
            }
            else if (options.parent &&
                options.parent.$i18n &&
                options.parent.$i18n instanceof VueI18n) {
                // parent i18n
                this._i18n = options.parent.$i18n;
            }
        },
        beforeMount() {
            const options = this.$options; // eslint-disable-line @typescript-eslint/no-explicit-any
            if (options.__VUE18N__INSTANCE__) {
                return;
            }
            if (i18n.mode === 'composition') {
                return;
            }
            options.i18n = options.i18n || (options.__i18nBridge ? {} : null);
            if (options.i18n) {
                if (options.i18n instanceof VueI18n) {
                    // init locale messages via custom blocks
                    this._i18n.subscribeDataChanging(this);
                    this._subscribing = true;
                }
                else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.i18n)) {
                    this._i18n.subscribeDataChanging(this);
                    this._subscribing = true;
                }
                else {
                    if ((true)) {
                        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn)(`Cannot be interpreted 'i18n' option.`);
                    }
                }
            }
            else if (this.$root &&
                this.$root.$i18n &&
                this.$root.$i18n instanceof VueI18n) {
                this._i18n.subscribeDataChanging(this);
                this._subscribing = true;
            }
            else if (options.parent &&
                options.parent.$i18n &&
                options.parent.$i18n instanceof VueI18n) {
                this._i18n.subscribeDataChanging(this);
                this._subscribing = true;
            }
        },
        beforeDestroy() {
            const options = this.$options; // eslint-disable-line @typescript-eslint/no-explicit-any
            if (options.__VUE18N__INSTANCE__) {
                return;
            }
            if (this._i18nBridgeRoot) {
                delete this._i18nBridgeRoot;
                return;
            }
            if (i18n.mode === 'composition') {
                delete this._i18n;
                return;
            }
            if (!this._i18n) {
                return;
            }
            const self = this; // eslint-disable-line @typescript-eslint/no-explicit-any
            this.$nextTick(() => {
                if (self._subscribing) {
                    self._i18n.unsubscribeDataChanging(self);
                    delete self._subscribing;
                }
                if (self._i18nWatcher) {
                    self._i18nWatcher();
                    self._i18n.destroyVM();
                    delete self._i18nWatcher;
                }
                if (self._localeWatcher) {
                    self._localeWatcher();
                    delete self._localeWatcher;
                }
            });
        }
    };
}

// for bridge
let _legacyVueI18n = null; // eslint-disable-line @typescript-eslint/no-explicit-any
/**
 * Injection key for {@link useI18n}
 *
 * @remarks
 * The global injection key for I18n instances with `useI18n`. this injection key is used in Web Components.
 * Specify the i18n instance created by {@link createI18n} together with `provide` function.
 *
 * @VueI18nGeneral
 */
const I18nInjectionKey = 
/* #__PURE__*/ (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)('global-vue-i18n');
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function createI18n(options = {}, VueI18nLegacy) {
    {
        _legacyVueI18n = VueI18nLegacy;
    }
    // prettier-ignore
    const __legacyMode = __VUE_I18N_LEGACY_API__ && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.legacy)
            ? options.legacy
            : __VUE_I18N_LEGACY_API__;
    // prettier-ignore
    const __globalInjection = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.globalInjection)
        ? options.globalInjection
        : true;
    // prettier-ignore
    const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode
            ? !!options.allowComposition
            : true;
    const __instances = new Map();
    const [globalScope, __global] = createGlobal(options, __legacyMode, VueI18nLegacy);
    (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.makeSymbol)(( true) ? 'vue-i18n' : 0);
    function __getInstance(component) {
        return __instances.get(component) || null;
    }
    function __setInstance(component, instance) {
        __instances.set(component, instance);
    }
    function __deleteInstance(component) {
        __instances.delete(component);
    }
    {
        // extend legacy VueI18n instance
        const i18n = __global[LegacyInstanceSymbol]; // eslint-disable-line @typescript-eslint/no-explicit-any
        let _localeWatcher = null;
        Object.defineProperty(i18n, 'global', {
            get() {
                return __global;
            }
        });
        Object.defineProperty(i18n, 'mode', {
            get() {
                return __legacyMode ? 'legacy' : 'composition';
            }
        });
        Object.defineProperty(i18n, 'allowComposition', {
            get() {
                return __allowComposition;
            }
        });
        Object.defineProperty(i18n, '__instances', {
            get() {
                return __instances;
            }
        });
        Object.defineProperty(i18n, 'install', {
            writable: true,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            value: (Vue, ...options) => {
                const version = (Vue && Vue.version && Number(Vue.version.split('.')[0])) || -1;
                if (version !== 2) {
                    throw createI18nError(I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY);
                }
                __VUE_I18N_FULL_INSTALL__ && apply(Vue, ...options);
                if (!__legacyMode && __globalInjection) {
                    _localeWatcher = injectGlobalFieldsForBridge(Vue, i18n, __global);
                }
                Vue.mixin(defineMixin(i18n, _legacyVueI18n));
            }
        });
        Object.defineProperty(i18n, 'dispose', {
            value: () => {
                _localeWatcher && _localeWatcher();
                globalScope.stop();
            }
        });
        const methodMap = {
            __getInstance,
            __setInstance,
            __deleteInstance
        };
        Object.keys(methodMap).forEach(key => Object.defineProperty(i18n, key, { value: methodMap[key] }) // eslint-disable-line @typescript-eslint/no-explicit-any
        );
        return i18n;
    }
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function useI18n(options = {}) {
    const instance = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance)();
    if (instance == null) {
        throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
    }
    {
        if (_legacyVueI18n == null) {
            throw createI18nError(I18nErrorCodes.NOT_INSLALLED);
        }
    }
    const i18n = getI18nInstance(instance);
    const global = getGlobalComposer(i18n);
    const componentOptions = getComponentOptions(instance);
    const scope = getScope(options, componentOptions);
    if (__VUE_I18N_LEGACY_API__) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (i18n.mode === 'legacy' && !options.__useComponent) {
            if (!i18n.allowComposition) {
                throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
            }
            return useI18nForLegacy(instance, scope, global, options);
        }
    }
    if (scope === 'global') {
        adjustI18nResources(global, options, componentOptions);
        return global;
    }
    if (scope === 'parent') {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let composer = getComposer(i18n, instance, options.__useComponent);
        if (composer == null) {
            if ((true)) {
                (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn)(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
            }
            composer = global;
        }
        return composer;
    }
    const i18nInternal = i18n;
    let composer = i18nInternal.__getInstance(instance);
    if (composer == null) {
        const composerOptions = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options);
        if ('__i18n' in componentOptions) {
            composerOptions.__i18n = componentOptions.__i18n;
        }
        if (global) {
            composerOptions.__root = global;
        }
        composer = createComposer(composerOptions, _legacyVueI18n);
        setupLifeCycle(i18nInternal, instance, composer);
        i18nInternal.__setInstance(instance, composer);
    }
    return composer;
}
/**
 * Cast to VueI18n legacy compatible type
 *
 * @remarks
 * This API is provided only with [vue-i18n-bridge](https://vue-i18n.intlify.dev/guide/migration/ways.html#what-is-vue-i18n-bridge).
 *
 * The purpose of this function is to convert an {@link I18n} instance created with {@link createI18n | createI18n(legacy: true)} into a `vue-i18n@v8.x` compatible instance of `new VueI18n` in a TypeScript environment.
 *
 * @param i18n - An instance of {@link I18n}
 * @returns A i18n instance which is casted to {@link VueI18n} type
 *
 * @VueI18nTip
 * :new: provided by **vue-i18n-bridge only**
 *
 * @VueI18nGeneral
 */
const castToVueI18n =  (i18n
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) => {
    if (!(__VUE_I18N_BRIDGE__ in i18n)) {
        throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
    }
    return i18n;
};
function createGlobal(options, legacyMode, VueI18nLegacy // eslint-disable-line @typescript-eslint/no-explicit-any
) {
    const scope = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.effectScope)();
    {
        if (!isLegacyVueI18n(VueI18nLegacy)) {
            throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
        }
        const obj = scope.run(() => createComposer(options, VueI18nLegacy));
        if (obj == null) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        return [scope, obj];
    }
}
function getI18nInstance(instance) {
    {
        const vm = instance.proxy;
        /* istanbul ignore if */
        if (vm == null) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const i18n = vm._i18nBridgeRoot; // eslint-disable-line @typescript-eslint/no-explicit-any
        /* istanbul ignore if */
        if (!i18n) {
            throw createI18nError(I18nErrorCodes.NOT_INSLALLED);
        }
        return i18n;
    }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getScope(options, componentOptions) {
    // prettier-ignore
    return (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isEmptyObject)(options)
        ? ('__i18n' in componentOptions)
            ? 'local'
            : 'global'
        : !options.useScope
            ? 'local'
            : options.useScope;
}
function getGlobalComposer(i18n) {
    // prettier-ignore
    return i18n.global;
}
function getComposer(i18n, target, useComponent = false) {
    let composer = null;
    const root = target.root;
    let current = target.parent;
    while (current != null) {
        const i18nInternal = i18n;
        if (i18n.mode === 'composition') {
            composer = i18nInternal.__getInstance(current);
        }
        else {
            if (__VUE_I18N_LEGACY_API__) {
                const vueI18n = i18nInternal.__getInstance(current);
                if (vueI18n != null) {
                    composer = vueI18n
                        .__composer;
                    if (useComponent &&
                        composer &&
                        !composer[InejctWithOption] // eslint-disable-line @typescript-eslint/no-explicit-any
                    ) {
                        composer = null;
                    }
                }
            }
        }
        if (composer != null) {
            break;
        }
        if (root === current) {
            break;
        }
        current = current.parent;
    }
    return composer;
}
function setupLifeCycle(i18n, target, composer) {
    {
        // assign legacy VueI18n instance to Vue2 instance
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const vm = target.proxy;
        if (vm == null) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const _i18n = composer[LegacyInstanceSymbol];
        if (_i18n === i18n) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        vm._i18n = _i18n;
        vm._i18n_bridge = true;
        // browser only
        if (_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
            vm._i18nWatcher = vm._i18n.watchI18nData();
            if (vm._i18n._sync) {
                vm._localeWatcher = vm._i18n.watchLocale();
            }
        }
        let subscribing = false;
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount)(() => {
            vm._i18n.subscribeDataChanging(vm);
            subscribing = true;
        });
        (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {
            if (subscribing) {
                vm._i18n.unsubscribeDataChanging(vm);
                subscribing = false;
            }
            if (vm._i18nWatcher) {
                vm._i18nWatcher();
                vm._i18n.destroyVM();
                delete vm._i18nWatcher;
            }
            if (vm._localeWatcher) {
                vm._localeWatcher();
                delete vm._localeWatcher;
            }
            delete vm._i18n_bridge;
            delete vm._i18n;
        });
    }
}
function useI18nForLegacy(instance, scope, root, options = {} // eslint-disable-line @typescript-eslint/no-explicit-any
) {
    const isLocale = scope === 'local';
    const _composer = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(null);
    if (isLocale &&
        instance.proxy &&
        !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
        throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    }
    const _inheritLocale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.inheritLocale)
        ? options.inheritLocale
        : true;
    const _locale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(
    // prettier-ignore
    isLocale && _inheritLocale
        ? root.locale.value
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.locale)
            ? options.locale
            : _intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_LOCALE);
    const _fallbackLocale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(
    // prettier-ignore
    isLocale && _inheritLocale
        ? root.fallbackLocale.value
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.fallbackLocale) ||
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(options.fallbackLocale) ||
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.fallbackLocale) ||
            options.fallbackLocale === false
            ? options.fallbackLocale
            : _locale.value);
    const _messages = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)(getLocaleMessages(_locale.value, options));
    // prettier-ignore
    const _datetimeFormats = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.datetimeFormats)
        ? options.datetimeFormats
        : { [_locale.value]: {} });
    // prettier-ignore
    const _numberFormats = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.ref)((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.numberFormats)
        ? options.numberFormats
        : { [_locale.value]: {} });
    // prettier-ignore
    const _missingWarn = isLocale
        ? root.missingWarn
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.missingWarn) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(options.missingWarn)
            ? options.missingWarn
            : true;
    // prettier-ignore
    const _fallbackWarn = isLocale
        ? root.fallbackWarn
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackWarn) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(options.fallbackWarn)
            ? options.fallbackWarn
            : true;
    // prettier-ignore
    const _fallbackRoot = isLocale
        ? root.fallbackRoot
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackRoot)
            ? options.fallbackRoot
            : true;
    // configure fall back to root
    const _fallbackFormat = !!options.fallbackFormat;
    // runtime missing
    const _missing = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.missing) ? options.missing : null;
    // postTranslation handler
    const _postTranslation = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.postTranslation)
        ? options.postTranslation
        : null;
    // prettier-ignore
    const _warnHtmlMessage = isLocale
        ? root.warnHtmlMessage
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.warnHtmlMessage)
            ? options.warnHtmlMessage
            : true;
    const _escapeParameter = !!options.escapeParameter;
    // prettier-ignore
    const _modifiers = isLocale
        ? root.modifiers
        : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.modifiers)
            ? options.modifiers
            : {};
    // pluralRules
    const _pluralRules = options.pluralRules || (isLocale && root.pluralRules);
    // track reactivity
    function trackReactivityValues() {
        return [
            _locale.value,
            _fallbackLocale.value,
            _messages.value,
            _datetimeFormats.value,
            _numberFormats.value
        ];
    }
    // locale
    const locale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)({
        get: () => {
            return _composer.value ? _composer.value.locale.value : _locale.value;
        },
        set: val => {
            if (_composer.value) {
                _composer.value.locale.value = val;
            }
            _locale.value = val;
        }
    });
    // fallbackLocale
    const fallbackLocale = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)({
        get: () => {
            return _composer.value
                ? _composer.value.fallbackLocale.value
                : _fallbackLocale.value;
        },
        set: val => {
            if (_composer.value) {
                _composer.value.fallbackLocale.value = val;
            }
            _fallbackLocale.value = val;
        }
    });
    // messages
    const messages = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
        if (_composer.value) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return _composer.value.messages.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return _messages.value;
        }
    });
    const datetimeFormats = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => _datetimeFormats.value);
    const numberFormats = (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.computed)(() => _numberFormats.value);
    function getPostTranslationHandler() {
        return _composer.value
            ? _composer.value.getPostTranslationHandler()
            : _postTranslation;
    }
    function setPostTranslationHandler(handler) {
        if (_composer.value) {
            _composer.value.setPostTranslationHandler(handler);
        }
    }
    function getMissingHandler() {
        return _composer.value ? _composer.value.getMissingHandler() : _missing;
    }
    function setMissingHandler(handler) {
        if (_composer.value) {
            _composer.value.setMissingHandler(handler);
        }
    }
    function warpWithDeps(fn) {
        trackReactivityValues();
        return fn();
    }
    function t(...args) {
        return _composer.value
            ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args]))
            : warpWithDeps(() => '');
    }
    function rt(...args) {
        return _composer.value
            ? Reflect.apply(_composer.value.rt, null, [...args])
            : '';
    }
    function d(...args) {
        return _composer.value
            ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args]))
            : warpWithDeps(() => '');
    }
    function n(...args) {
        return _composer.value
            ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args]))
            : warpWithDeps(() => '');
    }
    function tm(key) {
        return _composer.value ? _composer.value.tm(key) : {};
    }
    function te(key, locale) {
        return _composer.value ? _composer.value.te(key, locale) : false;
    }
    function getLocaleMessage(locale) {
        return _composer.value ? _composer.value.getLocaleMessage(locale) : {};
    }
    function setLocaleMessage(locale, message) {
        if (_composer.value) {
            _composer.value.setLocaleMessage(locale, message);
            _messages.value[locale] = message;
        }
    }
    function mergeLocaleMessage(locale, message) {
        if (_composer.value) {
            _composer.value.mergeLocaleMessage(locale, message);
        }
    }
    function getDateTimeFormat(locale) {
        return _composer.value ? _composer.value.getDateTimeFormat(locale) : {};
    }
    function setDateTimeFormat(locale, format) {
        if (_composer.value) {
            _composer.value.setDateTimeFormat(locale, format);
            _datetimeFormats.value[locale] = format;
        }
    }
    function mergeDateTimeFormat(locale, format) {
        if (_composer.value) {
            _composer.value.mergeDateTimeFormat(locale, format);
        }
    }
    function getNumberFormat(locale) {
        return _composer.value ? _composer.value.getNumberFormat(locale) : {};
    }
    function setNumberFormat(locale, format) {
        if (_composer.value) {
            _composer.value.setNumberFormat(locale, format);
            _numberFormats.value[locale] = format;
        }
    }
    function mergeNumberFormat(locale, format) {
        if (_composer.value) {
            _composer.value.mergeNumberFormat(locale, format);
        }
    }
    const wrapper = {
        get id() {
            return _composer.value ? _composer.value.id : -1;
        },
        locale,
        fallbackLocale,
        messages,
        datetimeFormats,
        numberFormats,
        get inheritLocale() {
            return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
        },
        set inheritLocale(val) {
            if (_composer.value) {
                _composer.value.inheritLocale = val;
            }
        },
        get availableLocales() {
            return _composer.value
                ? _composer.value.availableLocales
                : Object.keys(_messages.value);
        },
        get modifiers() {
            return (_composer.value ? _composer.value.modifiers : _modifiers);
        },
        get pluralRules() {
            return (_composer.value ? _composer.value.pluralRules : _pluralRules);
        },
        get isGlobal() {
            return _composer.value ? _composer.value.isGlobal : false;
        },
        get missingWarn() {
            return _composer.value ? _composer.value.missingWarn : _missingWarn;
        },
        set missingWarn(val) {
            if (_composer.value) {
                _composer.value.missingWarn = val;
            }
        },
        get fallbackWarn() {
            return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
        },
        set fallbackWarn(val) {
            if (_composer.value) {
                _composer.value.missingWarn = val;
            }
        },
        get fallbackRoot() {
            return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
        },
        set fallbackRoot(val) {
            if (_composer.value) {
                _composer.value.fallbackRoot = val;
            }
        },
        get fallbackFormat() {
            return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
        },
        set fallbackFormat(val) {
            if (_composer.value) {
                _composer.value.fallbackFormat = val;
            }
        },
        get warnHtmlMessage() {
            return _composer.value
                ? _composer.value.warnHtmlMessage
                : _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
            if (_composer.value) {
                _composer.value.warnHtmlMessage = val;
            }
        },
        get escapeParameter() {
            return _composer.value
                ? _composer.value.escapeParameter
                : _escapeParameter;
        },
        set escapeParameter(val) {
            if (_composer.value) {
                _composer.value.escapeParameter = val;
            }
        },
        t,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        rt,
        d,
        n,
        tm,
        te,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getDateTimeFormat,
        setDateTimeFormat,
        mergeDateTimeFormat,
        getNumberFormat,
        setNumberFormat,
        mergeNumberFormat
    };
    function sync(composer) {
        composer.locale.value = _locale.value;
        composer.fallbackLocale.value = _fallbackLocale.value;
        Object.keys(_messages.value).forEach(locale => {
            composer.mergeLocaleMessage(locale, _messages.value[locale]);
        });
        Object.keys(_datetimeFormats.value).forEach(locale => {
            composer.mergeDateTimeFormat(locale, _datetimeFormats.value[locale]);
        });
        Object.keys(_numberFormats.value).forEach(locale => {
            composer.mergeNumberFormat(locale, _numberFormats.value[locale]);
        });
        composer.escapeParameter = _escapeParameter;
        composer.fallbackFormat = _fallbackFormat;
        composer.fallbackRoot = _fallbackRoot;
        composer.fallbackWarn = _fallbackWarn;
        composer.missingWarn = _missingWarn;
        composer.warnHtmlMessage = _warnHtmlMessage;
    }
    (0,vue_demi__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount)(() => {
        if (instance.proxy == null || instance.proxy.$i18n == null) {
            throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const composer = (_composer.value = instance.proxy.$i18n
            .__composer);
        if (scope === 'global') {
            _locale.value = composer.locale.value;
            _fallbackLocale.value = composer.fallbackLocale.value;
            _messages.value = composer.messages.value;
            _datetimeFormats.value = composer.datetimeFormats.value;
            _numberFormats.value = composer.numberFormats.value;
        }
        else if (isLocale) {
            sync(composer);
        }
    });
    return wrapper;
}
function injectGlobalFieldsForBridge(Vue, // eslint-disable-line @typescript-eslint/no-explicit-any
i18n, // eslint-disable-line @typescript-eslint/no-explicit-any
composer) {
    // The composition mode in vue-i18n-bridge is `$18n` is the VueI18n instance.
    // so we need to tell composer to change the locale.
    // If we don't do, things like `$t` that are injected will not be reacted.
    const watcher = i18n.watchLocale(composer);
    // define fowardcompatible vue-i18n-next inject fields with `globalInjection`
    Vue.prototype.$t = function (...args) {
        return Reflect.apply(composer.t, composer, [...args]);
    };
    Vue.prototype.$d = function (...args) {
        return Reflect.apply(composer.d, composer, [...args]);
    };
    Vue.prototype.$n = function (...args) {
        return Reflect.apply(composer.n, composer, [...args]);
    };
    return watcher;
}

// register message compiler at vue-i18n
(0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.registerMessageCompiler)(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.compileToFunction);
// register message resolver at vue-i18n
(0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.registerMessageResolver)(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.resolveValue);
// register fallback locale at vue-i18n
(0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.registerLocaleFallbacker)(_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.fallbackWithLocaleChain);
{
    initFeatureFlags();
}
// NOTE: experimental !!
if (true) {
    const target = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)();
    target.__INTLIFY__ = true;
    (0,_intlify_core_base__WEBPACK_IMPORTED_MODULE_2__.setDevToolsHook)(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
if ((true)) ;




/***/ }),
/* 22 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EffectScope": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.EffectScope; },
/* harmony export */   "Vue": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "Vue2": function() { return /* binding */ Vue2; },
/* harmony export */   "computed": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.computed; },
/* harmony export */   "createApp": function() { return /* binding */ createApp; },
/* harmony export */   "customRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.customRef; },
/* harmony export */   "defineAsyncComponent": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineAsyncComponent; },
/* harmony export */   "defineComponent": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent; },
/* harmony export */   "del": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.del; },
/* harmony export */   "effectScope": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope; },
/* harmony export */   "h": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.h; },
/* harmony export */   "inject": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.inject; },
/* harmony export */   "install": function() { return /* binding */ install; },
/* harmony export */   "isProxy": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isProxy; },
/* harmony export */   "isReactive": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReactive; },
/* harmony export */   "isReadonly": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReadonly; },
/* harmony export */   "isRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRef; },
/* harmony export */   "isShallow": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isShallow; },
/* harmony export */   "isVue2": function() { return /* binding */ isVue2; },
/* harmony export */   "isVue3": function() { return /* binding */ isVue3; },
/* harmony export */   "markRaw": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.markRaw; },
/* harmony export */   "mergeDefaults": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.mergeDefaults; },
/* harmony export */   "nextTick": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.nextTick; },
/* harmony export */   "onActivated": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onActivated; },
/* harmony export */   "onBeforeMount": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onBeforeUpdate; },
/* harmony export */   "onDeactivated": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onDeactivated; },
/* harmony export */   "onErrorCaptured": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onErrorCaptured; },
/* harmony export */   "onMounted": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onMounted; },
/* harmony export */   "onRenderTracked": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTracked; },
/* harmony export */   "onRenderTriggered": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onRenderTriggered; },
/* harmony export */   "onScopeDispose": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },
/* harmony export */   "onServerPrefetch": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onServerPrefetch; },
/* harmony export */   "onUnmounted": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onUpdated; },
/* harmony export */   "provide": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.provide; },
/* harmony export */   "proxyRefs": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.proxyRefs; },
/* harmony export */   "reactive": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.reactive; },
/* harmony export */   "readonly": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.readonly; },
/* harmony export */   "ref": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ref; },
/* harmony export */   "set": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.set; },
/* harmony export */   "shallowReactive": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },
/* harmony export */   "shallowReadonly": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReadonly; },
/* harmony export */   "shallowRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },
/* harmony export */   "toRaw": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRaw; },
/* harmony export */   "toRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRef; },
/* harmony export */   "toRefs": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRefs; },
/* harmony export */   "triggerRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },
/* harmony export */   "unref": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.unref; },
/* harmony export */   "useAttrs": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useAttrs; },
/* harmony export */   "useCssModule": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssModule; },
/* harmony export */   "useCssVars": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useCssVars; },
/* harmony export */   "useListeners": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useListeners; },
/* harmony export */   "useSlots": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.useSlots; },
/* harmony export */   "version": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.version; },
/* harmony export */   "warn": function() { return /* binding */ warn; },
/* harmony export */   "watch": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watch; },
/* harmony export */   "watchEffect": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);


var isVue2 = true
var isVue3 = false
var Vue2 = vue__WEBPACK_IMPORTED_MODULE_0__["default"]
var warn = vue__WEBPACK_IMPORTED_MODULE_0__["default"].util.warn

function install() {}

// createApp polyfill
function createApp(rootComponent, rootProps) {
  var vm
  var provide = {}
  var app = {
    config: vue__WEBPACK_IMPORTED_MODULE_0__["default"].config,
    use: vue__WEBPACK_IMPORTED_MODULE_0__["default"].use.bind(vue__WEBPACK_IMPORTED_MODULE_0__["default"]),
    mixin: vue__WEBPACK_IMPORTED_MODULE_0__["default"].mixin.bind(vue__WEBPACK_IMPORTED_MODULE_0__["default"]),
    component: vue__WEBPACK_IMPORTED_MODULE_0__["default"].component.bind(vue__WEBPACK_IMPORTED_MODULE_0__["default"]),
    provide: function (key, value) {
      provide[key] = value
      return this
    },
    directive: function (name, dir) {
      if (dir) {
        vue__WEBPACK_IMPORTED_MODULE_0__["default"].directive(name, dir)
        return app
      } else {
        return vue__WEBPACK_IMPORTED_MODULE_0__["default"].directive(name)
      }
    },
    mount: function (el, hydrating) {
      if (!vm) {
        vm = new vue__WEBPACK_IMPORTED_MODULE_0__["default"](Object.assign({ propsData: rootProps }, rootComponent, { provide: Object.assign(provide, rootComponent.provide) }))
        vm.$mount(el, hydrating)
        return vm
      } else {
        return vm
      }
    },
    unmount: function () {
      if (vm) {
        vm.$destroy()
        vm = undefined
      }
    },
  }
  return app
}





/***/ }),
/* 23 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assign": function() { return /* binding */ assign; },
/* harmony export */   "createEmitter": function() { return /* binding */ createEmitter; },
/* harmony export */   "escapeHtml": function() { return /* binding */ escapeHtml; },
/* harmony export */   "format": function() { return /* binding */ format; },
/* harmony export */   "friendlyJSONstringify": function() { return /* binding */ friendlyJSONstringify; },
/* harmony export */   "generateCodeFrame": function() { return /* binding */ generateCodeFrame; },
/* harmony export */   "generateFormatCacheKey": function() { return /* binding */ generateFormatCacheKey; },
/* harmony export */   "getGlobalThis": function() { return /* binding */ getGlobalThis; },
/* harmony export */   "hasOwn": function() { return /* binding */ hasOwn; },
/* harmony export */   "inBrowser": function() { return /* binding */ inBrowser; },
/* harmony export */   "isArray": function() { return /* binding */ isArray; },
/* harmony export */   "isBoolean": function() { return /* binding */ isBoolean; },
/* harmony export */   "isDate": function() { return /* binding */ isDate; },
/* harmony export */   "isEmptyObject": function() { return /* binding */ isEmptyObject; },
/* harmony export */   "isFunction": function() { return /* binding */ isFunction; },
/* harmony export */   "isNumber": function() { return /* binding */ isNumber; },
/* harmony export */   "isObject": function() { return /* binding */ isObject; },
/* harmony export */   "isPlainObject": function() { return /* binding */ isPlainObject; },
/* harmony export */   "isPromise": function() { return /* binding */ isPromise; },
/* harmony export */   "isRegExp": function() { return /* binding */ isRegExp; },
/* harmony export */   "isString": function() { return /* binding */ isString; },
/* harmony export */   "isSymbol": function() { return /* binding */ isSymbol; },
/* harmony export */   "makeSymbol": function() { return /* binding */ makeSymbol; },
/* harmony export */   "mark": function() { return /* binding */ mark; },
/* harmony export */   "measure": function() { return /* binding */ measure; },
/* harmony export */   "objectToString": function() { return /* binding */ objectToString; },
/* harmony export */   "toDisplayString": function() { return /* binding */ toDisplayString; },
/* harmony export */   "toTypeString": function() { return /* binding */ toTypeString; },
/* harmony export */   "warn": function() { return /* binding */ warn; }
/* harmony export */ });
/*!
  * shared v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
/**
 * Original Utilities
 * written by kazuya kawaguchi
 */
const inBrowser = typeof window !== 'undefined';
let mark;
let measure;
if ((true)) {
    const perf = inBrowser && window.performance;
    if (perf &&
        perf.mark &&
        perf.measure &&
        perf.clearMarks &&
        perf.clearMeasures) {
        mark = (tag) => perf.mark(tag);
        measure = (name, startTag, endTag) => {
            perf.measure(name, startTag, endTag);
            perf.clearMarks(startTag);
            perf.clearMarks(endTag);
        };
    }
}
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
/* eslint-disable */
function format(message, ...args) {
    if (args.length === 1 && isObject(args[0])) {
        args = args[0];
    }
    if (!args || !args.hasOwnProperty) {
        args = {};
    }
    return message.replace(RE_ARGS, (match, identifier) => {
        return args.hasOwnProperty(identifier) ? args[identifier] : '';
    });
}
const hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
const makeSymbol = (name) => hasSymbol ? Symbol(name) : name;
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json)
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
    .replace(/\u0027/g, '\\u0027');
const isNumber = (val) => typeof val === 'number' && isFinite(val);
const isDate = (val) => toTypeString(val) === '[object Date]';
const isRegExp = (val) => toTypeString(val) === '[object RegExp]';
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
function warn(msg, err) {
    if (typeof console !== 'undefined') {
        console.warn(`[intlify] ` + msg);
        /* istanbul ignore if */
        if (err) {
            console.warn(err.stack);
        }
    }
}
const assign = Object.assign;
let _globalThis;
const getGlobalThis = () => {
    // prettier-ignore
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};
function escapeHtml(rawText) {
    return rawText
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
}
/* eslint-enable */
/**
 * Useful Utilities By Evan you
 * Modified by kazuya kawaguchi
 * MIT License
 * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/index.ts
 * https://github.com/vuejs/vue-next/blob/master/packages/shared/src/codeframe.ts
 */
const isArray = Array.isArray;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isBoolean = (val) => typeof val === 'boolean';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => // eslint-disable-line
 val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
// for converting list and named values to displayed strings.
const toDisplayString = (val) => {
    return val == null
        ? ''
        : isArray(val) || (isPlainObject(val) && val.toString === objectToString)
            ? JSON.stringify(val, null, 2)
            : String(val);
};
const RANGE = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - RANGE; j <= i + RANGE || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

/**
 * Event emitter, forked from the below:
 * - original repository url: https://github.com/developit/mitt
 * - code url: https://github.com/developit/mitt/blob/master/src/index.ts
 * - author: Jason Miller (https://github.com/developit)
 * - license: MIT
 */
/**
 * Create a event emitter
 *
 * @returns An event emitter
 */
function createEmitter() {
    const events = new Map();
    const emitter = {
        events,
        on(event, handler) {
            const handlers = events.get(event);
            const added = handlers && handlers.push(handler);
            if (!added) {
                events.set(event, [handler]);
            }
        },
        off(event, handler) {
            const handlers = events.get(event);
            if (handlers) {
                handlers.splice(handlers.indexOf(handler) >>> 0, 1);
            }
        },
        emit(event, payload) {
            (events.get(event) || [])
                .slice()
                .map(handler => handler(payload));
            (events.get('*') || [])
                .slice()
                .map(handler => handler(event, payload));
        }
    };
    return emitter;
}




/***/ }),
/* 24 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompileErrorCodes": function() { return /* reexport safe */ _intlify_message_compiler__WEBPACK_IMPORTED_MODULE_0__.CompileErrorCodes; },
/* harmony export */   "CoreErrorCodes": function() { return /* binding */ CoreErrorCodes; },
/* harmony export */   "CoreWarnCodes": function() { return /* binding */ CoreWarnCodes; },
/* harmony export */   "DATETIME_FORMAT_OPTIONS_KEYS": function() { return /* binding */ DATETIME_FORMAT_OPTIONS_KEYS; },
/* harmony export */   "DEFAULT_LOCALE": function() { return /* binding */ DEFAULT_LOCALE; },
/* harmony export */   "DEFAULT_MESSAGE_DATA_TYPE": function() { return /* binding */ DEFAULT_MESSAGE_DATA_TYPE; },
/* harmony export */   "MISSING_RESOLVE_VALUE": function() { return /* binding */ MISSING_RESOLVE_VALUE; },
/* harmony export */   "NOT_REOSLVED": function() { return /* binding */ NOT_REOSLVED; },
/* harmony export */   "NUMBER_FORMAT_OPTIONS_KEYS": function() { return /* binding */ NUMBER_FORMAT_OPTIONS_KEYS; },
/* harmony export */   "VERSION": function() { return /* binding */ VERSION; },
/* harmony export */   "clearCompileCache": function() { return /* binding */ clearCompileCache; },
/* harmony export */   "clearDateTimeFormat": function() { return /* binding */ clearDateTimeFormat; },
/* harmony export */   "clearNumberFormat": function() { return /* binding */ clearNumberFormat; },
/* harmony export */   "compileToFunction": function() { return /* binding */ compileToFunction; },
/* harmony export */   "createCompileError": function() { return /* reexport safe */ _intlify_message_compiler__WEBPACK_IMPORTED_MODULE_0__.createCompileError; },
/* harmony export */   "createCoreContext": function() { return /* binding */ createCoreContext; },
/* harmony export */   "createCoreError": function() { return /* binding */ createCoreError; },
/* harmony export */   "createMessageContext": function() { return /* binding */ createMessageContext; },
/* harmony export */   "datetime": function() { return /* binding */ datetime; },
/* harmony export */   "fallbackWithLocaleChain": function() { return /* binding */ fallbackWithLocaleChain; },
/* harmony export */   "fallbackWithSimple": function() { return /* binding */ fallbackWithSimple; },
/* harmony export */   "getAdditionalMeta": function() { return /* binding */ getAdditionalMeta; },
/* harmony export */   "getDevToolsHook": function() { return /* binding */ getDevToolsHook; },
/* harmony export */   "getFallbackContext": function() { return /* binding */ getFallbackContext; },
/* harmony export */   "getWarnMessage": function() { return /* binding */ getWarnMessage; },
/* harmony export */   "handleMissing": function() { return /* binding */ handleMissing; },
/* harmony export */   "initI18nDevTools": function() { return /* binding */ initI18nDevTools; },
/* harmony export */   "isMessageFunction": function() { return /* binding */ isMessageFunction; },
/* harmony export */   "isTranslateFallbackWarn": function() { return /* binding */ isTranslateFallbackWarn; },
/* harmony export */   "isTranslateMissingWarn": function() { return /* binding */ isTranslateMissingWarn; },
/* harmony export */   "number": function() { return /* binding */ number; },
/* harmony export */   "parse": function() { return /* binding */ parse; },
/* harmony export */   "parseDateTimeArgs": function() { return /* binding */ parseDateTimeArgs; },
/* harmony export */   "parseNumberArgs": function() { return /* binding */ parseNumberArgs; },
/* harmony export */   "parseTranslateArgs": function() { return /* binding */ parseTranslateArgs; },
/* harmony export */   "registerLocaleFallbacker": function() { return /* binding */ registerLocaleFallbacker; },
/* harmony export */   "registerMessageCompiler": function() { return /* binding */ registerMessageCompiler; },
/* harmony export */   "registerMessageResolver": function() { return /* binding */ registerMessageResolver; },
/* harmony export */   "resolveValue": function() { return /* binding */ resolveValue; },
/* harmony export */   "resolveWithKeyValue": function() { return /* binding */ resolveWithKeyValue; },
/* harmony export */   "setAdditionalMeta": function() { return /* binding */ setAdditionalMeta; },
/* harmony export */   "setDevToolsHook": function() { return /* binding */ setDevToolsHook; },
/* harmony export */   "setFallbackContext": function() { return /* binding */ setFallbackContext; },
/* harmony export */   "translate": function() { return /* binding */ translate; },
/* harmony export */   "translateDevTools": function() { return /* binding */ translateDevTools; },
/* harmony export */   "updateFallbackLocale": function() { return /* binding */ updateFallbackLocale; }
/* harmony export */ });
/* harmony import */ var _intlify_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _intlify_message_compiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _intlify_devtools_if__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/*!
  * core-base v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */





const pathStateMachine =  [];
pathStateMachine[0 /* BEFORE_PATH */] = {
    ["w" /* WORKSPACE */]: [0 /* BEFORE_PATH */],
    ["i" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],
    ["[" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],
    ["o" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]
};
pathStateMachine[1 /* IN_PATH */] = {
    ["w" /* WORKSPACE */]: [1 /* IN_PATH */],
    ["." /* DOT */]: [2 /* BEFORE_IDENT */],
    ["[" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */],
    ["o" /* END_OF_FAIL */]: [7 /* AFTER_PATH */]
};
pathStateMachine[2 /* BEFORE_IDENT */] = {
    ["w" /* WORKSPACE */]: [2 /* BEFORE_IDENT */],
    ["i" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],
    ["0" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */]
};
pathStateMachine[3 /* IN_IDENT */] = {
    ["i" /* IDENT */]: [3 /* IN_IDENT */, 0 /* APPEND */],
    ["0" /* ZERO */]: [3 /* IN_IDENT */, 0 /* APPEND */],
    ["w" /* WORKSPACE */]: [1 /* IN_PATH */, 1 /* PUSH */],
    ["." /* DOT */]: [2 /* BEFORE_IDENT */, 1 /* PUSH */],
    ["[" /* LEFT_BRACKET */]: [4 /* IN_SUB_PATH */, 1 /* PUSH */],
    ["o" /* END_OF_FAIL */]: [7 /* AFTER_PATH */, 1 /* PUSH */]
};
pathStateMachine[4 /* IN_SUB_PATH */] = {
    ["'" /* SINGLE_QUOTE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */],
    ["\"" /* DOUBLE_QUOTE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */],
    ["[" /* LEFT_BRACKET */]: [
        4 /* IN_SUB_PATH */,
        2 /* INC_SUB_PATH_DEPTH */
    ],
    ["]" /* RIGHT_BRACKET */]: [1 /* IN_PATH */, 3 /* PUSH_SUB_PATH */],
    ["o" /* END_OF_FAIL */]: 8 /* ERROR */,
    ["l" /* ELSE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */]
};
pathStateMachine[5 /* IN_SINGLE_QUOTE */] = {
    ["'" /* SINGLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],
    ["o" /* END_OF_FAIL */]: 8 /* ERROR */,
    ["l" /* ELSE */]: [5 /* IN_SINGLE_QUOTE */, 0 /* APPEND */]
};
pathStateMachine[6 /* IN_DOUBLE_QUOTE */] = {
    ["\"" /* DOUBLE_QUOTE */]: [4 /* IN_SUB_PATH */, 0 /* APPEND */],
    ["o" /* END_OF_FAIL */]: 8 /* ERROR */,
    ["l" /* ELSE */]: [6 /* IN_DOUBLE_QUOTE */, 0 /* APPEND */]
};
/**
 * Check if an expression is a literal value.
 */
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
    return literalValueRE.test(exp);
}
/**
 * Strip quotes from a string
 */
function stripQuotes(str) {
    const a = str.charCodeAt(0);
    const b = str.charCodeAt(str.length - 1);
    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
}
/**
 * Determine the type of a character in a keypath.
 */
function getPathCharType(ch) {
    if (ch === undefined || ch === null) {
        return "o" /* END_OF_FAIL */;
    }
    const code = ch.charCodeAt(0);
    switch (code) {
        case 0x5b: // [
        case 0x5d: // ]
        case 0x2e: // .
        case 0x22: // "
        case 0x27: // '
            return ch;
        case 0x5f: // _
        case 0x24: // $
        case 0x2d: // -
            return "i" /* IDENT */;
        case 0x09: // Tab (HT)
        case 0x0a: // Newline (LF)
        case 0x0d: // Return (CR)
        case 0xa0: // No-break space (NBSP)
        case 0xfeff: // Byte Order Mark (BOM)
        case 0x2028: // Line Separator (LS)
        case 0x2029: // Paragraph Separator (PS)
            return "w" /* WORKSPACE */;
    }
    return "i" /* IDENT */;
}
/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 */
function formatSubPath(path) {
    const trimmed = path.trim();
    // invalid leading 0
    if (path.charAt(0) === '0' && isNaN(parseInt(path))) {
        return false;
    }
    return isLiteral(trimmed)
        ? stripQuotes(trimmed)
        : "*" /* ASTARISK */ + trimmed;
}
/**
 * Parse a string path into an array of segments
 */
function parse(path) {
    const keys = [];
    let index = -1;
    let mode = 0 /* BEFORE_PATH */;
    let subPathDepth = 0;
    let c;
    let key; // eslint-disable-line
    let newChar;
    let type;
    let transition;
    let action;
    let typeMap;
    const actions = [];
    actions[0 /* APPEND */] = () => {
        if (key === undefined) {
            key = newChar;
        }
        else {
            key += newChar;
        }
    };
    actions[1 /* PUSH */] = () => {
        if (key !== undefined) {
            keys.push(key);
            key = undefined;
        }
    };
    actions[2 /* INC_SUB_PATH_DEPTH */] = () => {
        actions[0 /* APPEND */]();
        subPathDepth++;
    };
    actions[3 /* PUSH_SUB_PATH */] = () => {
        if (subPathDepth > 0) {
            subPathDepth--;
            mode = 4 /* IN_SUB_PATH */;
            actions[0 /* APPEND */]();
        }
        else {
            subPathDepth = 0;
            if (key === undefined) {
                return false;
            }
            key = formatSubPath(key);
            if (key === false) {
                return false;
            }
            else {
                actions[1 /* PUSH */]();
            }
        }
    };
    function maybeUnescapeQuote() {
        const nextChar = path[index + 1];
        if ((mode === 5 /* IN_SINGLE_QUOTE */ &&
            nextChar === "'" /* SINGLE_QUOTE */) ||
            (mode === 6 /* IN_DOUBLE_QUOTE */ &&
                nextChar === "\"" /* DOUBLE_QUOTE */)) {
            index++;
            newChar = '\\' + nextChar;
            actions[0 /* APPEND */]();
            return true;
        }
    }
    while (mode !== null) {
        index++;
        c = path[index];
        if (c === '\\' && maybeUnescapeQuote()) {
            continue;
        }
        type = getPathCharType(c);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type] || typeMap["l" /* ELSE */] || 8 /* ERROR */;
        // check parse error
        if (transition === 8 /* ERROR */) {
            return;
        }
        mode = transition[0];
        if (transition[1] !== undefined) {
            action = actions[transition[1]];
            if (action) {
                newChar = c;
                if (action() === false) {
                    return;
                }
            }
        }
        // check parse finish
        if (mode === 7 /* AFTER_PATH */) {
            return keys;
        }
    }
}
// path token cache
const cache = new Map();
/**
 * key-value message resolver
 *
 * @remarks
 * Resolves messages with the key-value structure. Note that messages with a hierarchical structure such as objects cannot be resolved
 *
 * @param obj - A target object to be resolved with path
 * @param path - A {@link Path | path} to resolve the value of message
 *
 * @returns A resolved {@link PathValue | path value}
 *
 * @VueI18nGeneral
 */
function resolveWithKeyValue(obj, path) {
    return (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj) ? obj[path] : null;
}
/**
 * message resolver
 *
 * @remarks
 * Resolves messages. messages with a hierarchical structure such as objects can be resolved. This resolver is used in VueI18n as default.
 *
 * @param obj - A target object to be resolved with path
 * @param path - A {@link Path | path} to resolve the value of message
 *
 * @returns A resolved {@link PathValue | path value}
 *
 * @VueI18nGeneral
 */
function resolveValue(obj, path) {
    // check object
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(obj)) {
        return null;
    }
    // parse path
    let hit = cache.get(path);
    if (!hit) {
        hit = parse(path);
        if (hit) {
            cache.set(path, hit);
        }
    }
    // check hit
    if (!hit) {
        return null;
    }
    // resolve path value
    const len = hit.length;
    let last = obj;
    let i = 0;
    while (i < len) {
        const val = last[hit[i]];
        if (val === undefined) {
            return null;
        }
        last = val;
        i++;
    }
    return last;
}

const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => ''; // eslint-disable-line
const DEFAULT_MESSAGE_DATA_TYPE = 'text';
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? '' : values.join('');
const DEFAULT_INTERPOLATE = _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.toDisplayString;
function pluralDefault(choice, choicesLength) {
    choice = Math.abs(choice);
    if (choicesLength === 2) {
        // prettier-ignore
        return choice
            ? choice > 1
                ? 1
                : 0
            : 1;
    }
    return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
    // prettier-ignore
    const index = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(options.pluralIndex)
        ? options.pluralIndex
        : -1;
    // prettier-ignore
    return options.named && ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(options.named.count) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(options.named.n))
        ? (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(options.named.count)
            ? options.named.count
            : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(options.named.n)
                ? options.named.n
                : index
        : index;
}
function normalizeNamed(pluralIndex, props) {
    if (!props.count) {
        props.count = pluralIndex;
    }
    if (!props.n) {
        props.n = pluralIndex;
    }
}
function createMessageContext(options = {}) {
    const locale = options.locale;
    const pluralIndex = getPluralIndex(options);
    const pluralRule = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.pluralRules) &&
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(locale) &&
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.pluralRules[locale])
        ? options.pluralRules[locale]
        : pluralDefault;
    const orgPluralRule = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.pluralRules) &&
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(locale) &&
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.pluralRules[locale])
        ? pluralDefault
        : undefined;
    const plural = (messages) => {
        return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
    };
    const _list = options.list || [];
    const list = (index) => _list[index];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const _named = options.named || {};
    (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
    const named = (key) => _named[key];
    function message(key) {
        // prettier-ignore
        const msg = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.messages)
            ? options.messages(key)
            : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.messages)
                ? options.messages[key]
                : false;
        return !msg
            ? options.parent
                ? options.parent.message(key) // resolve from parent messages
                : DEFAULT_MESSAGE
            : msg;
    }
    const _modifier = (name) => options.modifiers
        ? options.modifiers[name]
        : DEFAULT_MODIFIER;
    const normalize = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.processor) && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.processor.normalize)
        ? options.processor.normalize
        : DEFAULT_NORMALIZE;
    const interpolate = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.processor) &&
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.processor.interpolate)
        ? options.processor.interpolate
        : DEFAULT_INTERPOLATE;
    const type = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.processor) && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.processor.type)
        ? options.processor.type
        : DEFAULT_MESSAGE_DATA_TYPE;
    const linked = (key, ...args) => {
        const [arg1, arg2] = args;
        let type = 'text';
        let modifier = '';
        if (args.length === 1) {
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(arg1)) {
                modifier = arg1.modifier || modifier;
                type = arg1.type || type;
            }
            else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg1)) {
                modifier = arg1 || modifier;
            }
        }
        else if (args.length === 2) {
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg1)) {
                modifier = arg1 || modifier;
            }
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg2)) {
                type = arg2 || type;
            }
        }
        let msg = message(key)(ctx);
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        if (type === 'vnode' && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(msg) && modifier) {
            msg = msg[0];
        }
        return modifier ? _modifier(modifier)(msg, type) : msg;
    };
    const ctx = {
        ["list" /* LIST */]: list,
        ["named" /* NAMED */]: named,
        ["plural" /* PLURAL */]: plural,
        ["linked" /* LINKED */]: linked,
        ["message" /* MESSAGE */]: message,
        ["type" /* TYPE */]: type,
        ["interpolate" /* INTERPOLATE */]: interpolate,
        ["normalize" /* NORMALIZE */]: normalize
    };
    return ctx;
}

let devtools = null;
function setDevToolsHook(hook) {
    devtools = hook;
}
function getDevToolsHook() {
    return devtools;
}
function initI18nDevTools(i18n, version, meta) {
    // TODO: queue if devtools is undefined
    devtools &&
        devtools.emit(_intlify_devtools_if__WEBPACK_IMPORTED_MODULE_2__.IntlifyDevToolsHooks.I18nInit, {
            timestamp: Date.now(),
            i18n,
            version,
            meta
        });
}
const translateDevTools = /* #__PURE__*/ createDevToolsHook(_intlify_devtools_if__WEBPACK_IMPORTED_MODULE_2__.IntlifyDevToolsHooks.FunctionTranslate);
function createDevToolsHook(hook) {
    return (payloads) => devtools && devtools.emit(hook, payloads);
}

const CoreWarnCodes = {
    NOT_FOUND_KEY: 1,
    FALLBACK_TO_TRANSLATE: 2,
    CANNOT_FORMAT_NUMBER: 3,
    FALLBACK_TO_NUMBER_FORMAT: 4,
    CANNOT_FORMAT_DATE: 5,
    FALLBACK_TO_DATE_FORMAT: 6,
    __EXTEND_POINT__: 7
};
/** @internal */
const warnMessages = {
    [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
    [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
    [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
    [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
    [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
    [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`
};
function getWarnMessage(code, ...args) {
    return (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.format)(warnMessages[code], ...args);
}

/**
 * Fallback with simple implemenation
 *
 * @remarks
 * A fallback locale function implemented with a simple fallback algorithm.
 *
 * Basically, it returns the value as specified in the `fallbackLocale` props, and is processed with the fallback inside intlify.
 *
 * @param ctx - A {@link CoreContext | context}
 * @param fallback - A {@link FallbackLocale | fallback locale}
 * @param start - A starting {@link Locale | locale}
 *
 * @returns Fallback locales
 *
 * @VueI18nGeneral
 */
function fallbackWithSimple(ctx, fallback, start // eslint-disable-line @typescript-eslint/no-unused-vars
) {
    // prettier-ignore
    return [...new Set([
            start,
            ...((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fallback)
                ? fallback
                : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(fallback)
                    ? Object.keys(fallback)
                    : (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(fallback)
                        ? [fallback]
                        : [start])
        ])];
}
/**
 * Fallback with locale chain
 *
 * @remarks
 * A fallback locale function implemented with a fallback chain algorithm. It's used in VueI18n as default.
 *
 * @param ctx - A {@link CoreContext | context}
 * @param fallback - A {@link FallbackLocale | fallback locale}
 * @param start - A starting {@link Locale | locale}
 *
 * @returns Fallback locales
 *
 * @VueI18nSee [Fallbacking](../guide/essentials/fallback)
 *
 * @VueI18nGeneral
 */
function fallbackWithLocaleChain(ctx, fallback, start) {
    const startLocale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(start) ? start : DEFAULT_LOCALE;
    const context = ctx;
    if (!context.__localeChainCache) {
        context.__localeChainCache = new Map();
    }
    let chain = context.__localeChainCache.get(startLocale);
    if (!chain) {
        chain = [];
        // first block defined by start
        let block = [start];
        // while any intervening block found
        while ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(block)) {
            block = appendBlockToChain(chain, block, fallback);
        }
        // prettier-ignore
        // last block defined by default
        const defaults = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(fallback) || !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(fallback)
            ? fallback
            : fallback['default']
                ? fallback['default']
                : null;
        // convert defaults to array
        block = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(defaults) ? [defaults] : defaults;
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(block)) {
            appendBlockToChain(chain, block, false);
        }
        context.__localeChainCache.set(startLocale, chain);
    }
    return chain;
}
function appendBlockToChain(chain, block, blocks) {
    let follow = true;
    for (let i = 0; i < block.length && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(follow); i++) {
        const locale = block[i];
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(locale)) {
            follow = appendLocaleToChain(chain, block[i], blocks);
        }
    }
    return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
    let follow;
    const tokens = locale.split('-');
    do {
        const target = tokens.join('-');
        follow = appendItemToChain(chain, target, blocks);
        tokens.splice(-1, 1);
    } while (tokens.length && follow === true);
    return follow;
}
function appendItemToChain(chain, target, blocks) {
    let follow = false;
    if (!chain.includes(target)) {
        follow = true;
        if (target) {
            follow = target[target.length - 1] !== '!';
            const locale = target.replace(/!/g, '');
            chain.push(locale);
            if (((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(blocks) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(blocks)) &&
                blocks[locale] // eslint-disable-line @typescript-eslint/no-explicit-any
            ) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                follow = blocks[locale];
            }
        }
    }
    return follow;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Intlify core-base version
 * @internal
 */
const VERSION = '9.2.2';
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = 'en-US';
const MISSING_RESOLVE_VALUE = '';
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
    return {
        upper: (val, type) => {
            // prettier-ignore
            return type === 'text' && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val)
                ? val.toUpperCase()
                : type === 'vnode' && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && '__v_isVNode' in val
                    ? val.children.toUpperCase()
                    : val;
        },
        lower: (val, type) => {
            // prettier-ignore
            return type === 'text' && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val)
                ? val.toLowerCase()
                : type === 'vnode' && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && '__v_isVNode' in val
                    ? val.children.toLowerCase()
                    : val;
        },
        capitalize: (val, type) => {
            // prettier-ignore
            return (type === 'text' && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val)
                ? capitalize(val)
                : type === 'vnode' && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(val) && '__v_isVNode' in val
                    ? capitalize(val.children)
                    : val);
        }
    };
}
let _compiler;
function registerMessageCompiler(compiler) {
    _compiler = compiler;
}
let _resolver;
/**
 * Register the message resolver
 *
 * @param resolver - A {@link MessageResolver} function
 *
 * @VueI18nGeneral
 */
function registerMessageResolver(resolver) {
    _resolver = resolver;
}
let _fallbacker;
/**
 * Register the locale fallbacker
 *
 * @param fallbacker - A {@link LocaleFallbacker} function
 *
 * @VueI18nGeneral
 */
function registerLocaleFallbacker(fallbacker) {
    _fallbacker = fallbacker;
}
// Additional Meta for Intlify DevTools
let _additionalMeta = null;
const setAdditionalMeta =  (meta) => {
    _additionalMeta = meta;
};
const getAdditionalMeta =  () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
    _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
// ID for CoreContext
let _cid = 0;
function createCoreContext(options = {}) {
    // setup options
    const version = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.version) ? options.version : VERSION;
    const locale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.locale) ? options.locale : DEFAULT_LOCALE;
    const fallbackLocale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(options.fallbackLocale) ||
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.fallbackLocale) ||
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.fallbackLocale) ||
        options.fallbackLocale === false
        ? options.fallbackLocale
        : locale;
    const messages = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.messages)
        ? options.messages
        : { [locale]: {} };
    const datetimeFormats = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.datetimeFormats)
            ? options.datetimeFormats
            : { [locale]: {} }
        ;
    const numberFormats = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.numberFormats)
            ? options.numberFormats
            : { [locale]: {} }
        ;
    const modifiers = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, options.modifiers || {}, getDefaultLinkedModifiers());
    const pluralRules = options.pluralRules || {};
    const missing = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.missing) ? options.missing : null;
    const missingWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.missingWarn) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(options.missingWarn)
        ? options.missingWarn
        : true;
    const fallbackWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackWarn) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isRegExp)(options.fallbackWarn)
        ? options.fallbackWarn
        : true;
    const fallbackFormat = !!options.fallbackFormat;
    const unresolving = !!options.unresolving;
    const postTranslation = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.postTranslation)
        ? options.postTranslation
        : null;
    const processor = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(options.processor) ? options.processor : null;
    const warnHtmlMessage = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.warnHtmlMessage)
        ? options.warnHtmlMessage
        : true;
    const escapeParameter = !!options.escapeParameter;
    const messageCompiler = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.messageCompiler)
        ? options.messageCompiler
        : _compiler;
    const messageResolver = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.messageResolver)
        ? options.messageResolver
        : _resolver || resolveWithKeyValue;
    const localeFallbacker = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.localeFallbacker)
        ? options.localeFallbacker
        : _fallbacker || fallbackWithSimple;
    const fallbackContext = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.fallbackContext)
        ? options.fallbackContext
        : undefined;
    const onWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.onWarn) ? options.onWarn : _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn;
    // setup internal options
    const internalOptions = options;
    const __datetimeFormatters = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(internalOptions.__datetimeFormatters)
            ? internalOptions.__datetimeFormatters
            : new Map()
        ;
    const __numberFormatters = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(internalOptions.__numberFormatters)
            ? internalOptions.__numberFormatters
            : new Map()
        ;
    const __meta = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(internalOptions.__meta) ? internalOptions.__meta : {};
    _cid++;
    const context = {
        version,
        cid: _cid,
        locale,
        fallbackLocale,
        messages,
        modifiers,
        pluralRules,
        missing,
        missingWarn,
        fallbackWarn,
        fallbackFormat,
        unresolving,
        postTranslation,
        processor,
        warnHtmlMessage,
        escapeParameter,
        messageCompiler,
        messageResolver,
        localeFallbacker,
        fallbackContext,
        onWarn,
        __meta
    };
    {
        context.datetimeFormats = datetimeFormats;
        context.numberFormats = numberFormats;
        context.__datetimeFormatters = __datetimeFormatters;
        context.__numberFormatters = __numberFormatters;
    }
    // for vue-devtools timeline event
    if ((true)) {
        context.__v_emitter =
            internalOptions.__v_emitter != null
                ? internalOptions.__v_emitter
                : undefined;
    }
    // NOTE: experimental !!
    if (true) {
        initI18nDevTools(context, version, __meta);
    }
    return context;
}
/** @internal */
function isTranslateFallbackWarn(fallback, key) {
    return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
/** @internal */
function isTranslateMissingWarn(missing, key) {
    return missing instanceof RegExp ? missing.test(key) : missing;
}
/** @internal */
function handleMissing(context, key, locale, missingWarn, type) {
    const { missing, onWarn } = context;
    // for vue-devtools timeline event
    if ((true)) {
        const emitter = context.__v_emitter;
        if (emitter) {
            emitter.emit("missing" /* MISSING */, {
                locale,
                key,
                type,
                groupId: `${type}:${key}`
            });
        }
    }
    if (missing !== null) {
        const ret = missing(context, locale, key, type);
        return (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(ret) ? ret : key;
    }
    else {
        if (( true) && isTranslateMissingWarn(missingWarn, key)) {
            onWarn(getWarnMessage(CoreWarnCodes.NOT_FOUND_KEY, { key, locale }));
        }
        return key;
    }
}
/** @internal */
function updateFallbackLocale(ctx, locale, fallback) {
    const context = ctx;
    context.__localeChainCache = new Map();
    ctx.localeFallbacker(ctx, fallback, locale);
}
/* eslint-enable @typescript-eslint/no-explicit-any */

const RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
const WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
function checkHtmlMessage(source, options) {
    const warnHtmlMessage = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.warnHtmlMessage)
        ? options.warnHtmlMessage
        : true;
    if (warnHtmlMessage && RE_HTML_TAG.test(source)) {
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn)((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.format)(WARN_MESSAGE, { source }));
    }
}
const defaultOnCacheKey = (source) => source;
let compileCache = Object.create(null);
function clearCompileCache() {
    compileCache = Object.create(null);
}
function compileToFunction(source, options = {}) {
    {
        // check HTML message
        ( true) && checkHtmlMessage(source, options);
        // check caches
        const onCacheKey = options.onCacheKey || defaultOnCacheKey;
        const key = onCacheKey(source);
        const cached = compileCache[key];
        if (cached) {
            return cached;
        }
        // compile error detecting
        let occurred = false;
        const onError = options.onError || _intlify_message_compiler__WEBPACK_IMPORTED_MODULE_0__.defaultOnError;
        options.onError = (err) => {
            occurred = true;
            onError(err);
        };
        // compile
        const { code } = (0,_intlify_message_compiler__WEBPACK_IMPORTED_MODULE_0__.baseCompile)(source, options);
        // evaluate function
        const msg = new Function(`return ${code}`)();
        // if occurred compile error, don't cache
        return !occurred ? (compileCache[key] = msg) : msg;
    }
}

let code = _intlify_message_compiler__WEBPACK_IMPORTED_MODULE_0__.CompileErrorCodes.__EXTEND_POINT__;
const inc = () => ++code;
const CoreErrorCodes = {
    INVALID_ARGUMENT: code,
    INVALID_DATE_ARGUMENT: inc(),
    INVALID_ISO_DATE_ARGUMENT: inc(),
    __EXTEND_POINT__: inc() // 18
};
function createCoreError(code) {
    return (0,_intlify_message_compiler__WEBPACK_IMPORTED_MODULE_0__.createCompileError)(code, null, ( true) ? { messages: errorMessages } : 0);
}
/** @internal */
const errorMessages = {
    [CoreErrorCodes.INVALID_ARGUMENT]: 'Invalid arguments',
    [CoreErrorCodes.INVALID_DATE_ARGUMENT]: 'The date provided is an invalid Date object.' +
        'Make sure your Date represents a valid date.',
    [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: 'The argument provided is not a valid ISO date string'
};

const NOOP_MESSAGE_FUNCTION = () => '';
const isMessageFunction = (val) => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(val);
// implementation of `translate` function
function translate(context, ...args) {
    const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
    const [key, options] = parseTranslateArgs(...args);
    const missingWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.missingWarn)
        ? options.missingWarn
        : context.missingWarn;
    const fallbackWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackWarn)
        ? options.fallbackWarn
        : context.fallbackWarn;
    const escapeParameter = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.escapeParameter)
        ? options.escapeParameter
        : context.escapeParameter;
    const resolvedMessage = !!options.resolvedMessage;
    // prettier-ignore
    const defaultMsgOrKey = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.default) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.default) // default by function option
        ? !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.default)
            ? options.default
            : (!messageCompiler ? () => key : key)
        : fallbackFormat // default by `fallbackFormat` option
            ? (!messageCompiler ? () => key : key)
            : '';
    const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== '';
    const locale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.locale) ? options.locale : context.locale;
    // escape params
    escapeParameter && escapeParams(options);
    // resolve message format
    // eslint-disable-next-line prefer-const
    let [formatScope, targetLocale, message] = !resolvedMessage
        ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn)
        : [
            key,
            locale,
            messages[locale] || {}
        ];
    // NOTE:
    //  Fix to work around `ssrTransfrom` bug in Vite.
    //  https://github.com/vitejs/vite/issues/4306
    //  To get around this, use temporary variables.
    //  https://github.com/nuxt/framework/issues/1461#issuecomment-954606243
    let format = formatScope;
    // if you use default message, set it as message format!
    let cacheBaseKey = key;
    if (!resolvedMessage &&
        !((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(format) || isMessageFunction(format))) {
        if (enableDefaultMsg) {
            format = defaultMsgOrKey;
            cacheBaseKey = format;
        }
    }
    // checking message format and target locale
    if (!resolvedMessage &&
        (!((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(format) || isMessageFunction(format)) ||
            !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetLocale))) {
        return unresolving ? NOT_REOSLVED : key;
    }
    if (( true) && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(format) && context.messageCompiler == null) {
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.warn)(`The message format compilation is not supported in this build. ` +
            `Because message compiler isn't included. ` +
            `You need to pre-compilation all message format. ` +
            `So translate function return '${key}'.`);
        return key;
    }
    // setup compile error detecting
    let occurred = false;
    const errorDetector = () => {
        occurred = true;
    };
    // compile message format
    const msg = !isMessageFunction(format)
        ? compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector)
        : format;
    // if occurred compile error, return the message format
    if (occurred) {
        return format;
    }
    // evaluate message with context
    const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
    const msgContext = createMessageContext(ctxOptions);
    const messaged = evaluateMessage(context, msg, msgContext);
    // if use post translation option, proceed it with handler
    const ret = postTranslation
        ? postTranslation(messaged, key)
        : messaged;
    // NOTE: experimental !!
    if (true) {
        // prettier-ignore
        const payloads = {
            timestamp: Date.now(),
            key: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key)
                ? key
                : isMessageFunction(format)
                    ? format.key
                    : '',
            locale: targetLocale || (isMessageFunction(format)
                ? format.locale
                : ''),
            format: (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(format)
                ? format
                : isMessageFunction(format)
                    ? format.source
                    : '',
            message: ret
        };
        payloads.meta = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, context.__meta, getAdditionalMeta() || {});
        translateDevTools(payloads);
    }
    return ret;
}
function escapeParams(options) {
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(options.list)) {
        options.list = options.list.map(item => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(item) ? (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.escapeHtml)(item) : item);
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isObject)(options.named)) {
        Object.keys(options.named).forEach(key => {
            if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.named[key])) {
                options.named[key] = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.escapeHtml)(options.named[key]);
            }
        });
    }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
    const { messages, onWarn, messageResolver: resolveValue, localeFallbacker } = context;
    const locales = localeFallbacker(context, fallbackLocale, locale); // eslint-disable-line @typescript-eslint/no-explicit-any
    let message = {};
    let targetLocale;
    let format = null;
    let from = locale;
    let to = null;
    const type = 'translate';
    for (let i = 0; i < locales.length; i++) {
        targetLocale = to = locales[i];
        if (( true) &&
            locale !== targetLocale &&
            isTranslateFallbackWarn(fallbackWarn, key)) {
            onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
                key,
                target: targetLocale
            }));
        }
        // for vue-devtools timeline event
        if (( true) && locale !== targetLocale) {
            const emitter = context.__v_emitter;
            if (emitter) {
                emitter.emit("fallback" /* FALBACK */, {
                    type,
                    key,
                    from,
                    to,
                    groupId: `${type}:${key}`
                });
            }
        }
        message =
            messages[targetLocale] || {};
        // for vue-devtools timeline event
        let start = null;
        let startTag;
        let endTag;
        if (( true) && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
            start = window.performance.now();
            startTag = 'intlify-message-resolve-start';
            endTag = 'intlify-message-resolve-end';
            _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark)(startTag);
        }
        if ((format = resolveValue(message, key)) === null) {
            // if null, resolve with object key path
            format = message[key]; // eslint-disable-line @typescript-eslint/no-explicit-any
        }
        // for vue-devtools timeline event
        if (( true) && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
            const end = window.performance.now();
            const emitter = context.__v_emitter;
            if (emitter && start && format) {
                emitter.emit("message-resolve" /* MESSAGE_RESOLVE */, {
                    type: "message-resolve" /* MESSAGE_RESOLVE */,
                    key,
                    message: format,
                    time: end - start,
                    groupId: `${type}:${key}`
                });
            }
            if (startTag && endTag && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.measure) {
                (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark)(endTag);
                (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.measure)('intlify message resolve', startTag, endTag);
            }
        }
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(format) || (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isFunction)(format))
            break;
        const missingRet = handleMissing(context, // eslint-disable-line @typescript-eslint/no-explicit-any
        key, targetLocale, missingWarn, type);
        if (missingRet !== key) {
            format = missingRet;
        }
        from = to;
    }
    return [format, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) {
    const { messageCompiler, warnHtmlMessage } = context;
    if (isMessageFunction(format)) {
        const msg = format;
        msg.locale = msg.locale || targetLocale;
        msg.key = msg.key || key;
        return msg;
    }
    if (messageCompiler == null) {
        const msg = (() => format);
        msg.locale = targetLocale;
        msg.key = key;
        return msg;
    }
    // for vue-devtools timeline event
    let start = null;
    let startTag;
    let endTag;
    if (( true) && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
        start = window.performance.now();
        startTag = 'intlify-message-compilation-start';
        endTag = 'intlify-message-compilation-end';
        _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark)(startTag);
    }
    const msg = messageCompiler(format, getCompileOptions(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, errorDetector));
    // for vue-devtools timeline event
    if (( true) && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
        const end = window.performance.now();
        const emitter = context.__v_emitter;
        if (emitter && start) {
            emitter.emit("message-compilation" /* MESSAGE_COMPILATION */, {
                type: "message-compilation" /* MESSAGE_COMPILATION */,
                message: format,
                time: end - start,
                groupId: `${'translate'}:${key}`
            });
        }
        if (startTag && endTag && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.measure) {
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark)(endTag);
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.measure)('intlify message compilation', startTag, endTag);
        }
    }
    msg.locale = targetLocale;
    msg.key = key;
    msg.source = format;
    return msg;
}
function evaluateMessage(context, msg, msgCtx) {
    // for vue-devtools timeline event
    let start = null;
    let startTag;
    let endTag;
    if (( true) && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
        start = window.performance.now();
        startTag = 'intlify-message-evaluation-start';
        endTag = 'intlify-message-evaluation-end';
        _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark && (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark)(startTag);
    }
    const messaged = msg(msgCtx);
    // for vue-devtools timeline event
    if (( true) && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.inBrowser) {
        const end = window.performance.now();
        const emitter = context.__v_emitter;
        if (emitter && start) {
            emitter.emit("message-evaluation" /* MESSAGE_EVALUATION */, {
                type: "message-evaluation" /* MESSAGE_EVALUATION */,
                value: messaged,
                time: end - start,
                groupId: `${'translate'}:${msg.key}`
            });
        }
        if (startTag && endTag && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark && _intlify_shared__WEBPACK_IMPORTED_MODULE_1__.measure) {
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.mark)(endTag);
            (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.measure)('intlify message evaluation', startTag, endTag);
        }
    }
    return messaged;
}
/** @internal */
function parseTranslateArgs(...args) {
    const [arg1, arg2, arg3] = args;
    const options = {};
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg1) && !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(arg1) && !isMessageFunction(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    // prettier-ignore
    const key = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(arg1)
        ? String(arg1)
        : isMessageFunction(arg1)
            ? arg1
            : arg1;
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(arg2)) {
        options.plural = arg2;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg2)) {
        options.default = arg2;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg2) && !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isEmptyObject)(arg2)) {
        options.named = arg2;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isArray)(arg2)) {
        options.list = arg2;
    }
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(arg3)) {
        options.plural = arg3;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg3)) {
        options.default = arg3;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg3)) {
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)(options, arg3);
    }
    return [key, options];
}
function getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {
    return {
        warnHtmlMessage,
        onError: (err) => {
            errorDetector && errorDetector(err);
            if ((true)) {
                const message = `Message compilation error: ${err.message}`;
                const codeFrame = err.location &&
                    (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.generateCodeFrame)(source, err.location.start.offset, err.location.end.offset);
                const emitter = context.__v_emitter;
                if (emitter) {
                    emitter.emit("compile-error" /* COMPILE_ERROR */, {
                        message: source,
                        error: err.message,
                        start: err.location && err.location.start.offset,
                        end: err.location && err.location.end.offset,
                        groupId: `${'translate'}:${key}`
                    });
                }
                console.error(codeFrame ? `${message}\n${codeFrame}` : message);
            }
            else {}
        },
        onCacheKey: (source) => (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.generateFormatCacheKey)(locale, key, source)
    };
}
function getMessageContextOptions(context, locale, message, options) {
    const { modifiers, pluralRules, messageResolver: resolveValue, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
    const resolveMessage = (key) => {
        let val = resolveValue(message, key);
        // fallback to root context
        if (val == null && fallbackContext) {
            const [, , message] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
            val = resolveValue(message, key);
        }
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(val)) {
            let occurred = false;
            const errorDetector = () => {
                occurred = true;
            };
            const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);
            return !occurred
                ? msg
                : NOOP_MESSAGE_FUNCTION;
        }
        else if (isMessageFunction(val)) {
            return val;
        }
        else {
            // TODO: should be implemented warning message
            return NOOP_MESSAGE_FUNCTION;
        }
    };
    const ctxOptions = {
        locale,
        modifiers,
        pluralRules,
        messages: resolveMessage
    };
    if (context.processor) {
        ctxOptions.processor = context.processor;
    }
    if (options.list) {
        ctxOptions.list = options.list;
    }
    if (options.named) {
        ctxOptions.named = options.named;
    }
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(options.plural)) {
        ctxOptions.pluralIndex = options.plural;
    }
    return ctxOptions;
}

const intlDefined = typeof Intl !== 'undefined';
const Availabilities = {
    dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',
    numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'
};

// implementation of `datetime` function
function datetime(context, ...args) {
    const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __datetimeFormatters } = context;
    if (( true) && !Availabilities.dateTimeFormat) {
        onWarn(getWarnMessage(CoreWarnCodes.CANNOT_FORMAT_DATE));
        return MISSING_RESOLVE_VALUE;
    }
    const [key, value, options, overrides] = parseDateTimeArgs(...args);
    const missingWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.missingWarn)
        ? options.missingWarn
        : context.missingWarn;
    const fallbackWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackWarn)
        ? options.fallbackWarn
        : context.fallbackWarn;
    const part = !!options.part;
    const locale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.locale) ? options.locale : context.locale;
    const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale, locale);
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || key === '') {
        return new Intl.DateTimeFormat(locale, overrides).format(value);
    }
    // resolve format
    let datetimeFormat = {};
    let targetLocale;
    let format = null;
    let from = locale;
    let to = null;
    const type = 'datetime format';
    for (let i = 0; i < locales.length; i++) {
        targetLocale = to = locales[i];
        if (( true) &&
            locale !== targetLocale &&
            isTranslateFallbackWarn(fallbackWarn, key)) {
            onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
                key,
                target: targetLocale
            }));
        }
        // for vue-devtools timeline event
        if (( true) && locale !== targetLocale) {
            const emitter = context.__v_emitter;
            if (emitter) {
                emitter.emit("fallback" /* FALBACK */, {
                    type,
                    key,
                    from,
                    to,
                    groupId: `${type}:${key}`
                });
            }
        }
        datetimeFormat =
            datetimeFormats[targetLocale] || {};
        format = datetimeFormat[key];
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(format))
            break;
        handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any
        from = to;
    }
    // checking format and target locale
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(format) || !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isEmptyObject)(overrides)) {
        id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __datetimeFormatters.get(id);
    if (!formatter) {
        formatter = new Intl.DateTimeFormat(targetLocale, (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, format, overrides));
        __datetimeFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
}
/** @internal */
const DATETIME_FORMAT_OPTIONS_KEYS = [
    'localeMatcher',
    'weekday',
    'era',
    'year',
    'month',
    'day',
    'hour',
    'minute',
    'second',
    'timeZoneName',
    'formatMatcher',
    'hour12',
    'timeZone',
    'dateStyle',
    'timeStyle',
    'calendar',
    'dayPeriod',
    'numberingSystem',
    'hourCycle',
    'fractionalSecondDigits'
];
/** @internal */
function parseDateTimeArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    let value;
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg1)) {
        // Only allow ISO strings - other date formats are often supported,
        // but may cause different results in different browsers.
        const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!matches) {
            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
        // Some browsers can not parse the iso datetime separated by space,
        // this is a compromise solution by replace the 'T'/' ' with 'T'
        const dateTime = matches[3]
            ? matches[3].trim().startsWith('T')
                ? `${matches[1].trim()}${matches[3].trim()}`
                : `${matches[1].trim()}T${matches[3].trim()}`
            : matches[1].trim();
        value = new Date(dateTime);
        try {
            // This will fail if the date is not valid
            value.toISOString();
        }
        catch (e) {
            throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isDate)(arg1)) {
        if (isNaN(arg1.getTime())) {
            throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
        }
        value = arg1;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(arg1)) {
        value = arg1;
    }
    else {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg2)) {
        options.key = arg2;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg2)) {
        Object.keys(arg2).forEach(key => {
            if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
                overrides[key] = arg2[key];
            }
            else {
                options[key] = arg2[key];
            }
        });
    }
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg3)) {
        options.locale = arg3;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg3)) {
        overrides = arg3;
    }
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg4)) {
        overrides = arg4;
    }
    return [options.key || '', value, options, overrides];
}
/** @internal */
function clearDateTimeFormat(ctx, locale, format) {
    const context = ctx;
    for (const key in format) {
        const id = `${locale}__${key}`;
        if (!context.__datetimeFormatters.has(id)) {
            continue;
        }
        context.__datetimeFormatters.delete(id);
    }
}

// implementation of `number` function
function number(context, ...args) {
    const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
    const { __numberFormatters } = context;
    if (( true) && !Availabilities.numberFormat) {
        onWarn(getWarnMessage(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
        return MISSING_RESOLVE_VALUE;
    }
    const [key, value, options, overrides] = parseNumberArgs(...args);
    const missingWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.missingWarn)
        ? options.missingWarn
        : context.missingWarn;
    const fallbackWarn = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(options.fallbackWarn)
        ? options.fallbackWarn
        : context.fallbackWarn;
    const part = !!options.part;
    const locale = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(options.locale) ? options.locale : context.locale;
    const locales = localeFallbacker(context, // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale, locale);
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(key) || key === '') {
        return new Intl.NumberFormat(locale, overrides).format(value);
    }
    // resolve format
    let numberFormat = {};
    let targetLocale;
    let format = null;
    let from = locale;
    let to = null;
    const type = 'number format';
    for (let i = 0; i < locales.length; i++) {
        targetLocale = to = locales[i];
        if (( true) &&
            locale !== targetLocale &&
            isTranslateFallbackWarn(fallbackWarn, key)) {
            onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
                key,
                target: targetLocale
            }));
        }
        // for vue-devtools timeline event
        if (( true) && locale !== targetLocale) {
            const emitter = context.__v_emitter;
            if (emitter) {
                emitter.emit("fallback" /* FALBACK */, {
                    type,
                    key,
                    from,
                    to,
                    groupId: `${type}:${key}`
                });
            }
        }
        numberFormat =
            numberFormats[targetLocale] || {};
        format = numberFormat[key];
        if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(format))
            break;
        handleMissing(context, key, targetLocale, missingWarn, type); // eslint-disable-line @typescript-eslint/no-explicit-any
        from = to;
    }
    // checking format and target locale
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(format) || !(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key;
    }
    let id = `${targetLocale}__${key}`;
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isEmptyObject)(overrides)) {
        id = `${id}__${JSON.stringify(overrides)}`;
    }
    let formatter = __numberFormatters.get(id);
    if (!formatter) {
        formatter = new Intl.NumberFormat(targetLocale, (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.assign)({}, format, overrides));
        __numberFormatters.set(id, formatter);
    }
    return !part ? formatter.format(value) : formatter.formatToParts(value);
}
/** @internal */
const NUMBER_FORMAT_OPTIONS_KEYS = [
    'localeMatcher',
    'style',
    'currency',
    'currencyDisplay',
    'currencySign',
    'useGrouping',
    'minimumIntegerDigits',
    'minimumFractionDigits',
    'maximumFractionDigits',
    'minimumSignificantDigits',
    'maximumSignificantDigits',
    'compactDisplay',
    'notation',
    'signDisplay',
    'unit',
    'unitDisplay',
    'roundingMode',
    'roundingPriority',
    'roundingIncrement',
    'trailingZeroDisplay'
];
/** @internal */
function parseNumberArgs(...args) {
    const [arg1, arg2, arg3, arg4] = args;
    const options = {};
    let overrides = {};
    if (!(0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isNumber)(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
    }
    const value = arg1;
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg2)) {
        options.key = arg2;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg2)) {
        Object.keys(arg2).forEach(key => {
            if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
                overrides[key] = arg2[key];
            }
            else {
                options[key] = arg2[key];
            }
        });
    }
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isString)(arg3)) {
        options.locale = arg3;
    }
    else if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg3)) {
        overrides = arg3;
    }
    if ((0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(arg4)) {
        overrides = arg4;
    }
    return [options.key || '', value, options, overrides];
}
/** @internal */
function clearNumberFormat(ctx, locale, format) {
    const context = ctx;
    for (const key in format) {
        const id = `${locale}__${key}`;
        if (!context.__numberFormatters.has(id)) {
            continue;
        }
        context.__numberFormatters.delete(id);
    }
}

// TODO: we could not exports for Node native ES Moudles yet...
{
    if (typeof __INTLIFY_PROD_DEVTOOLS__ !== 'boolean') {
        (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_1__.getGlobalThis)().__INTLIFY_PROD_DEVTOOLS__ = false;
    }
}




/***/ }),
/* 25 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CompileErrorCodes": function() { return /* binding */ CompileErrorCodes; },
/* harmony export */   "ERROR_DOMAIN": function() { return /* binding */ ERROR_DOMAIN; },
/* harmony export */   "LocationStub": function() { return /* binding */ LocationStub; },
/* harmony export */   "baseCompile": function() { return /* binding */ baseCompile; },
/* harmony export */   "createCompileError": function() { return /* binding */ createCompileError; },
/* harmony export */   "createLocation": function() { return /* binding */ createLocation; },
/* harmony export */   "createParser": function() { return /* binding */ createParser; },
/* harmony export */   "createPosition": function() { return /* binding */ createPosition; },
/* harmony export */   "defaultOnError": function() { return /* binding */ defaultOnError; },
/* harmony export */   "errorMessages": function() { return /* binding */ errorMessages; }
/* harmony export */ });
/* harmony import */ var _intlify_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/*!
  * message-compiler v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */


const CompileErrorCodes = {
    // tokenizer error codes
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    // parser error codes
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    // Special value for higher-order compilers to pick up the last code
    // to avoid collision of error codes. This should always be kept as the last
    // item.
    __EXTEND_POINT__: 15
};
/** @internal */
const errorMessages = {
    // tokenizer error messages
    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
    // parser error messages
    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`
};
function createCompileError(code, loc, options = {}) {
    const { domain, messages, args } = options;
    const msg = ( true)
        ? (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_0__.format)((messages || errorMessages)[code] || '', ...(args || []))
        : 0;
    const error = new SyntaxError(String(msg));
    error.code = code;
    if (loc) {
        error.location = loc;
    }
    error.domain = domain;
    return error;
}
/** @internal */
function defaultOnError(error) {
    throw error;
}

const LocationStub = {
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createPosition(line, column, offset) {
    return { line, column, offset };
}
function createLocation(start, end, source) {
    const loc = { start, end };
    if (source != null) {
        loc.source = source;
    }
    return loc;
}

const CHAR_SP = ' ';
const CHAR_CR = '\r';
const CHAR_LF = '\n';
const CHAR_LS = String.fromCharCode(0x2028);
const CHAR_PS = String.fromCharCode(0x2029);
function createScanner(str) {
    const _buf = str;
    let _index = 0;
    let _line = 1;
    let _column = 1;
    let _peekOffset = 0;
    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;
    const isLF = (index) => _buf[index] === CHAR_LF;
    const isPS = (index) => _buf[index] === CHAR_PS;
    const isLS = (index) => _buf[index] === CHAR_LS;
    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);
    const index = () => _index;
    const line = () => _line;
    const column = () => _column;
    const peekOffset = () => _peekOffset;
    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
    const currentChar = () => charAt(_index);
    const currentPeek = () => charAt(_index + _peekOffset);
    function next() {
        _peekOffset = 0;
        if (isLineEnd(_index)) {
            _line++;
            _column = 0;
        }
        if (isCRLF(_index)) {
            _index++;
        }
        _index++;
        _column++;
        return _buf[_index];
    }
    function peek() {
        if (isCRLF(_index + _peekOffset)) {
            _peekOffset++;
        }
        _peekOffset++;
        return _buf[_index + _peekOffset];
    }
    function reset() {
        _index = 0;
        _line = 1;
        _column = 1;
        _peekOffset = 0;
    }
    function resetPeek(offset = 0) {
        _peekOffset = offset;
    }
    function skipToPeek() {
        const target = _index + _peekOffset;
        // eslint-disable-next-line no-unmodified-loop-condition
        while (target !== _index) {
            next();
        }
        _peekOffset = 0;
    }
    return {
        index,
        line,
        column,
        peekOffset,
        charAt,
        currentChar,
        currentPeek,
        next,
        peek,
        reset,
        resetPeek,
        skipToPeek
    };
}

const EOF = undefined;
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$1 = 'tokenizer';
function createTokenizer(source, options = {}) {
    const location = options.location !== false;
    const _scnr = createScanner(source);
    const currentOffset = () => _scnr.index();
    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
    const _initLoc = currentPosition();
    const _initOffset = currentOffset();
    const _context = {
        currentType: 14 /* EOF */,
        offset: _initOffset,
        startLoc: _initLoc,
        endLoc: _initLoc,
        lastType: 14 /* EOF */,
        lastOffset: _initOffset,
        lastStartLoc: _initLoc,
        lastEndLoc: _initLoc,
        braceNest: 0,
        inLinked: false,
        text: ''
    };
    const context = () => _context;
    const { onError } = options;
    function emitError(code, pos, offset, ...args) {
        const ctx = context();
        pos.column += offset;
        pos.offset += offset;
        if (onError) {
            const loc = createLocation(ctx.startLoc, pos);
            const err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN$1,
                args
            });
            onError(err);
        }
    }
    function getToken(context, type, value) {
        context.endLoc = currentPosition();
        context.currentType = type;
        const token = { type };
        if (location) {
            token.loc = createLocation(context.startLoc, context.endLoc);
        }
        if (value != null) {
            token.value = value;
        }
        return token;
    }
    const getEndToken = (context) => getToken(context, 14 /* EOF */);
    function eat(scnr, ch) {
        if (scnr.currentChar() === ch) {
            scnr.next();
            return ch;
        }
        else {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
            return '';
        }
    }
    function peekSpaces(scnr) {
        let buf = '';
        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
            buf += scnr.currentPeek();
            scnr.peek();
        }
        return buf;
    }
    function skipSpaces(scnr) {
        const buf = peekSpaces(scnr);
        scnr.skipToPeek();
        return buf;
    }
    function isIdentifierStart(ch) {
        if (ch === EOF) {
            return false;
        }
        const cc = ch.charCodeAt(0);
        return ((cc >= 97 && cc <= 122) || // a-z
            (cc >= 65 && cc <= 90) || // A-Z
            cc === 95 // _
        );
    }
    function isNumberStart(ch) {
        if (ch === EOF) {
            return false;
        }
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57; // 0-9
    }
    function isNamedIdentifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isListIdentifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();
        const ret = isNumberStart(ch);
        scnr.resetPeek();
        return ret;
    }
    function isLiteralStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 2 /* BraceLeft */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === LITERAL_DELIMITER;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDotStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 8 /* LinkedAlias */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "." /* LinkedDot */;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedModifierStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 9 /* LinkedDot */) {
            return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
    }
    function isLinkedDelimiterStart(scnr, context) {
        const { currentType } = context;
        if (!(currentType === 8 /* LinkedAlias */ ||
            currentType === 12 /* LinkedModifier */)) {
            return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ":" /* LinkedDelimiter */;
        scnr.resetPeek();
        return ret;
    }
    function isLinkedReferStart(scnr, context) {
        const { currentType } = context;
        if (currentType !== 10 /* LinkedDelimiter */) {
            return false;
        }
        const fn = () => {
            const ch = scnr.currentPeek();
            if (ch === "{" /* BraceLeft */) {
                return isIdentifierStart(scnr.peek());
            }
            else if (ch === "@" /* LinkedAlias */ ||
                ch === "%" /* Modulo */ ||
                ch === "|" /* Pipe */ ||
                ch === ":" /* LinkedDelimiter */ ||
                ch === "." /* LinkedDot */ ||
                ch === CHAR_SP ||
                !ch) {
                return false;
            }
            else if (ch === CHAR_LF) {
                scnr.peek();
                return fn();
            }
            else {
                // other characters
                return isIdentifierStart(ch);
            }
        };
        const ret = fn();
        scnr.resetPeek();
        return ret;
    }
    function isPluralStart(scnr) {
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "|" /* Pipe */;
        scnr.resetPeek();
        return ret;
    }
    function detectModuloStart(scnr) {
        const spaces = peekSpaces(scnr);
        const ret = scnr.currentPeek() === "%" /* Modulo */ &&
            scnr.peek() === "{" /* BraceLeft */;
        scnr.resetPeek();
        return {
            isModulo: ret,
            hasSpace: spaces.length > 0
        };
    }
    function isTextStart(scnr, reset = true) {
        const fn = (hasSpace = false, prev = '', detectModulo = false) => {
            const ch = scnr.currentPeek();
            if (ch === "{" /* BraceLeft */) {
                return prev === "%" /* Modulo */ ? false : hasSpace;
            }
            else if (ch === "@" /* LinkedAlias */ || !ch) {
                return prev === "%" /* Modulo */ ? true : hasSpace;
            }
            else if (ch === "%" /* Modulo */) {
                scnr.peek();
                return fn(hasSpace, "%" /* Modulo */, true);
            }
            else if (ch === "|" /* Pipe */) {
                return prev === "%" /* Modulo */ || detectModulo
                    ? true
                    : !(prev === CHAR_SP || prev === CHAR_LF);
            }
            else if (ch === CHAR_SP) {
                scnr.peek();
                return fn(true, CHAR_SP, detectModulo);
            }
            else if (ch === CHAR_LF) {
                scnr.peek();
                return fn(true, CHAR_LF, detectModulo);
            }
            else {
                return true;
            }
        };
        const ret = fn();
        reset && scnr.resetPeek();
        return ret;
    }
    function takeChar(scnr, fn) {
        const ch = scnr.currentChar();
        if (ch === EOF) {
            return EOF;
        }
        if (fn(ch)) {
            scnr.next();
            return ch;
        }
        return null;
    }
    function takeIdentifierChar(scnr) {
        const closure = (ch) => {
            const cc = ch.charCodeAt(0);
            return ((cc >= 97 && cc <= 122) || // a-z
                (cc >= 65 && cc <= 90) || // A-Z
                (cc >= 48 && cc <= 57) || // 0-9
                cc === 95 || // _
                cc === 36 // $
            );
        };
        return takeChar(scnr, closure);
    }
    function takeDigit(scnr) {
        const closure = (ch) => {
            const cc = ch.charCodeAt(0);
            return cc >= 48 && cc <= 57; // 0-9
        };
        return takeChar(scnr, closure);
    }
    function takeHexDigit(scnr) {
        const closure = (ch) => {
            const cc = ch.charCodeAt(0);
            return ((cc >= 48 && cc <= 57) || // 0-9
                (cc >= 65 && cc <= 70) || // A-F
                (cc >= 97 && cc <= 102)); // a-f
        };
        return takeChar(scnr, closure);
    }
    function getDigits(scnr) {
        let ch = '';
        let num = '';
        while ((ch = takeDigit(scnr))) {
            num += ch;
        }
        return num;
    }
    function readModulo(scnr) {
        skipSpaces(scnr);
        const ch = scnr.currentChar();
        if (ch !== "%" /* Modulo */) {
            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        }
        scnr.next();
        return "%" /* Modulo */;
    }
    function readText(scnr) {
        let buf = '';
        while (true) {
            const ch = scnr.currentChar();
            if (ch === "{" /* BraceLeft */ ||
                ch === "}" /* BraceRight */ ||
                ch === "@" /* LinkedAlias */ ||
                ch === "|" /* Pipe */ ||
                !ch) {
                break;
            }
            else if (ch === "%" /* Modulo */) {
                if (isTextStart(scnr)) {
                    buf += ch;
                    scnr.next();
                }
                else {
                    break;
                }
            }
            else if (ch === CHAR_SP || ch === CHAR_LF) {
                if (isTextStart(scnr)) {
                    buf += ch;
                    scnr.next();
                }
                else if (isPluralStart(scnr)) {
                    break;
                }
                else {
                    buf += ch;
                    scnr.next();
                }
            }
            else {
                buf += ch;
                scnr.next();
            }
        }
        return buf;
    }
    function readNamedIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = '';
        let name = '';
        while ((ch = takeIdentifierChar(scnr))) {
            name += ch;
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return name;
    }
    function readListIdentifier(scnr) {
        skipSpaces(scnr);
        let value = '';
        if (scnr.currentChar() === '-') {
            scnr.next();
            value += `-${getDigits(scnr)}`;
        }
        else {
            value += getDigits(scnr);
        }
        if (scnr.currentChar() === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return value;
    }
    function readLiteral(scnr) {
        skipSpaces(scnr);
        eat(scnr, `\'`);
        let ch = '';
        let literal = '';
        const fn = (x) => x !== LITERAL_DELIMITER && x !== CHAR_LF;
        while ((ch = takeChar(scnr, fn))) {
            if (ch === '\\') {
                literal += readEscapeSequence(scnr);
            }
            else {
                literal += ch;
            }
        }
        const current = scnr.currentChar();
        if (current === CHAR_LF || current === EOF) {
            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
            // TODO: Is it correct really?
            if (current === CHAR_LF) {
                scnr.next();
                eat(scnr, `\'`);
            }
            return literal;
        }
        eat(scnr, `\'`);
        return literal;
    }
    function readEscapeSequence(scnr) {
        const ch = scnr.currentChar();
        switch (ch) {
            case '\\':
            case `\'`:
                scnr.next();
                return `\\${ch}`;
            case 'u':
                return readUnicodeEscapeSequence(scnr, ch, 4);
            case 'U':
                return readUnicodeEscapeSequence(scnr, ch, 6);
            default:
                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
                return '';
        }
    }
    function readUnicodeEscapeSequence(scnr, unicode, digits) {
        eat(scnr, unicode);
        let sequence = '';
        for (let i = 0; i < digits; i++) {
            const ch = takeHexDigit(scnr);
            if (!ch) {
                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
                break;
            }
            sequence += ch;
        }
        return `\\${unicode}${sequence}`;
    }
    function readInvalidIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = '';
        let identifiers = '';
        const closure = (ch) => ch !== "{" /* BraceLeft */ &&
            ch !== "}" /* BraceRight */ &&
            ch !== CHAR_SP &&
            ch !== CHAR_LF;
        while ((ch = takeChar(scnr, closure))) {
            identifiers += ch;
        }
        return identifiers;
    }
    function readLinkedModifier(scnr) {
        let ch = '';
        let name = '';
        while ((ch = takeIdentifierChar(scnr))) {
            name += ch;
        }
        return name;
    }
    function readLinkedRefer(scnr) {
        const fn = (detect = false, buf) => {
            const ch = scnr.currentChar();
            if (ch === "{" /* BraceLeft */ ||
                ch === "%" /* Modulo */ ||
                ch === "@" /* LinkedAlias */ ||
                ch === "|" /* Pipe */ ||
                !ch) {
                return buf;
            }
            else if (ch === CHAR_SP) {
                return buf;
            }
            else if (ch === CHAR_LF) {
                buf += ch;
                scnr.next();
                return fn(detect, buf);
            }
            else {
                buf += ch;
                scnr.next();
                return fn(true, buf);
            }
        };
        return fn(false, '');
    }
    function readPlural(scnr) {
        skipSpaces(scnr);
        const plural = eat(scnr, "|" /* Pipe */);
        skipSpaces(scnr);
        return plural;
    }
    // TODO: We need refactoring of token parsing ...
    function readTokenInPlaceholder(scnr, context) {
        let token = null;
        const ch = scnr.currentChar();
        switch (ch) {
            case "{" /* BraceLeft */:
                if (context.braceNest >= 1) {
                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context, 2 /* BraceLeft */, "{" /* BraceLeft */);
                skipSpaces(scnr);
                context.braceNest++;
                return token;
            case "}" /* BraceRight */:
                if (context.braceNest > 0 &&
                    context.currentType === 2 /* BraceLeft */) {
                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
                }
                scnr.next();
                token = getToken(context, 3 /* BraceRight */, "}" /* BraceRight */);
                context.braceNest--;
                context.braceNest > 0 && skipSpaces(scnr);
                if (context.inLinked && context.braceNest === 0) {
                    context.inLinked = false;
                }
                return token;
            case "@" /* LinkedAlias */:
                if (context.braceNest > 0) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                }
                token = readTokenInLinked(scnr, context) || getEndToken(context);
                context.braceNest = 0;
                return token;
            default:
                let validNamedIdentifier = true;
                let validListIdentifier = true;
                let validLiteral = true;
                if (isPluralStart(scnr)) {
                    if (context.braceNest > 0) {
                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    }
                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                if (context.braceNest > 0 &&
                    (context.currentType === 5 /* Named */ ||
                        context.currentType === 6 /* List */ ||
                        context.currentType === 7 /* Literal */)) {
                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
                    context.braceNest = 0;
                    return readToken(scnr, context);
                }
                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {
                    token = getToken(context, 5 /* Named */, readNamedIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {
                    token = getToken(context, 6 /* List */, readListIdentifier(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if ((validLiteral = isLiteralStart(scnr, context))) {
                    token = getToken(context, 7 /* Literal */, readLiteral(scnr));
                    skipSpaces(scnr);
                    return token;
                }
                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...
                    token = getToken(context, 13 /* InvalidPlace */, readInvalidIdentifier(scnr));
                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
                    skipSpaces(scnr);
                    return token;
                }
                break;
        }
        return token;
    }
    // TODO: We need refactoring of token parsing ...
    function readTokenInLinked(scnr, context) {
        const { currentType } = context;
        let token = null;
        const ch = scnr.currentChar();
        if ((currentType === 8 /* LinkedAlias */ ||
            currentType === 9 /* LinkedDot */ ||
            currentType === 12 /* LinkedModifier */ ||
            currentType === 10 /* LinkedDelimiter */) &&
            (ch === CHAR_LF || ch === CHAR_SP)) {
            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        switch (ch) {
            case "@" /* LinkedAlias */:
                scnr.next();
                token = getToken(context, 8 /* LinkedAlias */, "@" /* LinkedAlias */);
                context.inLinked = true;
                return token;
            case "." /* LinkedDot */:
                skipSpaces(scnr);
                scnr.next();
                return getToken(context, 9 /* LinkedDot */, "." /* LinkedDot */);
            case ":" /* LinkedDelimiter */:
                skipSpaces(scnr);
                scnr.next();
                return getToken(context, 10 /* LinkedDelimiter */, ":" /* LinkedDelimiter */);
            default:
                if (isPluralStart(scnr)) {
                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                if (isLinkedDotStart(scnr, context) ||
                    isLinkedDelimiterStart(scnr, context)) {
                    skipSpaces(scnr);
                    return readTokenInLinked(scnr, context);
                }
                if (isLinkedModifierStart(scnr, context)) {
                    skipSpaces(scnr);
                    return getToken(context, 12 /* LinkedModifier */, readLinkedModifier(scnr));
                }
                if (isLinkedReferStart(scnr, context)) {
                    skipSpaces(scnr);
                    if (ch === "{" /* BraceLeft */) {
                        // scan the placeholder
                        return readTokenInPlaceholder(scnr, context) || token;
                    }
                    else {
                        return getToken(context, 11 /* LinkedKey */, readLinkedRefer(scnr));
                    }
                }
                if (currentType === 8 /* LinkedAlias */) {
                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
                }
                context.braceNest = 0;
                context.inLinked = false;
                return readToken(scnr, context);
        }
    }
    // TODO: We need refactoring of token parsing ...
    function readToken(scnr, context) {
        let token = { type: 14 /* EOF */ };
        if (context.braceNest > 0) {
            return readTokenInPlaceholder(scnr, context) || getEndToken(context);
        }
        if (context.inLinked) {
            return readTokenInLinked(scnr, context) || getEndToken(context);
        }
        const ch = scnr.currentChar();
        switch (ch) {
            case "{" /* BraceLeft */:
                return readTokenInPlaceholder(scnr, context) || getEndToken(context);
            case "}" /* BraceRight */:
                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
                scnr.next();
                return getToken(context, 3 /* BraceRight */, "}" /* BraceRight */);
            case "@" /* LinkedAlias */:
                return readTokenInLinked(scnr, context) || getEndToken(context);
            default:
                if (isPluralStart(scnr)) {
                    token = getToken(context, 1 /* Pipe */, readPlural(scnr));
                    // reset
                    context.braceNest = 0;
                    context.inLinked = false;
                    return token;
                }
                const { isModulo, hasSpace } = detectModuloStart(scnr);
                if (isModulo) {
                    return hasSpace
                        ? getToken(context, 0 /* Text */, readText(scnr))
                        : getToken(context, 4 /* Modulo */, readModulo(scnr));
                }
                if (isTextStart(scnr)) {
                    return getToken(context, 0 /* Text */, readText(scnr));
                }
                break;
        }
        return token;
    }
    function nextToken() {
        const { currentType, offset, startLoc, endLoc } = _context;
        _context.lastType = currentType;
        _context.lastOffset = offset;
        _context.lastStartLoc = startLoc;
        _context.lastEndLoc = endLoc;
        _context.offset = currentOffset();
        _context.startLoc = currentPosition();
        if (_scnr.currentChar() === EOF) {
            return getToken(_context, 14 /* EOF */);
        }
        return readToken(_scnr, _context);
    }
    return {
        nextToken,
        currentOffset,
        currentPosition,
        context
    };
}

const ERROR_DOMAIN = 'parser';
// Backslash backslash, backslash quote, uHHHH, UHHHHHH.
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
    switch (match) {
        case `\\\\`:
            return `\\`;
        case `\\\'`:
            return `\'`;
        default: {
            const codePoint = parseInt(codePoint4 || codePoint6, 16);
            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {
                return String.fromCodePoint(codePoint);
            }
            // invalid ...
            // Replace them with U+FFFD REPLACEMENT CHARACTER.
            return '�';
        }
    }
}
function createParser(options = {}) {
    const location = options.location !== false;
    const { onError } = options;
    function emitError(tokenzer, code, start, offset, ...args) {
        const end = tokenzer.currentPosition();
        end.offset += offset;
        end.column += offset;
        if (onError) {
            const loc = createLocation(start, end);
            const err = createCompileError(code, loc, {
                domain: ERROR_DOMAIN,
                args
            });
            onError(err);
        }
    }
    function startNode(type, offset, loc) {
        const node = {
            type,
            start: offset,
            end: offset
        };
        if (location) {
            node.loc = { start: loc, end: loc };
        }
        return node;
    }
    function endNode(node, offset, pos, type) {
        node.end = offset;
        if (type) {
            node.type = type;
        }
        if (location && node.loc) {
            node.loc.end = pos;
        }
    }
    function parseText(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(3 /* Text */, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseList(tokenizer, index) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(5 /* List */, offset, loc);
        node.index = parseInt(index, 10);
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseNamed(tokenizer, key) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(4 /* Named */, offset, loc);
        node.key = key;
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLiteral(tokenizer, value) {
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc
        const node = startNode(9 /* Literal */, offset, loc);
        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
        tokenizer.nextToken(); // skip brach right
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinkedModifier(tokenizer) {
        const token = tokenizer.nextToken();
        const context = tokenizer.context();
        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc
        const node = startNode(8 /* LinkedModifier */, offset, loc);
        if (token.type !== 12 /* LinkedModifier */) {
            // empty modifier
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
            node.value = '';
            endNode(node, offset, loc);
            return {
                nextConsumeToken: token,
                node
            };
        }
        // check token
        if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        node.value = token.value || '';
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node
        };
    }
    function parseLinkedKey(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(7 /* LinkedKey */, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseLinked(tokenizer) {
        const context = tokenizer.context();
        const linkedNode = startNode(6 /* Linked */, context.offset, context.startLoc);
        let token = tokenizer.nextToken();
        if (token.type === 9 /* LinkedDot */) {
            const parsed = parseLinkedModifier(tokenizer);
            linkedNode.modifier = parsed.node;
            token = parsed.nextConsumeToken || tokenizer.nextToken();
        }
        // asset check token
        if (token.type !== 10 /* LinkedDelimiter */) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        token = tokenizer.nextToken();
        // skip brace left
        if (token.type === 2 /* BraceLeft */) {
            token = tokenizer.nextToken();
        }
        switch (token.type) {
            case 11 /* LinkedKey */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');
                break;
            case 5 /* Named */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseNamed(tokenizer, token.value || '');
                break;
            case 6 /* List */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseList(tokenizer, token.value || '');
                break;
            case 7 /* Literal */:
                if (token.value == null) {
                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                }
                linkedNode.key = parseLiteral(tokenizer, token.value || '');
                break;
            default:
                // empty key
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
                const nextContext = tokenizer.context();
                const emptyLinkedKeyNode = startNode(7 /* LinkedKey */, nextContext.offset, nextContext.startLoc);
                emptyLinkedKeyNode.value = '';
                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
                linkedNode.key = emptyLinkedKeyNode;
                endNode(linkedNode, nextContext.offset, nextContext.startLoc);
                return {
                    nextConsumeToken: token,
                    node: linkedNode
                };
        }
        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
            node: linkedNode
        };
    }
    function parseMessage(tokenizer) {
        const context = tokenizer.context();
        const startOffset = context.currentType === 1 /* Pipe */
            ? tokenizer.currentOffset()
            : context.offset;
        const startLoc = context.currentType === 1 /* Pipe */
            ? context.endLoc
            : context.startLoc;
        const node = startNode(2 /* Message */, startOffset, startLoc);
        node.items = [];
        let nextToken = null;
        do {
            const token = nextToken || tokenizer.nextToken();
            nextToken = null;
            switch (token.type) {
                case 0 /* Text */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseText(tokenizer, token.value || ''));
                    break;
                case 6 /* List */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseList(tokenizer, token.value || ''));
                    break;
                case 5 /* Named */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseNamed(tokenizer, token.value || ''));
                    break;
                case 7 /* Literal */:
                    if (token.value == null) {
                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
                    }
                    node.items.push(parseLiteral(tokenizer, token.value || ''));
                    break;
                case 8 /* LinkedAlias */:
                    const parsed = parseLinked(tokenizer);
                    node.items.push(parsed.node);
                    nextToken = parsed.nextConsumeToken || null;
                    break;
            }
        } while (context.currentType !== 14 /* EOF */ &&
            context.currentType !== 1 /* Pipe */);
        // adjust message node loc
        const endOffset = context.currentType === 1 /* Pipe */
            ? context.lastOffset
            : tokenizer.currentOffset();
        const endLoc = context.currentType === 1 /* Pipe */
            ? context.lastEndLoc
            : tokenizer.currentPosition();
        endNode(node, endOffset, endLoc);
        return node;
    }
    function parsePlural(tokenizer, offset, loc, msgNode) {
        const context = tokenizer.context();
        let hasEmptyMessage = msgNode.items.length === 0;
        const node = startNode(1 /* Plural */, offset, loc);
        node.cases = [];
        node.cases.push(msgNode);
        do {
            const msg = parseMessage(tokenizer);
            if (!hasEmptyMessage) {
                hasEmptyMessage = msg.items.length === 0;
            }
            node.cases.push(msg);
        } while (context.currentType !== 14 /* EOF */);
        if (hasEmptyMessage) {
            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    function parseResource(tokenizer) {
        const context = tokenizer.context();
        const { offset, startLoc } = context;
        const msgNode = parseMessage(tokenizer);
        if (context.currentType === 14 /* EOF */) {
            return msgNode;
        }
        else {
            return parsePlural(tokenizer, offset, startLoc, msgNode);
        }
    }
    function parse(source) {
        const tokenizer = createTokenizer(source, (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options));
        const context = tokenizer.context();
        const node = startNode(0 /* Resource */, context.offset, context.startLoc);
        if (location && node.loc) {
            node.loc.source = source;
        }
        node.body = parseResource(tokenizer);
        // assert whether achieved to EOF
        if (context.currentType !== 14 /* EOF */) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
    }
    return { parse };
}
function getTokenCaption(token) {
    if (token.type === 14 /* EOF */) {
        return 'EOF';
    }
    const name = (token.value || '').replace(/\r?\n/gu, '\\n');
    return name.length > 10 ? name.slice(0, 9) + '…' : name;
}

function createTransformer(ast, options = {} // eslint-disable-line
) {
    const _context = {
        ast,
        helpers: new Set()
    };
    const context = () => _context;
    const helper = (name) => {
        _context.helpers.add(name);
        return name;
    };
    return { context, helper };
}
function traverseNodes(nodes, transformer) {
    for (let i = 0; i < nodes.length; i++) {
        traverseNode(nodes[i], transformer);
    }
}
function traverseNode(node, transformer) {
    // TODO: if we need pre-hook of transform, should be implemented to here
    switch (node.type) {
        case 1 /* Plural */:
            traverseNodes(node.cases, transformer);
            transformer.helper("plural" /* PLURAL */);
            break;
        case 2 /* Message */:
            traverseNodes(node.items, transformer);
            break;
        case 6 /* Linked */:
            const linked = node;
            traverseNode(linked.key, transformer);
            transformer.helper("linked" /* LINKED */);
            transformer.helper("type" /* TYPE */);
            break;
        case 5 /* List */:
            transformer.helper("interpolate" /* INTERPOLATE */);
            transformer.helper("list" /* LIST */);
            break;
        case 4 /* Named */:
            transformer.helper("interpolate" /* INTERPOLATE */);
            transformer.helper("named" /* NAMED */);
            break;
    }
    // TODO: if we need post-hook of transform, should be implemented to here
}
// transform AST
function transform(ast, options = {} // eslint-disable-line
) {
    const transformer = createTransformer(ast);
    transformer.helper("normalize" /* NORMALIZE */);
    // traverse
    ast.body && traverseNode(ast.body, transformer);
    // set meta information
    const context = transformer.context();
    ast.helpers = Array.from(context.helpers);
}

function createCodeGenerator(ast, options) {
    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
    const _context = {
        source: ast.loc.source,
        filename,
        code: '',
        column: 1,
        line: 1,
        offset: 0,
        map: undefined,
        breakLineCode,
        needIndent: _needIndent,
        indentLevel: 0
    };
    const context = () => _context;
    function push(code, node) {
        _context.code += code;
    }
    function _newline(n, withBreakLine = true) {
        const _breakLineCode = withBreakLine ? breakLineCode : '';
        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
    }
    function indent(withNewLine = true) {
        const level = ++_context.indentLevel;
        withNewLine && _newline(level);
    }
    function deindent(withNewLine = true) {
        const level = --_context.indentLevel;
        withNewLine && _newline(level);
    }
    function newline() {
        _newline(_context.indentLevel);
    }
    const helper = (key) => `_${key}`;
    const needIndent = () => _context.needIndent;
    return {
        context,
        push,
        indent,
        deindent,
        newline,
        helper,
        needIndent
    };
}
function generateLinkedNode(generator, node) {
    const { helper } = generator;
    generator.push(`${helper("linked" /* LINKED */)}(`);
    generateNode(generator, node.key);
    if (node.modifier) {
        generator.push(`, `);
        generateNode(generator, node.modifier);
        generator.push(`, _type`);
    }
    else {
        generator.push(`, undefined, _type`);
    }
    generator.push(`)`);
}
function generateMessageNode(generator, node) {
    const { helper, needIndent } = generator;
    generator.push(`${helper("normalize" /* NORMALIZE */)}([`);
    generator.indent(needIndent());
    const length = node.items.length;
    for (let i = 0; i < length; i++) {
        generateNode(generator, node.items[i]);
        if (i === length - 1) {
            break;
        }
        generator.push(', ');
    }
    generator.deindent(needIndent());
    generator.push('])');
}
function generatePluralNode(generator, node) {
    const { helper, needIndent } = generator;
    if (node.cases.length > 1) {
        generator.push(`${helper("plural" /* PLURAL */)}([`);
        generator.indent(needIndent());
        const length = node.cases.length;
        for (let i = 0; i < length; i++) {
            generateNode(generator, node.cases[i]);
            if (i === length - 1) {
                break;
            }
            generator.push(', ');
        }
        generator.deindent(needIndent());
        generator.push(`])`);
    }
}
function generateResource(generator, node) {
    if (node.body) {
        generateNode(generator, node.body);
    }
    else {
        generator.push('null');
    }
}
function generateNode(generator, node) {
    const { helper } = generator;
    switch (node.type) {
        case 0 /* Resource */:
            generateResource(generator, node);
            break;
        case 1 /* Plural */:
            generatePluralNode(generator, node);
            break;
        case 2 /* Message */:
            generateMessageNode(generator, node);
            break;
        case 6 /* Linked */:
            generateLinkedNode(generator, node);
            break;
        case 8 /* LinkedModifier */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 7 /* LinkedKey */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 5 /* List */:
            generator.push(`${helper("interpolate" /* INTERPOLATE */)}(${helper("list" /* LIST */)}(${node.index}))`, node);
            break;
        case 4 /* Named */:
            generator.push(`${helper("interpolate" /* INTERPOLATE */)}(${helper("named" /* NAMED */)}(${JSON.stringify(node.key)}))`, node);
            break;
        case 9 /* Literal */:
            generator.push(JSON.stringify(node.value), node);
            break;
        case 3 /* Text */:
            generator.push(JSON.stringify(node.value), node);
            break;
        default:
            if ((true)) {
                throw new Error(`unhandled codegen node type: ${node.type}`);
            }
    }
}
// generate code from AST
const generate = (ast, options = {} // eslint-disable-line
) => {
    const mode = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(options.mode) ? options.mode : 'normal';
    const filename = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_0__.isString)(options.filename)
        ? options.filename
        : 'message.intl';
    const sourceMap = !!options.sourceMap;
    // prettier-ignore
    const breakLineCode = options.breakLineCode != null
        ? options.breakLineCode
        : mode === 'arrow'
            ? ';'
            : '\n';
    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';
    const helpers = ast.helpers || [];
    const generator = createCodeGenerator(ast, {
        mode,
        filename,
        sourceMap,
        breakLineCode,
        needIndent
    });
    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);
    generator.indent(needIndent);
    if (helpers.length > 0) {
        generator.push(`const { ${helpers.map(s => `${s}: _${s}`).join(', ')} } = ctx`);
        generator.newline();
    }
    generator.push(`return `);
    generateNode(generator, ast);
    generator.deindent(needIndent);
    generator.push(`}`);
    const { code, map } = generator.context();
    return {
        ast,
        code,
        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any
    };
};

function baseCompile(source, options = {}) {
    const assignedOptions = (0,_intlify_shared__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);
    // parse source codes
    const parser = createParser(assignedOptions);
    const ast = parser.parse(source);
    // transform ASTs
    transform(ast, assignedOptions);
    // generate javascript codes
    return generate(ast, assignedOptions);
}




/***/ }),
/* 26 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IntlifyDevToolsHooks": function() { return /* binding */ IntlifyDevToolsHooks; }
/* harmony export */ });
/*!
  * devtools-if v9.2.2
  * (c) 2022 kazuya kawaguchi
  * Released under the MIT License.
  */
const IntlifyDevToolsHooks =  {
    I18nInit: 'i18n:init',
    FunctionTranslate: 'function:translate'
};




/***/ }),
/* 27 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BEFORECREATE": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.BEFORECREATE; },
/* harmony export */   "BEFOREMOUNT": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.BEFOREMOUNT; },
/* harmony export */   "BEFOREUNMOUNT": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.BEFOREUNMOUNT; },
/* harmony export */   "BEFOREUPDATE": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.BEFOREUPDATE; },
/* harmony export */   "CREATED": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.CREATED; },
/* harmony export */   "MOUNTED": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.MOUNTED; },
/* harmony export */   "ONHIDE": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.ONHIDE; },
/* harmony export */   "ONLOAD": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.ONLOAD; },
/* harmony export */   "ONRESIZE": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.ONRESIZE; },
/* harmony export */   "ONSHOW": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.ONSHOW; },
/* harmony export */   "UNMOUNTED": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.UNMOUNTED; },
/* harmony export */   "UPDATED": function() { return /* reexport safe */ _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__.UPDATED; },
/* harmony export */   "computed": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.computed; },
/* harmony export */   "createActionsWithThis": function() { return /* reexport safe */ _mpxjs_store__WEBPACK_IMPORTED_MODULE_2__.createActionsWithThis; },
/* harmony export */   "createApp": function() { return /* reexport safe */ _platform_index__WEBPACK_IMPORTED_MODULE_4__["default"]; },
/* harmony export */   "createComponent": function() { return /* reexport safe */ _platform_index__WEBPACK_IMPORTED_MODULE_6__["default"]; },
/* harmony export */   "createGettersWithThis": function() { return /* reexport safe */ _mpxjs_store__WEBPACK_IMPORTED_MODULE_2__.createGettersWithThis; },
/* harmony export */   "createMutationsWithThis": function() { return /* reexport safe */ _mpxjs_store__WEBPACK_IMPORTED_MODULE_2__.createMutationsWithThis; },
/* harmony export */   "createPage": function() { return /* reexport safe */ _platform_index__WEBPACK_IMPORTED_MODULE_5__["default"]; },
/* harmony export */   "createStateWithThis": function() { return /* reexport safe */ _mpxjs_store__WEBPACK_IMPORTED_MODULE_2__.createStateWithThis; },
/* harmony export */   "createStore": function() { return /* reexport safe */ _mpxjs_store__WEBPACK_IMPORTED_MODULE_2__.createStore; },
/* harmony export */   "createStoreWithThis": function() { return /* reexport safe */ _mpxjs_store__WEBPACK_IMPORTED_MODULE_2__.createStoreWithThis; },
/* harmony export */   "customRef": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.customRef; },
/* harmony export */   "del": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.del; },
/* harmony export */   "effectScope": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.getCurrentScope; },
/* harmony export */   "getMixin": function() { return /* reexport safe */ _core_mergeOptions__WEBPACK_IMPORTED_MODULE_10__.getMixin; },
/* harmony export */   "implement": function() { return /* reexport safe */ _core_implement__WEBPACK_IMPORTED_MODULE_3__.implement; },
/* harmony export */   "isReactive": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.isReactive; },
/* harmony export */   "isRef": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.isRef; },
/* harmony export */   "markRaw": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.markRaw; },
/* harmony export */   "nextTick": function() { return /* reexport safe */ _observer_scheduler__WEBPACK_IMPORTED_MODULE_7__.nextTick; },
/* harmony export */   "onAddToFavorites": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onAddToFavorites; },
/* harmony export */   "onBeforeMount": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onBeforeUpdate; },
/* harmony export */   "onHide": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onHide; },
/* harmony export */   "onLoad": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onLoad; },
/* harmony export */   "onMounted": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onMounted; },
/* harmony export */   "onPageScroll": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onPageScroll; },
/* harmony export */   "onPullDownRefresh": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onPullDownRefresh; },
/* harmony export */   "onReachBottom": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onReachBottom; },
/* harmony export */   "onResize": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onResize; },
/* harmony export */   "onSaveExitState": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onSaveExitState; },
/* harmony export */   "onScopeDispose": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.onScopeDispose; },
/* harmony export */   "onShareAppMessage": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onShareAppMessage; },
/* harmony export */   "onShareTimeline": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onShareTimeline; },
/* harmony export */   "onShow": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onShow; },
/* harmony export */   "onTabItemTap": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onTabItemTap; },
/* harmony export */   "onUnmounted": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* reexport safe */ _core_proxy__WEBPACK_IMPORTED_MODULE_9__.onUpdated; },
/* harmony export */   "reactive": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.reactive; },
/* harmony export */   "ref": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.ref; },
/* harmony export */   "set": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.set; },
/* harmony export */   "shallowReactive": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.shallowReactive; },
/* harmony export */   "shallowRef": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.shallowRef; },
/* harmony export */   "toPureObject": function() { return /* binding */ toPureObject; },
/* harmony export */   "toRef": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.toRef; },
/* harmony export */   "toRefs": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.toRefs; },
/* harmony export */   "triggerRef": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.triggerRef; },
/* harmony export */   "unref": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.unref; },
/* harmony export */   "useI18n": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.useI18n; },
/* harmony export */   "watch": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.watch; },
/* harmony export */   "watchEffect": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* reexport safe */ _platform_export_index__WEBPACK_IMPORTED_MODULE_1__.watchSyncEffect; }
/* harmony export */ });
/* harmony import */ var _vue__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(119);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _platform_export_api__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(118);
/* harmony import */ var _platform_export_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _mpxjs_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _core_implement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _platform_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(43);
/* harmony import */ var _platform_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77);
/* harmony import */ var _platform_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(117);
/* harmony import */ var _observer_scheduler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(81);
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(46);
/* harmony import */ var _core_proxy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(80);
/* harmony import */ var _core_mergeOptions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(64);






















function toPureObject (obj) {
  return (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(obj).clone
}

function extendProps (target, proxyObj, rawProps, option) {
  const keys = Object.getOwnPropertyNames(proxyObj)
  const rawPropsMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(rawProps)

  for (const key of keys) {
    if (_platform_export_api__WEBPACK_IMPORTED_MODULE_11__.APIs[key] || rawPropsMap[key]) {
      continue
    } else if (option && (option.prefix || option.postfix)) {
      const transformKey = option.prefix
        ? option.prefix + '_' + key
        : key + '_' + option.postfix
      target[transformKey] = proxyObj[key]
    } else if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key)) {
      target[key] = proxyObj[key]
    } else {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`Mpx property [${key}] from installing plugin conflicts with already exists，please pass prefix/postfix options to avoid property conflict, for example: "use('plugin', {prefix: 'mm'})"`)
    }
  }
}

// 安装插件进行扩展API
const installedPlugins = []

function use (plugin, options = {}) {
  if (installedPlugins.indexOf(plugin) > -1) {
    return this
  }

  const args = [options]
  const proxyMpx = factory()
  const rawProps = Object.getOwnPropertyNames(proxyMpx)
  const rawPrototypeProps = Object.getOwnPropertyNames(proxyMpx.prototype)
  args.unshift(proxyMpx)
  // 传入真正的mpx对象供插件访问
  args.push(Mpx)
  if (typeof plugin.install === 'function') {
    plugin.install.apply(plugin, args)
  } else if (typeof plugin === 'function') {
    plugin.apply(null, args)
  }
  extendProps(Mpx, proxyMpx, rawProps, options)
  extendProps(Mpx.prototype, proxyMpx.prototype, rawPrototypeProps, options)
  installedPlugins.push(plugin)
  return this
}

_platform_export_api__WEBPACK_IMPORTED_MODULE_11__.APIs.use = use

function factory () {
  // 作为原型挂载属性的中间层
  function Mpx () {
  }

  Object.assign(Mpx, _platform_export_api__WEBPACK_IMPORTED_MODULE_11__.APIs)
  Object.assign(Mpx.prototype, _platform_export_api__WEBPACK_IMPORTED_MODULE_11__.InstanceAPIs)
  // 输出web时在mpx上挂载Vue对象
  if (true) {
    Mpx.__vue = _vue__WEBPACK_IMPORTED_MODULE_12__["default"]
  }
  return Mpx
}

const Mpx = factory()

Mpx.config = {
  useStrictDiff: false,
  ignoreWarning: false,
  ignoreProxyWhiteList: ['id', 'dataset', 'data'],
  observeClassInstance: false,
  errorHandler: null,
  proxyEventHandler: null,
  setDataHandler: null,
  forceFlushSync: false,
  webRouteConfig: {}
}

__webpack_require__.g.__mpx = Mpx

if (false) {}

/* harmony default export */ __webpack_exports__["default"] = (Mpx);


/***/ }),
/* 28 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aIsSubPathOfB": function() { return /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_2__.aIsSubPathOfB; },
/* harmony export */   "aliasReplace": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.aliasReplace; },
/* harmony export */   "arrayProtoAugment": function() { return /* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_4__.arrayProtoAugment; },
/* harmony export */   "callWithErrorHandling": function() { return /* reexport safe */ _errorHandling__WEBPACK_IMPORTED_MODULE_6__.callWithErrorHandling; },
/* harmony export */   "dash2hump": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.dash2hump; },
/* harmony export */   "def": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.def; },
/* harmony export */   "diffAndCloneA": function() { return /* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.diffAndCloneA; },
/* harmony export */   "doGetByPath": function() { return /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_2__.doGetByPath; },
/* harmony export */   "enumerableKeys": function() { return /* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.enumerableKeys; },
/* harmony export */   "error": function() { return /* reexport safe */ _log__WEBPACK_IMPORTED_MODULE_0__.error; },
/* harmony export */   "findItem": function() { return /* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_4__.findItem; },
/* harmony export */   "getByPath": function() { return /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_2__.getByPath; },
/* harmony export */   "getEnvObj": function() { return /* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_8__.getEnvObj; },
/* harmony export */   "getFirstKey": function() { return /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_2__.getFirstKey; },
/* harmony export */   "hasChanged": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.hasChanged; },
/* harmony export */   "hasOwn": function() { return /* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.hasOwn; },
/* harmony export */   "hasProto": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.hasProto; },
/* harmony export */   "hump2dash": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.hump2dash; },
/* harmony export */   "isArray": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isArray; },
/* harmony export */   "isBoolean": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isBoolean; },
/* harmony export */   "isBrowser": function() { return /* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_8__.isBrowser; },
/* harmony export */   "isDef": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isDef; },
/* harmony export */   "isDev": function() { return /* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_8__.isDev; },
/* harmony export */   "isEmptyObject": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isEmptyObject; },
/* harmony export */   "isFunction": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isFunction; },
/* harmony export */   "isNumber": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isNumber; },
/* harmony export */   "isNumberStr": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isNumberStr; },
/* harmony export */   "isObject": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isObject; },
/* harmony export */   "isPlainObject": function() { return /* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.isPlainObject; },
/* harmony export */   "isString": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isString; },
/* harmony export */   "isValidArrayIndex": function() { return /* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_4__.isValidArrayIndex; },
/* harmony export */   "isValidIdentifierStr": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.isValidIdentifierStr; },
/* harmony export */   "makeMap": function() { return /* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_4__.makeMap; },
/* harmony export */   "mergeData": function() { return /* reexport safe */ _merge__WEBPACK_IMPORTED_MODULE_5__.mergeData; },
/* harmony export */   "mergeObj": function() { return /* reexport safe */ _merge__WEBPACK_IMPORTED_MODULE_5__.mergeObj; },
/* harmony export */   "mergeObjectArray": function() { return /* reexport safe */ _merge__WEBPACK_IMPORTED_MODULE_5__.mergeObjectArray; },
/* harmony export */   "noop": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.noop; },
/* harmony export */   "parseSelector": function() { return /* reexport safe */ _element__WEBPACK_IMPORTED_MODULE_7__.parseSelector; },
/* harmony export */   "processUndefined": function() { return /* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.processUndefined; },
/* harmony export */   "proxy": function() { return /* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.proxy; },
/* harmony export */   "remove": function() { return /* reexport safe */ _array__WEBPACK_IMPORTED_MODULE_4__.remove; },
/* harmony export */   "setByPath": function() { return /* reexport safe */ _path__WEBPACK_IMPORTED_MODULE_2__.setByPath; },
/* harmony export */   "spreadProp": function() { return /* reexport safe */ _object__WEBPACK_IMPORTED_MODULE_3__.spreadProp; },
/* harmony export */   "type": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_1__.type; },
/* harmony export */   "walkChildren": function() { return /* reexport safe */ _element__WEBPACK_IMPORTED_MODULE_7__.walkChildren; },
/* harmony export */   "warn": function() { return /* reexport safe */ _log__WEBPACK_IMPORTED_MODULE_0__.warn; }
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
/* harmony import */ var _errorHandling__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(35);
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36);
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(37);



















/***/ }),
/* 29 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "error": function() { return /* binding */ error; },
/* harmony export */   "warn": function() { return /* binding */ warn; }
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);


const isDev = "development" !== 'production'

function warn (msg, location, e) {
  const condition = __webpack_require__.g.__mpx?.config.ignoreWarning
  let ignore = false
  if (typeof condition === 'boolean') {
    ignore = condition
  } else if (typeof condition === 'string') {
    ignore = msg.indexOf(condition) !== -1
  } else if (typeof condition === 'function') {
    ignore = condition(msg, location, e)
  } else if (condition instanceof RegExp) {
    ignore = condition.test(msg)
  }
  if (!ignore) return log('warn', msg, location, e)
}

function error (msg, location, e) {
  const errorHandler = __webpack_require__.g.__mpx?.config.errorHandler
  if ((0,_base__WEBPACK_IMPORTED_MODULE_0__.isFunction)(errorHandler)) {
    errorHandler(msg, location, e)
  }
  return log('error', msg, location, e)
}

function log (type, msg, location, e) {
  if (isDev) {
    let header = `[Mpx runtime ${type}]: `
    if (location) {
      header = `[Mpx runtime ${type} at ${location}]: `
    }
    console[type](header + msg)
    if (e) console[type](e)
  }
}


/***/ }),
/* 30 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aliasReplace": function() { return /* binding */ aliasReplace; },
/* harmony export */   "dash2hump": function() { return /* binding */ dash2hump; },
/* harmony export */   "def": function() { return /* binding */ def; },
/* harmony export */   "hasChanged": function() { return /* binding */ hasChanged; },
/* harmony export */   "hasProto": function() { return /* binding */ hasProto; },
/* harmony export */   "hump2dash": function() { return /* binding */ hump2dash; },
/* harmony export */   "isArray": function() { return /* binding */ isArray; },
/* harmony export */   "isBoolean": function() { return /* binding */ isBoolean; },
/* harmony export */   "isDef": function() { return /* binding */ isDef; },
/* harmony export */   "isEmptyObject": function() { return /* binding */ isEmptyObject; },
/* harmony export */   "isFunction": function() { return /* binding */ isFunction; },
/* harmony export */   "isNumber": function() { return /* binding */ isNumber; },
/* harmony export */   "isNumberStr": function() { return /* binding */ isNumberStr; },
/* harmony export */   "isObject": function() { return /* binding */ isObject; },
/* harmony export */   "isString": function() { return /* binding */ isString; },
/* harmony export */   "isValidIdentifierStr": function() { return /* binding */ isValidIdentifierStr; },
/* harmony export */   "noop": function() { return /* binding */ noop; },
/* harmony export */   "type": function() { return /* binding */ type; }
/* harmony export */ });
const noop = () => {}

function isString (str) {
  return typeof str === 'string'
}

function isBoolean (bool) {
  return typeof bool === 'boolean'
}

function isNumber (num) {
  return typeof num === 'number'
}

function isArray (arr) {
  return Array.isArray(arr)
}

function isFunction (fn) {
  return typeof fn === 'function'
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isEmptyObject (obj) {
  if (!obj) {
    return true
  }
  /* eslint-disable no-unreachable-loop */
  for (const key in obj) {
    return false
  }
  return true
}

function isNumberStr (str) {
  return /^\d+$/.test(str)
}

function isValidIdentifierStr (str) {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(str)
}

const hasProto = '__proto__' in {}

function dash2hump (value) {
  return value.replace(/-([a-z])/g, function (match, p1) {
    return p1.toUpperCase()
  })
}

function hump2dash (value) {
  return value.replace(/[A-Z]/g, function (match) {
    return '-' + match.toLowerCase()
  })
}

function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}

// type在支付宝环境下不一定准确，判断是普通对象优先使用isPlainObject（新版支付宝不复现，issue #644 修改isPlainObject实现与type等价）
function type (n) {
  return Object.prototype.toString.call(n).slice(8, -1)
}

function aliasReplace (options = {}, alias, target) {
  if (options[alias]) {
    if (Array.isArray(options[alias])) {
      options[target] = options[alias].concat(options[target] || [])
    } else if (isObject(options[alias])) {
      options[target] = Object.assign({}, options[alias], options[target])
    } else {
      options[target] = options[alias]
    }
    delete options[alias]
  }
  return options
}

// 比较一个值是否发生了变化（考虑NaN）。
function hasChanged (value, oldValue) {
  return !Object.is(value, oldValue)
}




/***/ }),
/* 31 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aIsSubPathOfB": function() { return /* binding */ aIsSubPathOfB; },
/* harmony export */   "doGetByPath": function() { return /* binding */ doGetByPath; },
/* harmony export */   "getByPath": function() { return /* binding */ getByPath; },
/* harmony export */   "getFirstKey": function() { return /* binding */ getFirstKey; },
/* harmony export */   "setByPath": function() { return /* binding */ setByPath; }
/* harmony export */ });
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);


let curStack
let targetStacks
let property

class Stack {
  constructor (mark) {
    this.mark = mark
    // 字符串stack需要特殊处理
    this.type = /['"]/.test(mark) ? 'string' : 'normal'
    this.value = []
  }

  push (data) {
    this.value.push(data)
  }
}

function startStack (mark) {
  // 开启栈或关闭栈都意味着前面的字符拼接截止
  propertyJoinOver()
  curStack && targetStacks.push(curStack)
  curStack = new Stack(mark)
}

function endStack () {
  // 开启栈或关闭栈都意味着前面的字符拼接截止
  propertyJoinOver()
  // 字符串栈直接拼接
  const result = curStack.type === 'string' ? '__mpx_str_' + curStack.value.join('') : curStack.value
  curStack = targetStacks.pop()
  // 将当前stack结果保存到父级stack里
  curStack.push(result)
}

function propertyJoinOver () {
  property = property.trim()
  if (property) curStack.push(property)
  property = ''
}

function init () {
  property = ''
  // 根stack
  curStack = new Stack()
  targetStacks = []
}

function parse (str) {
  init()
  for (const char of str) {
    // 当前遍历引号内的字符串时
    if (curStack.type === 'string') {
      // 若为对应的结束flag，则出栈，反之直接push
      curStack.mark === char ? endStack() : curStack.push(char)
    } else if (/['"[]/.test(char)) {
      startStack(char)
    } else if (char === ']') {
      endStack()
    } else if (char === '.' || char === '+') {
      propertyJoinOver()
      if (char === '+') curStack.push(char)
    } else {
      property += char
    }
  }
  // 字符解析收尾
  propertyJoinOver()
  return curStack.value
}

function outPutByPath (context, path, isSimple, transfer) {
  let result = context
  const len = path.length
  const meta = {
    isEnd: false,
    stop: false
  }
  for (let index = 0; index < len; index++) {
    if (index === len - 1) meta.isEnd = true
    let key
    const item = path[index]
    if (result) {
      if (isSimple) {
        key = item
      } else if (Array.isArray(item)) {
        // 获取子数组的输出结果作为当前key
        key = outPutByPath(context, item, isSimple, transfer)
      } else if (/^__mpx_str_/.test(item)) {
        // 字符串一定会被[]包裹，一定在子数组中
        result = item.replace('__mpx_str_', '')
      } else if (/^\d+$/.test(item)) {
        // 数字一定会被[]包裹，一定在子数组中
        result = +item
      } else if (item === '+') {
        // 获取加号后面所有path最终的结果
        result += outPutByPath(context, path.slice(index + 1), isSimple, transfer)
        break
      } else {
        key = item
      }
      if (key !== undefined) {
        result = transfer ? transfer(result, key, meta) : result[key]
        if (meta.stop) break
      }
    } else {
      break
    }
  }
  return result
}

function doGetByPath (context, pathStrOrArr, transfer) {
  if (!pathStrOrArr) {
    return context
  }
  let isSimple = false
  if (Array.isArray(pathStrOrArr)) {
    isSimple = true
  } else if (!/[[\]]/.test(pathStrOrArr)) {
    pathStrOrArr = pathStrOrArr.split('.')
    isSimple = true
  }

  if (!isSimple) pathStrOrArr = parse(pathStrOrArr)

  return outPutByPath(context, pathStrOrArr, isSimple, transfer)
}

function isExistAttr (obj, attr) {
  const type = typeof obj
  const isNullOrUndefined = obj === null || obj === undefined
  if (isNullOrUndefined) {
    return false
  } else if (type === 'object' || type === 'function') {
    return attr in obj
  } else {
    return obj[attr] !== undefined
  }
}

function getByPath (data, pathStrOrArr, defaultVal, errTip) {
  const results = []
  let normalizedArr = []
  if (Array.isArray(pathStrOrArr)) {
    normalizedArr = [pathStrOrArr]
  } else if (typeof pathStrOrArr === 'string') {
    normalizedArr = pathStrOrArr.split(',').map(str => str.trim())
  }

  normalizedArr.forEach(path => {
    if (!path) return
    const result = doGetByPath(data, path, (value, key) => {
      let newValue
      if (isExistAttr(value, key)) {
        newValue = value[key]
      } else {
        newValue = errTip
      }
      return newValue
    })
    // 小程序setData时不允许undefined数据
    results.push(result === undefined ? defaultVal : result)
  })
  return results.length > 1 ? results : results[0]
}

function setByPath (data, pathStrOrArr, value) {
  doGetByPath(data, pathStrOrArr, (current, key, meta) => {
    if (meta.isEnd) {
      (0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_0__.set)(current, key, value)
    } else if (!current[key]) {
      current[key] = {}
    }
    return current[key]
  })
}

function getFirstKey (path) {
  return /^[^[.]*/.exec(path)[0]
}

function aIsSubPathOfB (a, b) {
  if (a.startsWith(b) && a !== b) {
    const nextChar = a[b.length]
    if (nextChar === '.') {
      return a.slice(b.length + 1)
    } else if (nextChar === '[') {
      return a.slice(b.length)
    }
  }
}




/***/ }),
/* 32 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "diffAndCloneA": function() { return /* binding */ diffAndCloneA; },
/* harmony export */   "enumerableKeys": function() { return /* binding */ enumerableKeys; },
/* harmony export */   "hasOwn": function() { return /* binding */ hasOwn; },
/* harmony export */   "isPlainObject": function() { return /* binding */ isPlainObject; },
/* harmony export */   "processUndefined": function() { return /* binding */ processUndefined; },
/* harmony export */   "proxy": function() { return /* binding */ proxy; },
/* harmony export */   "spreadProp": function() { return /* binding */ spreadProp; }
/* harmony export */ });
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);



const hasOwnProperty = Object.prototype.hasOwnProperty

function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

function isPlainObject (value) {
  if (value === null || typeof value !== 'object' || (0,_base__WEBPACK_IMPORTED_MODULE_0__.type)(value) !== 'Object') return false
  const proto = Object.getPrototypeOf(value)
  if (proto === null) return true
  // 处理支付宝接口返回数据对象的__proto__与js中创建对象的__proto__不一致的问题，判断value.__proto__.__proto__ === null时也认为是plainObject
  const innerProto = Object.getPrototypeOf(proto)
  if (proto === Object.prototype || innerProto === null) return true
  // issue #644
  const observeClassInstance = __webpack_require__.g.__mpx?.config.observeClassInstance
  if (observeClassInstance) {
    if (Array.isArray(observeClassInstance)) {
      for (let i = 0; i < observeClassInstance.length; i++) {
        if (proto === observeClassInstance[i].prototype) return true
      }
    } else {
      return true
    }
  }
  return false
}

function diffAndCloneA (a, b) {
  let diffData = null
  let curPath = ''
  let diff = false

  function deepDiffAndCloneA (a, b, currentDiff) {
    const setDiff = (val) => {
      if (val) {
        currentDiff = val
        if (curPath) {
          diffData = diffData || {}
          diffData[curPath] = clone
        }
      }
    }
    let clone = a
    if (typeof a !== 'object' || a === null) {
      if (!currentDiff) setDiff(a !== b)
    } else {
      const toString = Object.prototype.toString
      const className = toString.call(a)
      const sameClass = className === toString.call(b)
      let length
      let lastPath
      if (isPlainObject(a)) {
        const keys = Object.keys(a)
        length = keys.length
        clone = {}
        if (!currentDiff) setDiff(!sameClass || length < Object.keys(b).length || !Object.keys(b).every((key) => hasOwn(a, key)))
        lastPath = curPath
        for (let i = 0; i < length; i++) {
          const key = keys[i]
          curPath += `.${key}`
          clone[key] = deepDiffAndCloneA(a[key], sameClass ? b[key] : undefined, currentDiff)
          curPath = lastPath
        }
        // 继承原始对象的freeze/seal/preventExtensions操作
        if (Object.isFrozen(a)) {
          Object.freeze(clone)
        } else if (Object.isSealed(a)) {
          Object.seal(clone)
        } else if (!Object.isExtensible(a)) {
          Object.preventExtensions(clone)
        }
      } else if (Array.isArray(a)) {
        length = a.length
        clone = []
        if (!currentDiff) setDiff(!sameClass || length < b.length)
        lastPath = curPath
        for (let i = 0; i < length; i++) {
          curPath += `[${i}]`
          clone[i] = deepDiffAndCloneA(a[i], sameClass ? b[i] : undefined, currentDiff)
          curPath = lastPath
        }
        // 继承原始数组的freeze/seal/preventExtensions操作
        if (Object.isFrozen(a)) {
          Object.freeze(clone)
        } else if (Object.isSealed(a)) {
          Object.seal(clone)
        } else if (!Object.isExtensible(a)) {
          Object.preventExtensions(clone)
        }
      } else if (a instanceof RegExp) {
        if (!currentDiff) setDiff(!sameClass || '' + a !== '' + b)
      } else if (a instanceof Date) {
        if (!currentDiff) setDiff(!sameClass || +a !== +b)
      } else {
        if (!currentDiff) setDiff(!sameClass || a !== b)
      }
    }
    if (currentDiff) {
      diff = currentDiff
    }
    return clone
  }

  return {
    clone: deepDiffAndCloneA(a, b, diff),
    diff,
    diffData
  }
}

function proxy (target, source, keys, readonly, onConflict) {
  keys = keys || Object.keys(source)
  keys.forEach((key) => {
    const descriptor = {
      get () {
        const val = source[key]
        return !(0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__.isReactive)(source) && (0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__.isRef)(val) ? val.value : val
      },
      configurable: true,
      enumerable: true
    }
    descriptor.set = readonly
      ? _base__WEBPACK_IMPORTED_MODULE_0__.noop
      : function (val) {
        // 对reactive对象代理时不需要处理ref解包
        if (!(0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__.isReactive)(source)) {
          const oldVal = source[key]
          if ((0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__.isRef)(oldVal) && !(0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__.isRef)(val)) {
            oldVal.value = val
            return
          }
        }
        source[key] = val
      }
    if (onConflict) {
      if (key in target) {
        if (onConflict(key) === false) return
      }
    }
    Object.defineProperty(target, key, descriptor)
  })
  return target
}

function spreadProp (obj, key) {
  if (hasOwn(obj, key)) {
    const temp = obj[key]
    delete obj[key]
    Object.assign(obj, temp)
  }
  return obj
}

// 包含原型链上属性keys
function enumerableKeys (obj) {
  const keys = []
  for (const key in obj) {
    keys.push(key)
  }
  return keys
}

function processUndefined (obj) {
  const result = {}
  for (const key in obj) {
    if (hasOwn(obj, key)) {
      if (obj[key] !== undefined) {
        result[key] = obj[key]
      } else {
        result[key] = ''
      }
    }
  }
  return result
}




/***/ }),
/* 33 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayProtoAugment": function() { return /* binding */ arrayProtoAugment; },
/* harmony export */   "findItem": function() { return /* binding */ findItem; },
/* harmony export */   "isValidArrayIndex": function() { return /* binding */ isValidArrayIndex; },
/* harmony export */   "makeMap": function() { return /* binding */ makeMap; },
/* harmony export */   "remove": function() { return /* binding */ remove; }
/* harmony export */ });
function makeMap (arr) {
  return arr.reduce((obj, item) => {
    obj[item] = true
    return obj
  }, {})
}

function findItem (arr = [], key) {
  for (const item of arr) {
    if ((key instanceof RegExp && key.test(item)) || item === key) {
      return true
    }
  }
  return false
}

function remove (arr, item) {
  if (arr.length) {
    const index = arr.indexOf(item)
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

// 微信小程序插件环境2.8.3以下基础库protoAugment会失败，对环境进行测试按需降级为copyAugment
function testArrayProtoAugment () {
  const arr = []
  /* eslint-disable no-proto, camelcase */
  arr.__proto__ = { __array_proto_test__: '__array_proto_test__' }
  return arr.__array_proto_test__ === '__array_proto_test__'
}

const arrayProtoAugment = testArrayProtoAugment()

function isValidArrayIndex (val) {
  const n = parseFloat(String(val))
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}




/***/ }),
/* 34 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeData": function() { return /* binding */ mergeData; },
/* harmony export */   "mergeObj": function() { return /* binding */ mergeObj; },
/* harmony export */   "mergeObjectArray": function() { return /* binding */ mergeObjectArray; }
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);




function doMergeData (target, source) {
  Object.keys(source).forEach((srcKey) => {
    if ((0,_object__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(target, srcKey)) {
      target[srcKey] = source[srcKey]
    } else {
      let processed = false
      const tarKeys = Object.keys(target)
      for (let i = 0; i < tarKeys.length; i++) {
        const tarKey = tarKeys[i]
        if ((0,_path__WEBPACK_IMPORTED_MODULE_2__.aIsSubPathOfB)(tarKey, srcKey)) {
          delete target[tarKey]
          target[srcKey] = source[srcKey]
          processed = true
          continue
        }
        const subPath = (0,_path__WEBPACK_IMPORTED_MODULE_2__.aIsSubPathOfB)(srcKey, tarKey)
        if (subPath) {
          (0,_path__WEBPACK_IMPORTED_MODULE_2__.setByPath)(target[tarKey], subPath, source[srcKey])
          processed = true
          break
        }
      }
      if (!processed) {
        target[srcKey] = source[srcKey]
      }
    }
  })
  return target
}

function mergeData (target, ...sources) {
  if (target) {
    sources.forEach((source) => {
      if (source) doMergeData(target, source)
    })
  }
  return target
}

// 用于合并i18n语言集
function mergeObj (target, ...sources) {
  if ((0,_base__WEBPACK_IMPORTED_MODULE_0__.isObject)(target)) {
    for (const source of sources) {
      if ((0,_base__WEBPACK_IMPORTED_MODULE_0__.isObject)(source)) {
        Object.keys(source).forEach((key) => {
          if ((0,_base__WEBPACK_IMPORTED_MODULE_0__.isObject)(source[key]) && (0,_base__WEBPACK_IMPORTED_MODULE_0__.isObject)(target[key])) {
            mergeObj(target[key], source[key])
          } else {
            target[key] = source[key]
          }
        })
      }
    }
  }
  return target
}

function mergeObjectArray (arr) {
  const res = {}
  for (let i = 0; i < arr.length; i++) {
    if (arr[i]) {
      Object.assign(res, arr[i])
    }
  }
  return res
}




/***/ }),
/* 35 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "callWithErrorHandling": function() { return /* binding */ callWithErrorHandling; }
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);



function callWithErrorHandling (fn, instance, info, args) {
  if (!(0,_base__WEBPACK_IMPORTED_MODULE_0__.isFunction)(fn)) return
  try {
    return args ? fn(...args) : fn()
  } catch (e) {
    (0,_log__WEBPACK_IMPORTED_MODULE_1__.error)(`Unhandled error occurs${info ? ` during execution of ${info}` : ''}!`, instance?.options?.mpxFileResource, e)
  }
}


/***/ }),
/* 36 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseSelector": function() { return /* binding */ parseSelector; },
/* harmony export */   "walkChildren": function() { return /* binding */ walkChildren; }
/* harmony export */ });
function parseSelector (selector) {
  const groups = selector.split(',')
  return groups.map((item) => {
    let id
    let ret = /#([^#.>\s]+)/.exec(item)
    if (ret) id = ret[1]

    const classes = []
    const classReg = /\.([^#.>\s]+)/g
    while (ret = classReg.exec(item)) {
      classes.push(ret[1])
    }
    return {
      id,
      classes
    }
  })
}

function matchSelector (vnode, selectorGroups) {
  let vnodeId
  let vnodeClasses = []
  if (vnode && vnode.data) {
    if (vnode.data.attrs && vnode.data.attrs.id) vnodeId = vnode.data.attrs.id
    if (vnode.data.staticClass) vnodeClasses = vnode.data.staticClass.split(/\s+/)
  }

  if (vnodeId || vnodeClasses.length) {
    for (let i = 0; i < selectorGroups.length; i++) {
      const { id, classes } = selectorGroups[i]
      if (id === vnodeId) return true
      if (classes.every((item) => vnodeClasses.includes(item))) return true
    }
  }
  return false
}

function walkChildren (vm, selectorGroups, context, result, all) {
  if (vm.$children && vm.$children.length) {
    for (let i = 0; i < vm.$children.length; i++) {
      const child = vm.$children[i]
      if (child.$vnode.context === context && !child.$options.__mpxBuiltIn) {
        if (matchSelector(child.$vnode, selectorGroups)) {
          result.push(child)
          if (!all) return
        }
      }
      walkChildren(child, selectorGroups, context, result, all)
    }
  }
}




/***/ }),
/* 37 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* mpx cjs variable */ var mpx = __webpack_require__(38);
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getEnvObj": function() { return /* binding */ getEnvObj; },
/* harmony export */   "isBrowser": function() { return /* binding */ isBrowser; },
/* harmony export */   "isDev": function() { return /* binding */ isDev; }
/* harmony export */ });
function getEnvObj () {
  switch ("web") {
    case 'wx':
      return /* mpx replace */ mpx
    case 'ali':
      return my
    case 'swan':
      return swan
    case 'qq':
      return qq
    case 'tt':
      return tt
    case 'jd':
      return jd
    case 'qa':
      return qa
    case 'dd':
      return dd
  }
}

const isBrowser = typeof window !== 'undefined'

const isDev = "development" !== 'production'


/***/ }),
/* 38 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(27)["default"]


/***/ }),
/* 39 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computed": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.computed; },
/* harmony export */   "customRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.customRef; },
/* harmony export */   "del": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.del; },
/* harmony export */   "effectScope": function() { return /* binding */ effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* binding */ getCurrentScope; },
/* harmony export */   "isReactive": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isReactive; },
/* harmony export */   "isRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.isRef; },
/* harmony export */   "markRaw": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.markRaw; },
/* harmony export */   "onScopeDispose": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.onScopeDispose; },
/* harmony export */   "reactive": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.reactive; },
/* harmony export */   "ref": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.ref; },
/* harmony export */   "set": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.set; },
/* harmony export */   "shallowReactive": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowReactive; },
/* harmony export */   "shallowRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef; },
/* harmony export */   "toRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRef; },
/* harmony export */   "toRefs": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.toRefs; },
/* harmony export */   "triggerRef": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.triggerRef; },
/* harmony export */   "unref": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.unref; },
/* harmony export */   "useI18n": function() { return /* reexport safe */ vue_i18n_bridge__WEBPACK_IMPORTED_MODULE_1__.useI18n; },
/* harmony export */   "watch": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watch; },
/* harmony export */   "watchEffect": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* reexport safe */ vue__WEBPACK_IMPORTED_MODULE_0__.watchSyncEffect; }
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var vue_i18n_bridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);




const noop = () => {
}

const fixEffectScope = (scope) => {
  scope.pause = noop
  scope.resume = noop
}

const effectScope = (detached) => fixEffectScope((0,vue__WEBPACK_IMPORTED_MODULE_0__.effectScope)(detached))
const getCurrentScope = () => fixEffectScope((0,vue__WEBPACK_IMPORTED_MODULE_0__.getCurrentScope)())






/***/ }),
/* 40 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createActionsWithThis": function() { return /* binding */ createActionsWithThis; },
/* harmony export */   "createGettersWithThis": function() { return /* binding */ createGettersWithThis; },
/* harmony export */   "createMutationsWithThis": function() { return /* binding */ createMutationsWithThis; },
/* harmony export */   "createStateWithThis": function() { return /* binding */ createStateWithThis; },
/* harmony export */   "createStore": function() { return /* binding */ createStore; },
/* harmony export */   "createStoreWithThis": function() { return /* binding */ createStoreWithThis; }
/* harmony export */ });
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _mapStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);



// 兼容在web和小程序平台中创建表现一致的store



function transformGetters (getters, module, store) {
  const newGetters = {}
  for (const key in getters) {
    if (key in store.getters) {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Duplicate getter type: ${key}.`)
    }
    const getter = function () {
      if (store.withThis) {
        return getters[key].call({
          state: module.state,
          getters: store.getters,
          rootState: store.state
        })
      }
      return getters[key](module.state, store.getters, store.state)
    }
    newGetters[key] = getter
  }
  return newGetters
}

function transformMutations (mutations, module, store) {
  const newMutations = {}
  for (const key in mutations) {
    if (store.mutations[key]) {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Duplicate mutation type: ${key}.`)
    }
    const context = {
      state: module.state,
      commit: store.commit.bind(store)
    }
    const mutation = function (...payload) {
      if (store.withThis) return mutations[key].apply(context, payload)
      return mutations[key](module.state, ...payload)
    }
    newMutations[key] = mutation
  }
  return newMutations
}

function transformActions (actions, module, store) {
  const newActions = {}
  for (const key in actions) {
    if (store.actions[key]) {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Duplicate action type: ${key}.`)
    }
    newActions[key] = function (...payload) {
      const context = {
        rootState: store.state,
        state: module.state,
        getters: store.getters,
        dispatch: store.dispatch.bind(store),
        commit: store.commit.bind(store)
      }

      let result
      if (store.withThis) {
        result = actions[key].apply(context, payload)
      } else {
        result = actions[key](context, ...payload)
      }
      // action一定返回一个promise
      if (result && typeof result.then === 'function' && typeof result.catch === 'function') {
        return result
      } else {
        return Promise.resolve(result)
      }
    }
  }
  return newActions
}

function mergeDeps (module, deps) {
  const mergeProps = ['state', 'getters', 'mutations', 'actions']
  Object.keys(deps).forEach(key => {
    const store = deps[key]
    mergeProps.forEach(prop => {
      if (module[prop] && (key in module[prop])) {
        (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Deps's name [${key}] conflicts with ${prop}'s key in current options.`)
      } else {
        module[prop] = module[prop] || {}
        if (prop === 'getters') {
          // depsGetters单独存放，不需要重新进行初始化
          module.depsGetters = module.depsGetters || {}
          module.depsGetters[key] = store.getters
          // module[prop][key] = () => store[prop]
        } else {
          module[prop][key] = store[prop]
        }
      }
    })
  })
}

class Store {
  constructor (options) {
    const {
      plugins = []
    } = options
    this.withThis = options.withThis
    this.__wrappedGetters = {}
    this.__depsGetters = {}
    this.getters = {}
    this.mutations = {}
    this.actions = {}
    this._subscribers = []
    this.state = this.registerModule(options).state
    this.resetStoreVM()
    Object.assign(this, (0,_mapStore__WEBPACK_IMPORTED_MODULE_1__["default"])(this))
    plugins.forEach(plugin => plugin(this))
  }

  dispatch (type, ...payload) {
    const action = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getByPath)(this.actions, type)
    if (!action) {
      return Promise.reject(new Error(`unknown action type: ${type}`))
    } else {
      return action(...payload)
    }
  }

  commit (type, ...payload) {
    const mutation = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getByPath)(this.mutations, type)
    if (!mutation) {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unknown mutation type: ${type}.`)
    } else {
      mutation(...payload)
      return this._subscribers.slice().forEach(sub => sub({ type, payload }, this.state))
    }
  }

  subscribe (fn, options) {
    return genericSubscribe(fn, this._subscribers, options)
  }

  registerModule (module) {
    const state = module.state || {}
    const reactiveModule = {
      state
    }
    if (module.getters) {
      reactiveModule.getters = transformGetters(module.getters, reactiveModule, this)
    }
    if (module.mutations) {
      reactiveModule.mutations = transformMutations(module.mutations, reactiveModule, this)
    }
    if (module.actions) {
      reactiveModule.actions = transformActions(module.actions, reactiveModule, this)
    }
    if (module.deps) {
      mergeDeps(reactiveModule, module.deps)
    }
    Object.assign(this.__depsGetters, reactiveModule.depsGetters)
    Object.assign(this.__wrappedGetters, reactiveModule.getters)
    // merge mutations
    Object.assign(this.mutations, reactiveModule.mutations)
    // merge actions
    Object.assign(this.actions, reactiveModule.actions)
    // 子module
    if (module.modules) {
      const childs = module.modules
      Object.keys(childs).forEach(key => {
        reactiveModule.state[key] = this.registerModule(childs[key]).state
      })
    }
    return reactiveModule
  }

  resetStoreVM () {
    if (true) {
      const Vue = _mpxjs_core__WEBPACK_IMPORTED_MODULE_2__["default"].__vue
      const vm = new Vue({
        data: {
          __mpxState: this.state
        },
        computed: this.__wrappedGetters
      })
      const computedKeys = Object.keys(this.__wrappedGetters)
      ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.getters, vm, computedKeys)
      ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.getters, this.__depsGetters)
    } else {}
  }
}

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn)
  }
  return () => {
    const i = subs.indexOf(fn)
    if (i > -1) {
      subs.splice(i, 1)
    }
  }
}

function createStore (options) {
  return new Store(options)
}

// ts util functions
function createStateWithThis (state) {
  return state
}

function createGettersWithThis (getters, options = {}) {
  return getters
}

function createMutationsWithThis (mutations, options = {}) {
  return mutations
}

function createActionsWithThis (actions, options = {}) {
  return actions
}

function createStoreWithThis (options) {
  options.withThis = true
  return new Store(options)
}


/***/ }),
/* 41 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);




function normalizeMap (prefix, arr) {
  if (typeof prefix !== 'string') {
    arr = prefix
    prefix = ''
  }
  if (Array.isArray(arr)) {
    const map = {}
    arr.forEach(value => {
      map[value] = prefix ? `${prefix}.${value}` : value
    })
    return map
  }
  if (prefix && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(arr)) {
    arr = Object.assign({}, arr)
    Object.keys(arr).forEach(key => {
      if (typeof arr[key] === 'string') {
        arr[key] = `${prefix}.${arr[key]}`
      }
    })
  }
  return arr
}

function mapFactory (type, store) {
  return function (depPath, maps) {
    maps = normalizeMap(depPath, maps)
    const result = {}
    Object.entries(maps).forEach(([key, value]) => {
      result[key] = function (payload) {
        switch (type) {
          case 'state':
            if (typeof value === 'function') {
              return value.call(this, store.state, store.getters)
            } else {
              let stateVal = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getByPath)(store.state, value, '', '__NOTFOUND__')
              if (stateVal === '__NOTFOUND__') {
                (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unknown state named [${value}].`)
                stateVal = ''
              }
              return stateVal
            }
          case 'getters': {
            let getterVal = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getByPath)(store.getters, value, '', '__NOTFOUND__')
            if (getterVal === '__NOTFOUND__') {
              (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Unknown getter named [${value}].`)
              getterVal = ''
            }
            return getterVal
          }
          case 'mutations':
            return store.commit(value, payload)
          case 'actions':
            return store.dispatch(value, payload)
        }
      }
    })
    return result
  }
}

function checkMapInstance (args) {
  const context = args[args.length - 1]
  const isValid = context && typeof context === 'object' && context.__mpxProxy
  if (!isValid) {
    (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)('调用map**ToInstance时必须传入当前component实例this')
  }

  args.splice(-1)

  return {
    restParams: args,
    context
  }
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(store) {
  const mapState = mapFactory('state', store)
  const mapGetters = mapFactory('getters', store)
  const mapMutations = mapFactory('mutations', store)
  const mapActions = mapFactory('actions', store)

  return {
    mapState,
    mapGetters,
    mapMutations,
    mapActions,
    // map*ToRefs用于组合式API解构获取响应式数据
    mapStateToRefs: (...args) => {
      const result = {}
      Object.entries(mapState(...args)).forEach(([key, value]) => {
        result[key] = (0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__.computed)(value)
      })
      return result
    },
    mapGettersToRefs: (...args) => {
      const result = {}
      Object.entries(mapGetters(...args)).forEach(([key, value]) => {
        result[key] = (0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__.computed)(value)
      })
      return result
    },
    // 以下是map*ToInstance用于异步store的,参数args：depPath, maps, context
    mapStateToInstance: (...args) => {
      const { context, restParams } = checkMapInstance(args)
      const result = mapState(...restParams)
      // 将result挂载到mpxProxy实例属性上
      context.__mpxProxy.options.computed = context.__mpxProxy.options.computed || {}
      Object.assign(context.__mpxProxy.options.computed, result)
    },
    mapGettersToInstance: (...args) => {
      const { context, restParams } = checkMapInstance(args)
      const result = mapGetters(...restParams)
      context.__mpxProxy.options.computed = context.__mpxProxy.options.computed || {}
      Object.assign(context.__mpxProxy.options.computed, result)
    },
    mapMutationsToInstance: (...args) => {
      const { context, restParams } = checkMapInstance(args)
      const result = mapMutations(...restParams)
      Object.assign(context, result)
    },
    mapActionsToInstance: (...args) => {
      const { context, restParams } = checkMapInstance(args)
      const result = mapActions(...restParams)
      Object.assign(context, result)
    }
  }
}


/***/ }),
/* 42 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "implement": function() { return /* binding */ implement; },
/* harmony export */   "implemented": function() { return /* binding */ implemented; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);


const implemented = {}

function implement (name, { modes = [], processor = _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.noop, remove = false } = {}) {
  if (!name) return
  if (modes.indexOf("web") > -1) {
    processor()
    implemented[name] = {
      remove
    }
  }
}


/***/ }),
/* 43 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ createApp; }
/* harmony export */ });
/* harmony import */ var _core_transferOptions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(47);
/* harmony import */ var _core_mergeOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(64);
/* harmony import */ var _patch_builtInKeysMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _platform_patch_web_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);







const webAppHooksMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(_platform_patch_web_lifecycle__WEBPACK_IMPORTED_MODULE_1__.LIFECYCLE.APP_HOOKS)

function filterOptions (options, appData) {
  const newOptions = {}
  Object.keys(options).forEach(key => {
    if (_patch_builtInKeysMap__WEBPACK_IMPORTED_MODULE_2__["default"][key]) {
      return
    }
    if ( true && !webAppHooksMap[key]) {
      appData[key] = options[key]
    } else {
      newOptions[key] = options[key]
    }
  })
  return newOptions
}

function createApp (option, config = {}) {
  // 在App中挂载mpx对象供周边工具访问，如e2e测试
  const builtInMixins = [{
    getMpx () {
      return _index__WEBPACK_IMPORTED_MODULE_3__["default"]
    }
  }]
  const appData = {}
  if (true) {
    builtInMixins.push({
      created () {
        Object.assign(this, _index__WEBPACK_IMPORTED_MODULE_3__["default"].prototype)
        Object.assign(this, appData)
        const current = (__webpack_require__.g.__mpxRouter && __webpack_require__.g.__mpxRouter.currentRoute) || {}
        const options = {
          path: current.path && current.path.replace(/^\//, ''),
          query: current.query,
          scene: 0,
          shareTicket: '',
          referrerInfo: {}
        }
        this.$options.onLaunch && this.$options.onLaunch.call(this, options)
        __webpack_require__.g.__mpxAppCbs = __webpack_require__.g.__mpxAppCbs || {
          show: [],
          hide: [],
          error: []
        }
        if (this.$options.onShow) {
          this.$options.onShow.call(this, options)
          __webpack_require__.g.__mpxAppCbs.show.push(this.$options.onShow.bind(this))
        }
        if (this.$options.onHide) {
          __webpack_require__.g.__mpxAppCbs.hide.push(this.$options.onHide.bind(this))
        }
        if (this.$options.onError) {
          __webpack_require__.g.__mpxAppCbs.error.push(this.$options.onError.bind(this))
        }
      }
    })
  } else {}
  // app选项目前不需要进行转换
  const { rawOptions } = (0,_core_transferOptions__WEBPACK_IMPORTED_MODULE_4__["default"])(option, 'app', false)
  rawOptions.mixins = builtInMixins
  const defaultOptions = filterOptions((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.spreadProp)((0,_core_mergeOptions__WEBPACK_IMPORTED_MODULE_5__["default"])(rawOptions, 'app', false), 'methods'), appData)

  if (true) {
    __webpack_require__.g.__mpxOptionsMap = __webpack_require__.g.__mpxOptionsMap || {}
    __webpack_require__.g.__mpxOptionsMap[__webpack_require__.g.currentModuleId] = defaultOptions
    __webpack_require__.g.getApp = function () {
      return appData
    }
  } else {}
}


/***/ }),
/* 44 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LIFECYCLE": function() { return /* binding */ LIFECYCLE; }
/* harmony export */ });
const COMPONENT_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'activated',
  'deactivated',
  'beforeDestroy',
  'destroyed',
  'errorCaptured'
]

const PAGE_HOOKS = [
  ...COMPONENT_HOOKS,
  'onLoad',
  'onReady',
  'onShow',
  'onHide',
  'onUnload',
  'onPullDownRefresh',
  'onReachBottom',
  'onPageScroll',
  'onAddToFavorites',
  'onShareAppMessage',
  'onShareTimeline',
  'onResize',
  'onTabItemTap',
  'onSaveExitState'
]

const APP_HOOKS = [
  ...COMPONENT_HOOKS,
  'onLaunch',
  'onShow',
  'onHide',
  'onError',
  'onPageNotFound',
  'onUnhandledRejection',
  'onThemeChange'
]

const LIFECYCLE = {
  APP_HOOKS,
  PAGE_HOOKS,
  COMPONENT_HOOKS
}


/***/ }),
/* 45 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);



let builtInKeys

if (true) {
  builtInKeys = [
    'proto',
    'mixins',
    'mpxCustomKeysForBlend',
    'mpxConvertMode',
    'mpxFileResource',
    '__nativeRender__',
    '__type__',
    '__pageCtor__'
  ]
} else {}

/* harmony default export */ __webpack_exports__["default"] = ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(builtInKeys.concat(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.INNER_LIFECYCLES)));


/***/ }),
/* 46 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BEFORECREATE": function() { return /* binding */ BEFORECREATE; },
/* harmony export */   "BEFOREMOUNT": function() { return /* binding */ BEFOREMOUNT; },
/* harmony export */   "BEFOREUNMOUNT": function() { return /* binding */ BEFOREUNMOUNT; },
/* harmony export */   "BEFOREUPDATE": function() { return /* binding */ BEFOREUPDATE; },
/* harmony export */   "CREATED": function() { return /* binding */ CREATED; },
/* harmony export */   "INNER_LIFECYCLES": function() { return /* binding */ INNER_LIFECYCLES; },
/* harmony export */   "MOUNTED": function() { return /* binding */ MOUNTED; },
/* harmony export */   "ONHIDE": function() { return /* binding */ ONHIDE; },
/* harmony export */   "ONLOAD": function() { return /* binding */ ONLOAD; },
/* harmony export */   "ONRESIZE": function() { return /* binding */ ONRESIZE; },
/* harmony export */   "ONSHOW": function() { return /* binding */ ONSHOW; },
/* harmony export */   "UNMOUNTED": function() { return /* binding */ UNMOUNTED; },
/* harmony export */   "UPDATED": function() { return /* binding */ UPDATED; }
/* harmony export */ });
const BEFORECREATE = '__beforeCreate__'
const CREATED = '__created__'
const BEFOREMOUNT = '__beforeMount__'
const MOUNTED = '__mounted__'
const BEFOREUPDATE = '__beforeUpdate__'
const UPDATED = '__updated__'
const BEFOREUNMOUNT = '__beforeUnmount__'
const UNMOUNTED = '__unmounted__'
const ONLOAD = '__onLoad__'
const ONSHOW = '__onShow__'
const ONHIDE = '__onHide__'
const ONRESIZE = '__onResize__'

const INNER_LIFECYCLES = [
  BEFORECREATE,
  CREATED,
  BEFOREMOUNT,
  MOUNTED,
  BEFOREUPDATE,
  UPDATED,
  BEFOREUNMOUNT,
  UNMOUNTED,
  ONLOAD,
  ONSHOW,
  ONHIDE,
  ONRESIZE
]


/***/ }),
/* 47 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ transferOptions; }
/* harmony export */ });
/* harmony import */ var _injectMixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _mergeOptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(64);
/* harmony import */ var _convertor_getConvertMode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);





function transferOptions (options, type, needConvert = true) {
  let currentInject
  if (__webpack_require__.g.currentInject && __webpack_require__.g.currentInject.moduleId === __webpack_require__.g.currentModuleId) {
    currentInject = __webpack_require__.g.currentInject
  }
  // 文件编译路径
  options.mpxFileResource = __webpack_require__.g.currentResource
  // 注入全局写入的mixins，原生模式下不进行注入
  if (!options.__nativeRender__) {
    options = (0,_injectMixins__WEBPACK_IMPORTED_MODULE_1__.mergeInjectedMixins)(options, type)
  }
  if (currentInject && currentInject.injectComputed) {
    // 编译计算属性注入
    options.computed = Object.assign({}, currentInject.injectComputed, options.computed)
  }
  if (currentInject && currentInject.injectOptions) {
    // 编译option注入,优先微信中的单独配置
    options.options = Object.assign({}, currentInject.injectOptions, options.options)
  }
  if (currentInject && currentInject.pageEvents) {
    options.mixins = options.mixins || []
    // 驱动层视作用户本地逻辑，作为最后的mixin来执行
    options.mixins.push(currentInject.pageEvents)
  }
  // 转换mode
  options.mpxConvertMode = options.mpxConvertMode || (0,_convertor_getConvertMode__WEBPACK_IMPORTED_MODULE_2__.getConvertMode)(__webpack_require__.g.currentSrcMode)
  const rawOptions = (0,_mergeOptions__WEBPACK_IMPORTED_MODULE_3__["default"])(options, type, needConvert)

  if (currentInject && currentInject.propKeys) {
    const computedKeys = Object.keys(rawOptions.computed || {})
    // 头条和百度小程序由于props传递为异步操作，通过props向子组件传递computed数据时，子组件无法在初始时(created/attached)获取到computed数据，如需进一步处理数据建议通过watch获取
    currentInject.propKeys.forEach(key => {
      if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.findItem)(computedKeys, key)) {
        (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`由于平台机制原因，子组件无法在初始时(created/attached)获取到通过props传递的计算属性[${key}]，该问题一般不影响渲染，如需进一步处理数据建议通过watch获取。`, __webpack_require__.g.currentResource)
      }
    })
  }
  return {
    rawOptions,
    currentInject
  }
}


/***/ }),
/* 48 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearInjectMixins": function() { return /* binding */ clearInjectMixins; },
/* harmony export */   "injectMixins": function() { return /* binding */ injectMixins; },
/* harmony export */   "mergeInjectedMixins": function() { return /* binding */ mergeInjectedMixins; }
/* harmony export */ });
/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__);


const mixinsQueueMap = {
  app: [[], []],
  page: [[], []],
  component: [[], []]
}

function clearInjectMixins () {
  mixinsQueueMap.app = [[], []]
  mixinsQueueMap.page = [[], []]
  mixinsQueueMap.component = [[], []]
}

function injectMixins (mixins, options = {}) {
  if (typeof options === 'string' || Array.isArray(options)) {
    options = {
      types: options
    }
  }

  let types = options.types || ['app', 'page', 'component']
  const stage = options.stage || -1

  if (typeof types === 'string') {
    types = [types]
  }

  if (!Array.isArray(mixins)) {
    mixins = [mixins]
  }

  mixins.stage = stage

  types.forEach(type => {
    const mixinsQueue = stage < 0 ? mixinsQueueMap[type][0] : mixinsQueueMap[type][1]
    for (let i = 0; i <= mixinsQueue.length; i++) {
      if (i === mixinsQueue.length) {
        mixinsQueue.push(mixins)
        break
      }
      const item = mixinsQueue[i]
      if (mixins === item) break
      if (stage < item.stage) {
        mixinsQueue.splice(i, 0, mixins)
        break
      }
    }
  })

  return this
}

function mergeInjectedMixins (options, type) {
  const before = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0___default()(mixinsQueueMap[type][0])
  const middle = options.mixins || []
  const after = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0___default()(mixinsQueueMap[type][1])
  const mixins = before.concat(middle).concat(after)
  if (mixins.length) {
    options.mixins = mixins
  }
  return options
}


/***/ }),
/* 49 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseFlatten = __webpack_require__(50);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 50 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayPush = __webpack_require__(51),
    isFlattenable = __webpack_require__(52);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 51 */
/***/ (function(module) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 52 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(53),
    isArguments = __webpack_require__(56),
    isArray = __webpack_require__(62);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 53 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(54);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 54 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var freeGlobal = __webpack_require__(55);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 55 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),
/* 56 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(57),
    isObjectLike = __webpack_require__(61);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 57 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObjectLike = __webpack_require__(61);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 58 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(53),
    getRawTag = __webpack_require__(59),
    objectToString = __webpack_require__(60);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 59 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var Symbol = __webpack_require__(53);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 60 */
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 61 */
/***/ (function(module) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 62 */
/***/ (function(module) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 63 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getConvertMode": function() { return /* binding */ getConvertMode; }
/* harmony export */ });
const convertModes = {
  'wx-ali': 'wxToAli',
  'wx-web': 'wxToWeb',
  'wx-swan': 'wxToSwan',
  'wx-qq': 'wxToQq',
  'wx-tt': 'wxToTt',
  'wx-jd': 'wxToJd',
  'wx-dd': 'wxToDd'
}

function getConvertMode (srcMode) {
  return convertModes[srcMode + '-' + "web"]
}


/***/ }),
/* 64 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ mergeOptions; },
/* harmony export */   "getMixin": function() { return /* binding */ getMixin; },
/* harmony export */   "mergeArray": function() { return /* binding */ mergeArray; },
/* harmony export */   "mergeDefault": function() { return /* binding */ mergeDefault; },
/* harmony export */   "mergeHooks": function() { return /* binding */ mergeHooks; },
/* harmony export */   "mergeShallowObj": function() { return /* binding */ mergeShallowObj; },
/* harmony export */   "mergeToArray": function() { return /* binding */ mergeToArray; }
/* harmony export */ });
/* harmony import */ var _convertor_convertor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65);
/* harmony import */ var _platform_patch_builtInKeysMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _implement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);





let currentHooksMap = {}
let curType
let convertRule
let mpxCustomKeysMap

function mergeOptions (options = {}, type, needConvert) {
  // 缓存混合模式下的自定义属性列表
  mpxCustomKeysMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(options.mpxCustomKeysForBlend || [])
  // needConvert为false，表示衔接原生的root配置，那么此时的配置都是当前原生环境支持的配置，不需要转换
  convertRule = (0,_convertor_convertor__WEBPACK_IMPORTED_MODULE_1__.getConvertRule)(needConvert ? options.mpxConvertMode || 'default' : 'local')
  // 微信小程序使用Component创建page
  if (type === 'page' && convertRule.pageMode) {
    curType = convertRule.pageMode
  } else {
    curType = type
  }
  currentHooksMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(convertRule.lifecycle[curType])
  const newOptions = {}
  extractMixins(newOptions, options, needConvert)
  if (needConvert) {
    proxyHooks(newOptions)
    // 自定义补充转换函数
    typeof convertRule.convert === 'function' && convertRule.convert(newOptions, type)
    // 当存在lifecycle2时，在转换后将currentHooksMap替换，以确保后续合并hooks时转换后的hooks能够被正确处理
    if (convertRule.lifecycle2) {
      const implementedHooks = convertRule.lifecycle[curType].filter((hook) => {
        return _implement__WEBPACK_IMPORTED_MODULE_2__.implemented[hook]
      })
      currentHooksMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(convertRule.lifecycle2[curType].concat(implementedHooks))
    }
  }
  newOptions.mpxCustomKeysForBlend = Object.keys(mpxCustomKeysMap)
  return transformHOOKS(newOptions)
}

function getMixin (mixin = {}) {
  // 用于ts反向推导mixin类型
  return mixin
}

function extractMixins (mergeOptions, options, needConvert) {
  // 如果编译阶段behaviors都被当做mixins处理，那么进行别名替换
  if (options.behaviors && options.behaviors[0] && options.behaviors[0].__mpx_behaviors_to_mixins__) {
    (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.aliasReplace)(options, 'behaviors', 'mixins')
  }
  if (options.mixins) {
    for (const mixin of options.mixins) {
      if (typeof mixin === 'string') {
        (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)('String-formatted builtin behaviors is not supported to be converted to mixins.', options.mpxFileResource)
      } else {
        extractMixins(mergeOptions, mixin, needConvert)
      }
    }
  }
  // 出于业务兼容考虑暂时不移除pageShow/pageHide
  // options = extractPageShow(options)
  options = extractLifetimes(options)
  options = extractPageHooks(options)
  if (needConvert) {
    options = extractObservers(options)
  }
  mergeMixins(mergeOptions, options)
  return mergeOptions
}

// function extractPageShow (options) {
//   if (options.pageShow || options.pageHide) {
//     const mixin = {
//       pageLifetimes: {}
//     }
//     if (options.pageShow) {
//       mixin.pageLifetimes.show = options.pageShow
//       delete options.pageShow
//     }
//     if (options.pageHide) {
//       mixin.pageLifetimes.hide = options.pageHide
//       delete options.pageHide
//     }
//     mergeToArray(options, mixin, 'pageLifetimes')
//   }
//   return options
// }

function extractLifetimes (options) {
  if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(options.lifetimes)) {
    const newOptions = Object.assign({}, options, options.lifetimes)
    delete newOptions.lifetimes
    return newOptions
  } else {
    return options
  }
}

function extractObservers (options) {
  const observers = options.observers
  const props = Object.assign({}, options.properties, options.props)
  const watch = Object.assign({}, options.watch)
  let extract = false

  function mergeWatch (key, config) {
    if (watch[key]) {
      if (!Array.isArray(watch[key])) watch[key] = [watch[key]]
    } else {
      watch[key] = []
    }
    watch[key].push(config)
    extract = true
  }

  Object.keys(props).forEach(key => {
    const prop = props[key]
    if (prop && prop.observer) {
      mergeWatch(key, {
        handler (...rest) {
          let callback = prop.observer
          if (typeof callback === 'string') {
            callback = this[callback]
          }
          typeof callback === 'function' && callback.call(this, ...rest)
        },
        deep: true,
        // 延迟触发首次回调，处理转换支付宝时在observer中查询组件的行为，如vant/picker中，如不考虑该特殊情形可用immediate代替
        immediateAsync: true
      })
    }
  })
  if (observers) {
    Object.keys(observers).forEach(key => {
      const callback = observers[key]
      if (callback) {
        let deep = false
        const propsArr = Object.keys(props)
        const keyPathArr = []
        key.split(',').forEach(item => {
          const result = item.trim()
          result && keyPathArr.push(result)
        })
        // 针对prop的watch都需要立刻执行一次
        let watchProp = false
        for (const prop of propsArr) {
          if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.findItem)(keyPathArr, prop)) {
            watchProp = true
            break
          }
        }
        if (key.indexOf('.**') > -1) {
          deep = true
          key = key.replace('.**', '')
        }
        mergeWatch(key, {
          handler (val, old) {
            let cb = callback
            if (typeof cb === 'string') {
              cb = this[cb]
            }
            if (typeof cb === 'function') {
              if (keyPathArr.length < 2) {
                val = [val]
                old = [old]
              }
              cb.call(this, ...val, ...old)
            }
          },
          deep,
          immediateAsync: watchProp
        })
      }
    })
  }
  if (extract) {
    const newOptions = Object.assign({}, options)
    newOptions.watch = watch
    delete newOptions.observers
    return newOptions
  }
  return options
}

function extractPageHooks (options) {
  if (curType === 'blend') {
    const newOptions = Object.assign({}, options)
    const methods = newOptions.methods
    const pageHooksMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(convertRule.lifecycle.page)
    methods && Object.keys(methods).forEach(key => {
      if (pageHooksMap[key]) {
        if (newOptions[key]) {
          (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Duplicate lifecycle [${key}] is defined in root options and methods, please check.`, options.mpxFileResource)
        }
        newOptions[key] = methods[key]
        delete methods[key]
      }
    })
    return newOptions
  } else {
    return options
  }
}

function mergeMixins (parent, child) {
  for (const key in child) {
    if (currentHooksMap[key]) {
      mergeHooks(parent, child, key)
    } else if (/^(data|dataFn)$/.test(key)) {
      mergeDataFn(parent, child, key)
    } else if (/^(computed|properties|props|methods|proto|options|relations|initData)$/.test(key)) {
      mergeShallowObj(parent, child, key)
    } else if (/^(watch|observers|pageLifetimes|events)$/.test(key)) {
      mergeToArray(parent, child, key)
    } else if (/^behaviors|externalClasses$/.test(key)) {
      mergeArray(parent, child, key)
    } else if (key !== 'mixins' && key !== 'mpxCustomKeysForBlend') {
      // 收集非函数的自定义属性，在Component创建的页面中挂载到this上，模拟Page创建页面的表现，swan当中component构造器也能自动挂载自定义数据，不需要框架模拟挂载
      if (curType === 'blend' && typeof child[key] !== 'function' && !_platform_patch_builtInKeysMap__WEBPACK_IMPORTED_MODULE_3__["default"][key] && "web" !== 'swan') {
        mpxCustomKeysMap[key] = true
      }
      mergeDefault(parent, child, key)
    }
  }
}

function mergeDefault (parent, child, key) {
  parent[key] = child[key]
}

function mergeHooks (parent, child, key) {
  if (parent[key]) {
    parent[key].push(child[key])
  } else {
    parent[key] = [child[key]]
  }
}

function mergeShallowObj (parent, child, key) {
  let parentVal = parent[key]
  const childVal = child[key]
  if (!parentVal) {
    parent[key] = parentVal = {}
  }
  Object.assign(parentVal, childVal)
}

function mergeDataFn (parent, child, key) {
  let parentVal = parent[key]
  const childVal = child[key]

  if (typeof parentVal === 'function' && key === 'data') {
    parent.dataFn = parentVal
    delete parent.data
  }

  if (typeof childVal !== 'function') {
    mergeShallowObj(parent, child, 'data')
  } else {
    parentVal = parent.dataFn
    if (!parentVal) {
      parent.dataFn = childVal
    } else {
      parent.dataFn = function mergeFn () {
        const to = parentVal.call(this)
        const from = childVal.call(this)
        return Object.assign(to, from)
      }
    }
  }
}

function mergeArray (parent, child, key) {
  const childVal = child[key]
  if (!parent[key]) {
    parent[key] = []
  }
  parent[key] = parent[key].concat(childVal)
}

function mergeToArray (parent, child, key) {
  let parentVal = parent[key]
  const childVal = child[key]
  if (!parentVal) {
    parent[key] = parentVal = {}
  }
  Object.keys(childVal).forEach(key => {
    if (key in parentVal) {
      let parent = parentVal[key]
      let child = childVal[key]
      if (!Array.isArray(parent)) {
        parent = [parent]
      }
      if (!Array.isArray(child)) {
        child = [child]
      }
      parentVal[key] = parent.concat(child)
    } else {
      parentVal[key] = Array.isArray(childVal[key]) ? childVal[key] : [childVal[key]]
    }
  })
}

function composeHooks (target, includes) {
  Object.keys(target).forEach(key => {
    if (!includes || includes[key]) {
      const hooksArr = target[key]
      hooksArr && (target[key] = function (...args) {
        let result
        for (let i = 0; i < hooksArr.length; i++) {
          if (typeof hooksArr[i] === 'function') {
            const data = hooksArr[i].apply(this, args)
            data !== undefined && (result = data)
          }
        }
        return result
      })
    }
  })
}

function proxyHooks (options) {
  const lifecycleProxyMap = convertRule.lifecycleProxyMap
  lifecycleProxyMap && Object.keys(lifecycleProxyMap).forEach(key => {
    const newHooks = (options[key] || []).slice()
    const proxyArr = lifecycleProxyMap[key]
    proxyArr && proxyArr.forEach(lifecycle => {
      if (options[lifecycle] && currentHooksMap[lifecycle]) {
        newHooks.push.apply(newHooks, options[lifecycle])
        delete options[lifecycle]
      }
    })
    newHooks.length && (options[key] = newHooks)
  })
}

function transformHOOKS (options) {
  composeHooks(options, currentHooksMap)
  options.pageLifetimes && composeHooks(options.pageLifetimes)
  options.events && composeHooks(options.events)
  if (curType === 'blend' && convertRule.support) {
    const componentHooksMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(convertRule.lifecycle.component)
    for (const key in options) {
      // 使用Component创建page实例，页面专属生命周期&自定义方法需写在methods内部
      if (typeof options[key] === 'function' && key !== 'dataFn' && key !== 'setup' && !componentHooksMap[key]) {
        if (!options.methods) options.methods = {}
        options.methods[key] = options[key]
        delete options[key]
      }
    }
  }
  return options
}


/***/ }),
/* 65 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getConvertRule": function() { return /* binding */ getConvertRule; }
/* harmony export */ });
/* harmony import */ var _platform_patch_web_lifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);
/* harmony import */ var _mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _wxToAli__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69);
/* harmony import */ var _wxToWeb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67);
/* harmony import */ var _wxToSwan__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71);
/* harmony import */ var _wxToQq__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(73);
/* harmony import */ var _wxToTt__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(74);
/* harmony import */ var _wxToDd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(75);
/* harmony import */ var _wxToJd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(76);














// 根据当前环境获取的默认生命周期信息
let lifecycleInfo
let pageMode

if (true) {
  lifecycleInfo = _platform_patch_web_lifecycle__WEBPACK_IMPORTED_MODULE_1__
  pageMode = ''
} else {}

/**
 * 转换规则包含四点
 * lifecycle [object] 生命周期
 * lifecycleProxyMap [object] 代理规则
 * pageMode [string] 页面生命周期合并模式，是否为blend
 * support [boolean]当前平台是否支持blend
 * convert [function] 自定义转换函数, 接收一个options
 */
const defaultConvertRule = {
  lifecycle: (0,_mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__.mergeLifecycle)(lifecycleInfo.LIFECYCLE),
  lifecycleProxyMap: lifecycleInfo.lifecycleProxyMap,
  pageMode,
  support: !!pageMode,
  convert: null
}

const rulesMap = {
  local: { ...defaultConvertRule },
  default: defaultConvertRule,
  wxToWeb: _wxToWeb__WEBPACK_IMPORTED_MODULE_3__["default"],
  wxToAli: _wxToAli__WEBPACK_IMPORTED_MODULE_4__["default"],
  wxToSwan: _wxToSwan__WEBPACK_IMPORTED_MODULE_5__["default"],
  wxToQq: { ...defaultConvertRule, ..._wxToQq__WEBPACK_IMPORTED_MODULE_6__["default"] },
  wxToTt: { ...defaultConvertRule, ..._wxToTt__WEBPACK_IMPORTED_MODULE_7__["default"] },
  wxToDd: { ...defaultConvertRule, ..._wxToDd__WEBPACK_IMPORTED_MODULE_8__["default"] },
  wxToJd: { ...defaultConvertRule, ..._wxToJd__WEBPACK_IMPORTED_MODULE_9__["default"] }
}

function getConvertRule (convertMode) {
  const rule = rulesMap[convertMode]
  if (!rule || !rule.lifecycle) {
    (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`Absence of convert rule for ${convertMode}, please check.`)
  } else {
    return rule
  }
}


/***/ }),
/* 66 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeLifecycle": function() { return /* binding */ mergeLifecycle; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);


function mergeLifecycle (lifecycle) {
  if (lifecycle) {
    const appHooks = (lifecycle.APP_HOOKS || []).concat(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.INNER_LIFECYCLES)
    const pageHooks = (lifecycle.PAGE_HOOKS || []).concat(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.INNER_LIFECYCLES)
    const componentHooks = (lifecycle.COMPONENT_HOOKS || []).concat(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.INNER_LIFECYCLES)
    return {
      app: appHooks,
      page: pageHooks,
      component: componentHooks,
      blend: pageHooks.concat(lifecycle.COMPONENT_HOOKS || [])
    }
  }
}


/***/ }),
/* 67 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _platform_patch_web_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var _mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _core_implement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);






// 暂不支持的wx选项，后期需要各种花式支持
const unsupported = ['moved', 'definitionFilter', 'onShareAppMessage']

function convertErrorDesc (key) {
  ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`Options.${key} is not supported in runtime conversion from wx to web.`, __webpack_require__.g.currentResource)
}

function notSupportTip (options) {
  unsupported.forEach(key => {
    if (options[key]) {
      if (!_core_implement__WEBPACK_IMPORTED_MODULE_1__.implemented[key]) {
        _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev && convertErrorDesc(key)
        delete options[key]
      } else if (_core_implement__WEBPACK_IMPORTED_MODULE_1__.implemented[key].remove) {
        delete options[key]
      }
    }
  })
}

/* harmony default export */ __webpack_exports__["default"] = ({
  lifecycle: (0,_mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__.mergeLifecycle)(_platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__.LIFECYCLE),
  lifecycle2: (0,_mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__.mergeLifecycle)(_platform_patch_web_lifecycle__WEBPACK_IMPORTED_MODULE_4__.LIFECYCLE),
  pageMode: 'blend',
  support: true,
  lifecycleProxyMap: _platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__.lifecycleProxyMap,
  convert (options) {
    const props = Object.assign({}, options.properties, options.props)
    if (props) {
      Object.keys(props).forEach(key => {
        const prop = props[key]
        if (prop) {
          if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(prop, 'type')) {
            const newProp = {}
            if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(prop, 'optionalTypes')) {
              newProp.type = [prop.type, ...prop.optionalTypes]
            } else {
              newProp.type = prop.type
            }
            if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(prop, 'value')) {
              // vue中对于引用类型数据需要使用函数返回
              newProp.default = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(prop.value)
                ? function propFn () {
                  return (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(prop.value).clone
                }
                : prop.value
            }
            props[key] = newProp
          } else {
            props[key] = prop
          }
        }
      })
      options.props = props
      delete options.properties
    }
    notSupportTip(options)
  }
});


/***/ }),
/* 68 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LIFECYCLE": function() { return /* binding */ LIFECYCLE; },
/* harmony export */   "lifecycleProxyMap": function() { return /* binding */ lifecycleProxyMap; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);


const APP_HOOKS = [
  'onLaunch',
  'onShow',
  'onHide',
  'onError',
  'onPageNotFound',
  'onUnhandledRejection',
  'onThemeChange'
]

const PAGE_HOOKS = [
  'onLoad',
  'onReady',
  'onShow',
  'onHide',
  'onUnload',
  'onPullDownRefresh',
  'onReachBottom',
  'onPageScroll',
  'onAddToFavorites',
  'onShareAppMessage',
  'onShareTimeline',
  'onResize',
  'onTabItemTap',
  'onSaveExitState'
]

const COMPONENT_HOOKS = [
  'created',
  'attached',
  'ready',
  'moved',
  'detached',
  'pageShow',
  'pageHide'
]

const lifecycleProxyMap = {
  // 类微信平台中onLoad不能代理到CREATED上，否则Component构造页面时无法获取页面参数
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.CREATED]: ['created', 'attached'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.MOUNTED]: ['ready', 'onReady'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.UNMOUNTED]: ['detached', 'onUnload'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONSHOW]: ['pageShow', 'onShow'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONHIDE]: ['pageHide', 'onHide'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONLOAD]: ['onLoad']
}

const LIFECYCLE = {
  APP_HOOKS,
  PAGE_HOOKS,
  COMPONENT_HOOKS
}


/***/ }),
/* 69 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _platform_patch_ali_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70);
/* harmony import */ var _mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _core_mergeOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(64);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _core_implement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);







const unsupported = ['moved', 'definitionFilter']

function convertErrorDesc (key) {
  ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`Options.${key} is not supported in runtime conversion from wx to ali.`, __webpack_require__.g.currentResource)
}

function notSupportTip (options) {
  unsupported.forEach(key => {
    if (options[key]) {
      if (!_core_implement__WEBPACK_IMPORTED_MODULE_1__.implemented[key]) {
        _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev && convertErrorDesc(key)
        delete options[key]
      } else if (_core_implement__WEBPACK_IMPORTED_MODULE_1__.implemented[key].remove) {
        delete options[key]
      }
    }
  })
  // relations部分支持
  const relations = options.relations
  if (relations) {
    Object.keys(relations).forEach(path => {
      const item = relations[path]
      if (item.target) {
        convertErrorDesc('relations > target')
      }
      if (item.linkChanged) {
        convertErrorDesc('relations > linkChanged')
      }
    })
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  lifecycle: (0,_mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__.mergeLifecycle)(_platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__.LIFECYCLE),
  lifecycle2: (0,_mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__.mergeLifecycle)(_platform_patch_ali_lifecycle__WEBPACK_IMPORTED_MODULE_4__.LIFECYCLE),
  pageMode: 'blend',
  support: false,
  lifecycleProxyMap: _platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__.lifecycleProxyMap,
  convert (options) {
    const props = Object.assign({}, options.properties, options.props)
    if (props) {
      Object.keys(props).forEach(key => {
        const prop = props[key]
        if (prop) {
          if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(prop, 'value')) {
            props[key] = prop.value
          } else {
            const type = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(prop, 'type') ? prop.type : prop
            if (typeof type === 'function') props[key] = type()
          }
        }
      })
      options.props = props
      delete options.properties
    }
    if (options.onResize) {
      (0,_core_mergeOptions__WEBPACK_IMPORTED_MODULE_5__.mergeToArray)(options, {
        events: {
          onResize: options.onResize
        }
      }, 'events')
      delete options.onResize
    }
    notSupportTip(options)
  }
});


/***/ }),
/* 70 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LIFECYCLE": function() { return /* binding */ LIFECYCLE; },
/* harmony export */   "lifecycleProxyMap": function() { return /* binding */ lifecycleProxyMap; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);


const APP_HOOKS = [
  'onLaunch',
  'onShow',
  'onHide',
  'onError',
  'onShareAppMessage',
  'onUnhandledRejection',
  'onPageNotFound'
]

const PAGE_HOOKS = [
  'onLoad',
  'onReady',
  'onShow',
  'onHide',
  'onUnload',
  'onShareAppMessage',
  'onTitleClick',
  'onOptionMenuClick',
  'onPullDownRefresh',
  'onTabItemTap',
  'onPageScroll',
  'onReachBottom'
]

const COMPONENT_HOOKS = [
  'onInit',
  'deriveDataFromProps',
  'didMount',
  'didUpdate',
  'didUnmount',
  'onError',
  'pageShow',
  'pageHide'
]

const lifecycleProxyMap = {
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.CREATED]: ['onInit'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.UPDATED]: ['didUpdate'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.MOUNTED]: ['didMount', 'onReady'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.UNMOUNTED]: ['didUnmount', 'onUnload'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONSHOW]: ['pageShow', 'onShow'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONHIDE]: ['pageHide', 'onHide'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONLOAD]: ['onLoad']
}

const LIFECYCLE = {
  APP_HOOKS,
  PAGE_HOOKS,
  COMPONENT_HOOKS
}


/***/ }),
/* 71 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _core_implement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _platform_patch_swan_lifecycle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(72);






const BEHAVIORS_MAP = {
  'wx://form-field': 'swan://form-field',
  'wx://component-export': 'swan://component-export'
}

const unsupported = ['moved', 'relations']

function convertErrorDesc (key) {
  ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`Options.${key} is not supported in runtime conversion from wx to swan.`, __webpack_require__.g.currentResource)
}

function notSupportTip (options) {
  unsupported.forEach(key => {
    if (options[key]) {
      if (!_core_implement__WEBPACK_IMPORTED_MODULE_1__.implemented[key]) {
        _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev && convertErrorDesc(key)
        delete options[key]
      } else if (_core_implement__WEBPACK_IMPORTED_MODULE_1__.implemented[key].remove) {
        delete options[key]
      }
    }
  })
}

/* harmony default export */ __webpack_exports__["default"] = ({
  lifecycle: (0,_mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__.mergeLifecycle)(_platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__.LIFECYCLE),
  lifecycle2: (0,_mergeLifecycle__WEBPACK_IMPORTED_MODULE_2__.mergeLifecycle)(_platform_patch_swan_lifecycle__WEBPACK_IMPORTED_MODULE_4__.LIFECYCLE),
  pageMode: 'blend',
  support: true,
  lifecycleProxyMap: _platform_patch_wx_lifecycle__WEBPACK_IMPORTED_MODULE_3__.lifecycleProxyMap,
  convert (options, type) {
    if (options.behaviors) {
      options.behaviors.forEach((behavior, idx) => {
        if (typeof behavior === 'string' && BEHAVIORS_MAP[behavior]) {
          options.behaviors.splice(idx, 1, BEHAVIORS_MAP[behavior])
        }
      })
    }
    if (type === 'page' && !options.__pageCtor__) {
      options.options = options.options || {}
      options.options.addGlobalClass = true
    }
    notSupportTip(options)
  }
});


/***/ }),
/* 72 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LIFECYCLE": function() { return /* binding */ LIFECYCLE; },
/* harmony export */   "lifecycleProxyMap": function() { return /* binding */ lifecycleProxyMap; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);


const APP_HOOKS = [
  'onLogin',
  'onLaunch',
  'onShow',
  'onHide',
  'onError',
  'onPageNotFound'
]

const PAGE_HOOKS = [
  'onInit',
  'onLoad',
  'onReady',
  'onShow',
  'onHide',
  'onUnload',
  'onPullDownRefresh',
  'onReachBottom',
  'onPageScroll',
  'onShareAppMessage',
  'onTabItemTap',
  'onURLQueryChange',
  'onResize'
]

const COMPONENT_HOOKS = [
  'created',
  'attached',
  'ready',
  'detached',
  'pageShow',
  'pageHide'
]

const lifecycleProxyMap = {
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.CREATED]: ['onInit', 'created', 'attached'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.MOUNTED]: ['ready', 'onReady'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.UNMOUNTED]: ['detached', 'onUnload'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONSHOW]: ['pageShow', 'onShow'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONHIDE]: ['pageHide', 'onHide'],
  [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.ONLOAD]: ['onLoad']
}

const LIFECYCLE = {
  APP_HOOKS,
  PAGE_HOOKS,
  COMPONENT_HOOKS
}


/***/ }),
/* 73 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const BEHAVIORS_MAP = {
  'wx://form-field': 'qq://form-field',
  'wx://component-export': 'qq://component-export'
}

/* harmony default export */ __webpack_exports__["default"] = ({
  convert (options) {
    if (options.behaviors) {
      options.behaviors.forEach((behavior, idx) => {
        if (typeof behavior === 'string' && BEHAVIORS_MAP[behavior]) {
          options.behaviors.splice(idx, 1, BEHAVIORS_MAP[behavior])
        }
      })
    }
  }
});


/***/ }),
/* 74 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);


const BEHAVIORS_MAP = [
  'wx://form-field',
  'wx://form-field-group',
  'wx://form-field-button',
  'wx://component-export'
]

/* harmony default export */ __webpack_exports__["default"] = ({
  convert (options) {
    if (options.behaviors) {
      options.behaviors.forEach((behavior, idx) => {
        if (BEHAVIORS_MAP.includes(behavior)) {
          (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`Built-in behavior "${behavior}" is not supported in tt environment!`, __webpack_require__.g.currentResource)
          options.behaviors.splice(idx, 1)
        }
      })
    }
  }
});


/***/ }),
/* 75 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const BEHAVIORS_MAP = {
  'wx://form-field': 'dd://form-field',
  'wx://component-export': 'dd://component-export'
}

/* harmony default export */ __webpack_exports__["default"] = ({
  convert (options) {
    if (options.behaviors) {
      options.behaviors.forEach((behavior, idx) => {
        if (typeof behavior === 'string' && BEHAVIORS_MAP[behavior]) {
          options.behaviors.splice(idx, 1, BEHAVIORS_MAP[behavior])
        }
      })
    }
  }
});


/***/ }),
/* 76 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const BEHAVIORS_MAP = {
  'wx://form-field': 'jd://form-field',
  'wx://component-export': 'jd://component-export'
}

/* harmony default export */ __webpack_exports__["default"] = ({
  convert (options) {
    if (options.behaviors) {
      options.behaviors.forEach((behavior, idx) => {
        if (typeof behavior === 'string' && BEHAVIORS_MAP[behavior]) {
          options.behaviors.splice(idx, 1, BEHAVIORS_MAP[behavior])
        }
      })
    }
  }
});


/***/ }),
/* 77 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);


/* harmony default export */ __webpack_exports__["default"] = ((0,_patch__WEBPACK_IMPORTED_MODULE_0__["default"])('page'));


/***/ }),
/* 78 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ createFactory; }
/* harmony export */ });
/* harmony import */ var _core_transferOptions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47);
/* harmony import */ var _builtInMixins_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _web_getDefaultOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);








function createFactory (type) {
  return (options = {}, { isNative, customCtor, customCtorType } = {}) => {
    options.__nativeRender__ = !!isNative
    options.__type__ = type
    let ctor
    if (false) {}

    let getDefaultOptions
    if (true) {
      getDefaultOptions = _web_getDefaultOptions__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions
    } else {}

    const { setup } = options
    const { rawOptions, currentInject } = (0,_core_transferOptions__WEBPACK_IMPORTED_MODULE_2__["default"])(options, type)
    rawOptions.setup = setup
    // 不接受mixin中的setup配置
    // 注入内建的mixins, 内建mixin是按原始平台编写的，所以合并规则和rootMixins保持一致
    // 将合并后的用户定义的rawOptions传入获取当前应该注入的内建mixins
    rawOptions.mixins = (0,_builtInMixins_index__WEBPACK_IMPORTED_MODULE_3__["default"])(rawOptions, type)
    const defaultOptions = getDefaultOptions(type, { rawOptions, currentInject })
    if (true) {
      __webpack_require__.g.__mpxOptionsMap = __webpack_require__.g.__mpxOptionsMap || {}
      __webpack_require__.g.__mpxOptionsMap[__webpack_require__.g.currentModuleId] = defaultOptions
    } else {}
  }
}


/***/ }),
/* 79 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultOptions": function() { return /* binding */ getDefaultOptions; }
/* harmony export */ });
/* harmony import */ var _builtInKeysMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _core_mergeOptions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(64);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _export_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15);
/* harmony import */ var _core_proxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46);







function filterOptions (options) {
  const newOptions = {}
  Object.keys(options).forEach(key => {
    if (_builtInKeysMap__WEBPACK_IMPORTED_MODULE_1__["default"][key]) {
      return
    }
    if (key === 'data' || key === 'dataFn') {
      if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(newOptions, 'data')) {
        newOptions.data = function mergeFn () {
          return Object.assign(
            (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(options.data || {}).clone,
            options.dataFn && options.dataFn.call(this)
          )
        }
      }
    } else {
      newOptions[key] = options[key]
    }
  })
  return newOptions
}

function initProxy (context, rawOptions) {
  if (!context.__mpxProxy) {
    context.__mpxProxy = new _core_proxy__WEBPACK_IMPORTED_MODULE_2__["default"](rawOptions, context)
    context.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_3__.BEFORECREATE)
  } else if (context.__mpxProxy.isUnmounted()) {
    context.__mpxProxy = new _core_proxy__WEBPACK_IMPORTED_MODULE_2__["default"](rawOptions, context, true)
    context.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_3__.BEFORECREATE)
  }
}

function getDefaultOptions (type, { rawOptions = {} }) {
  const rawSetup = rawOptions.setup
  if (rawSetup) {
    rawOptions.setup = (props) => {
      const instance = (0,_export_index__WEBPACK_IMPORTED_MODULE_4__.getCurrentInstance)().proxy
      initProxy(instance, rawOptions)
      ;(0,_core_proxy__WEBPACK_IMPORTED_MODULE_2__.setCurrentInstance)(instance.__mpxProxy)
      const newContext = {
        triggerEvent: instance.triggerEvent.bind(instance),
        refs: instance.$refs,
        forceUpdate: instance.$forceUpdate.bind(instance),
        selectComponent: instance.selectComponent.bind(instance),
        selectAllComponents: instance.selectAllComponents.bind(instance),
        createSelectorQuery: instance.createSelectorQuery.bind(instance),
        createIntersectionObserver: instance.createIntersectionObserver.bind(instance)
      }
      const setupRes = rawSetup(props, newContext)
      ;(0,_core_proxy__WEBPACK_IMPORTED_MODULE_2__.unsetCurrentInstance)(instance.__mpxProxy)
      return setupRes
    }
  }
  const rootMixins = [{
    beforeCreate () {
      initProxy(this, rawOptions)
    },
    created () {
      if (this.__mpxProxy) this.__mpxProxy.created()
    },
    mounted () {
      if (this.__mpxProxy) this.__mpxProxy.mounted()
    },
    beforeUpdate () {
      if (this.__mpxProxy) this.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_3__.BEFOREUPDATE)
    },
    updated () {
      if (this.__mpxProxy) this.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_3__.UPDATED)
    },
    beforeDestroy () {
      if (this.__mpxProxy) this.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_3__.BEFOREUNMOUNT)
    },
    destroyed () {
      if (this.__mpxProxy) this.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_3__.UNMOUNTED)
    }
  }]
  // 为了在builtMixin中可以使用某些rootMixin实现的特性（如数据响应等），此处builtInMixin在rootMixin之后执行，但是当builtInMixin使用存在对应内建生命周期的目标平台声明周期写法时，可能会出现用户生命周期比builtInMixin中的生命周期先执行的情况，为了避免这种情况发生，builtInMixin应该尽可能使用内建生命周期来编写
  rawOptions.mixins = rawOptions.mixins ? rootMixins.concat(rawOptions.mixins) : rootMixins
  rawOptions = (0,_core_mergeOptions__WEBPACK_IMPORTED_MODULE_5__["default"])(rawOptions, type, false)
  return filterOptions(rawOptions)
}


/***/ }),
/* 80 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createHook": function() { return /* binding */ createHook; },
/* harmony export */   "currentInstance": function() { return /* binding */ currentInstance; },
/* harmony export */   "default": function() { return /* binding */ MpxProxy; },
/* harmony export */   "getCurrentInstance": function() { return /* binding */ getCurrentInstance; },
/* harmony export */   "injectHook": function() { return /* binding */ injectHook; },
/* harmony export */   "onAddToFavorites": function() { return /* binding */ onAddToFavorites; },
/* harmony export */   "onBeforeMount": function() { return /* binding */ onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* binding */ onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* binding */ onBeforeUpdate; },
/* harmony export */   "onHide": function() { return /* binding */ onHide; },
/* harmony export */   "onLoad": function() { return /* binding */ onLoad; },
/* harmony export */   "onMounted": function() { return /* binding */ onMounted; },
/* harmony export */   "onPageScroll": function() { return /* binding */ onPageScroll; },
/* harmony export */   "onPullDownRefresh": function() { return /* binding */ onPullDownRefresh; },
/* harmony export */   "onReachBottom": function() { return /* binding */ onReachBottom; },
/* harmony export */   "onResize": function() { return /* binding */ onResize; },
/* harmony export */   "onSaveExitState": function() { return /* binding */ onSaveExitState; },
/* harmony export */   "onShareAppMessage": function() { return /* binding */ onShareAppMessage; },
/* harmony export */   "onShareTimeline": function() { return /* binding */ onShareTimeline; },
/* harmony export */   "onShow": function() { return /* binding */ onShow; },
/* harmony export */   "onTabItemTap": function() { return /* binding */ onTabItemTap; },
/* harmony export */   "onUnmounted": function() { return /* binding */ onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* binding */ onUpdated; },
/* harmony export */   "setCurrentInstance": function() { return /* binding */ setCurrentInstance; },
/* harmony export */   "unsetCurrentInstance": function() { return /* binding */ unsetCurrentInstance; }
/* harmony export */ });
/* harmony import */ var _observer_reactive__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(82);
/* harmony import */ var _observer_effect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(88);
/* harmony import */ var _observer_watch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(90);
/* harmony import */ var _observer_computed__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(87);
/* harmony import */ var _observer_scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);










let uid = 0

class RenderTask {
  resolved = false

  constructor (instance) {
    instance.currentRenderTask = this
    this.promise = new Promise((resolve) => {
      this.resolve = resolve
    }).then(() => {
      this.resolved = true
    })
  }
}

/**
 * process renderData, remove sub node if visit parent node already
 * @param {Object} renderData
 * @return {Object} processedRenderData
 */
function preProcessRenderData (renderData) {
  // method for get key path array
  const processKeyPathMap = (keyPathMap) => {
    const keyPath = Object.keys(keyPathMap)
    return keyPath.filter((keyA) => {
      return keyPath.every((keyB) => {
        if (keyA.startsWith(keyB) && keyA !== keyB) {
          const nextChar = keyA[keyB.length]
          if (nextChar === '.' || nextChar === '[') {
            return false
          }
        }
        return true
      })
    })
  }

  const processedRenderData = {}
  const renderDataFinalKey = processKeyPathMap(renderData)
  Object.keys(renderData).forEach(item => {
    if (renderDataFinalKey.indexOf(item) > -1) {
      processedRenderData[item] = renderData[item]
    }
  })
  return processedRenderData
}

class MpxProxy {
  constructor (options, target, reCreated) {
    this.target = target
    this.reCreated = reCreated
    this.uid = uid++
    this.name = options.name || ''
    this.options = options
    // beforeCreate -> created -> mounted -> unmounted
    this.state = _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFORECREATE
    this.ignoreProxyMap = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.makeMap)(_index__WEBPACK_IMPORTED_MODULE_2__["default"].config.ignoreProxyWhiteList)
    // 收集setup中动态注册的hooks，小程序与web环境都需要
    this.hooks = {}
    if (false) {}
    this.initApi()
  }

  created () {
    if (false) {}

    this.state = _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.CREATED
    this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.CREATED)

    if (false) {}

    if (this.reCreated) {
      (0,_observer_scheduler__WEBPACK_IMPORTED_MODULE_3__.nextTick)(this.mounted.bind(this))
    }
  }

  createRenderTask (isEmptyRender) {
    if ((!this.isMounted() && this.currentRenderTask) || (this.isMounted() && isEmptyRender)) {
      return
    }
    return new RenderTask(this)
  }

  isMounted () {
    return this.state === _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.MOUNTED
  }

  mounted () {
    if (this.state === _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.CREATED) {
      this.state = _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.MOUNTED
      // 用于处理refs等前置工作
      this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREMOUNT)
      this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.MOUNTED)
      this.currentRenderTask && this.currentRenderTask.resolve()
    }
  }

  propsUpdated () {
    const updateJob = this.updateJob || (this.updateJob = () => {
      // 只有当前没有渲染任务时，属性更新才需要单独触发updated，否则可以由渲染任务触发updated
      if (this.currentRenderTask?.resolved && this.isMounted()) {
        this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREUPDATE)
        this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UPDATED)
      }
    })
    ;(0,_observer_scheduler__WEBPACK_IMPORTED_MODULE_3__.nextTick)(updateJob)
  }

  unmounted () {
    this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREUNMOUNT)
    this.scope?.stop()
    this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UNMOUNTED)
    this.state = _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UNMOUNTED
  }

  isUnmounted () {
    return this.state === _innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UNMOUNTED
  }

  createProxyConflictHandler (owner) {
    return (key) => {
      if (this.ignoreProxyMap[key]) {
        !this.reCreated && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`The ${owner} key [${key}] is a reserved keyword of miniprogram, please check and rename it.`, this.options.mpxFileResource)
        return false
      }
      !this.reCreated && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`The ${owner} key [${key}] exist in the current instance already, please check and rename it.`, this.options.mpxFileResource)
    }
  }

  initApi () {
    // 挂载扩展属性到实例上
    (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.target, _index__WEBPACK_IMPORTED_MODULE_2__["default"].prototype, undefined, true, this.createProxyConflictHandler('mpx.prototype'))
    // 挂载混合模式下createPage中的自定义属性，模拟原生Page构造器的表现
    if (this.options.__type__ === 'page' && !this.options.__pageCtor__) {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.target, this.options, this.options.mpxCustomKeysForBlend, false, this.createProxyConflictHandler('page options'))
    }
    // 挂载$rawOptions
    this.target.$rawOptions = this.options
    if (false) {}
  }

  initProps () {
    this.props = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(this.target.__getProps(this.options)).clone
    ;(0,_observer_reactive__WEBPACK_IMPORTED_MODULE_4__.reactive)(this.props)
    ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.target, this.props, undefined, false, this.createProxyConflictHandler('props'))
  }

  initSetup () {
    const setup = this.options.setup
    if (setup) {
      const setupResult = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(setup, this, 'setup function', [
        this.props,
        {
          triggerEvent: this.target.triggerEvent.bind(this.target),
          refs: this.target.$refs,
          asyncRefs: this.target.$asyncRefs,
          forceUpdate: this.forceUpdate.bind(this),
          selectComponent: this.target.selectComponent.bind(this.target),
          selectAllComponents: this.target.selectAllComponents.bind(this.target),
          createSelectorQuery: this.target.createSelectorQuery.bind(this.target),
          createIntersectionObserver: this.target.createIntersectionObserver.bind(this.target)
        }
      ])
      if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(setupResult)) {
        (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)(`Setup() should return a object, received: ${(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.type)(setupResult)}.`, this.options.mpxFileResource)
        return
      }
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.target, setupResult, undefined, false, this.createProxyConflictHandler('setup result'))
      this.collectLocalKeys(setupResult, (key, val) => !(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(val))
    }
  }

  initData () {
    const data = this.options.data
    const dataFn = this.options.dataFn
    // 之所以没有直接使用initialData，而是通过对原始dataOpt进行深clone获取初始数据对象，主要是为了避免小程序自身序列化时错误地转换数据对象，比如将promise转为普通object
    this.data = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(data || {}).clone
    // 执行dataFn
    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(dataFn)) {
      Object.assign(this.data, (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(dataFn.bind(this.target), this, 'data function'))
    }
    (0,_observer_reactive__WEBPACK_IMPORTED_MODULE_4__.reactive)(this.data)
    ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.target, this.data, undefined, false, this.createProxyConflictHandler('data'))
    this.collectLocalKeys(this.data)
  }

  initComputed () {
    const computedOpt = this.options.computed
    if (computedOpt) {
      const computedObj = {}
      Object.entries(computedOpt).forEach(([key, opt]) => {
        const get = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(opt)
          ? opt.bind(this.target)
          : (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(opt.get)
            ? opt.get.bind(this.target)
            : _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.noop

        const set = !(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(opt) && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(opt.set)
          ? opt.set.bind(this.target)
          : () => (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Write operation failed: computed property "${key}" is readonly.`, this.options.mpxFileResource)

        computedObj[key] = (0,_observer_computed__WEBPACK_IMPORTED_MODULE_5__.computed)({ get, set })
      })
      this.collectLocalKeys(computedObj)
      ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.proxy)(this.target, computedObj, undefined, false, this.createProxyConflictHandler('computed'))
    }
  }

  initWatch () {
    const watch = this.options.watch
    if (watch) {
      Object.entries(watch).forEach(([key, handler]) => {
        if (Array.isArray(handler)) {
          for (let i = 0; i < handler.length; i++) {
            this.watch(key, handler[i])
          }
        } else {
          this.watch(key, handler)
        }
      })
    }
  }

  watch (source, cb, options) {
    const target = this.target
    const getter = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(source)
      ? () => (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getByPath)(target, source)
      : source.bind(target)

    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(cb)) {
      options = cb
      cb = cb.handler
    }

    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(cb) && target[cb]) {
      cb = target[cb]
    }

    cb = cb || _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.noop

    const cur = currentInstance
    setCurrentInstance(this)

    const res = (0,_observer_watch__WEBPACK_IMPORTED_MODULE_6__.watch)(getter, cb.bind(target), options)

    if (cur) setCurrentInstance(cur)
    else unsetCurrentInstance()

    return res
  }

  collectLocalKeys (data, filter = () => true) {
    Object.keys(data).filter((key) => filter(key, data[key])).forEach((key) => {
      this.localKeysMap[key] = true
    })
  }

  callHook (hookName, params, hooksOnly) {
    const hook = this.options[hookName]
    const hooks = this.hooks[hookName] || []
    let result
    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(hook) && !hooksOnly) {
      result = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(hook.bind(this.target), this, `${hookName} hook`, params)
    }
    hooks.forEach((hook) => {
      result = params ? hook(...params) : hook()
    })
    return result
  }

  hasHook (hookName) {
    return !!(this.options[hookName] || this.hooks[hookName])
  }

  render () {
    const renderData = {}
    Object.keys(this.localKeysMap).forEach((key) => {
      renderData[key] = this.target[key]
    })
    this.doRender(this.processRenderDataWithStrictDiff(renderData))
  }

  renderWithData () {
    const renderData = preProcessRenderData(this.renderData)
    this.doRender(this.processRenderDataWithStrictDiff(renderData))
    // 重置renderData准备下次收集
    this.renderData = {}
  }

  processRenderDataWithDiffData (result, key, diffData) {
    Object.keys(diffData).forEach((subKey) => {
      result[key + subKey] = diffData[subKey]
    })
  }

  processRenderDataWithStrictDiff (renderData) {
    const result = {}
    for (const key in renderData) {
      if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(renderData, key)) {
        const data = renderData[key]
        const firstKey = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getFirstKey)(key)
        if (!this.localKeysMap[firstKey]) {
          continue
        }
        // 外部clone，用于只需要clone的场景
        let clone
        if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(this.miniRenderData, key)) {
          const { clone: localClone, diff, diffData } = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(data, this.miniRenderData[key])
          clone = localClone
          if (diff) {
            this.miniRenderData[key] = clone
            if (diffData && _index__WEBPACK_IMPORTED_MODULE_2__["default"].config.useStrictDiff) {
              this.processRenderDataWithDiffData(result, key, diffData)
            } else {
              result[key] = clone
            }
          }
        } else {
          let processed = false
          const miniRenderDataKeys = Object.keys(this.miniRenderData)
          for (let i = 0; i < miniRenderDataKeys.length; i++) {
            const tarKey = miniRenderDataKeys[i]
            if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.aIsSubPathOfB)(tarKey, key)) {
              if (!clone) clone = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(data).clone
              delete this.miniRenderData[tarKey]
              this.miniRenderData[key] = result[key] = clone
              processed = true
              continue
            }
            const subPath = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.aIsSubPathOfB)(key, tarKey)
            if (subPath) {
              // setByPath 更新miniRenderData中的子数据
              (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.doGetByPath)(this.miniRenderData[tarKey], subPath, (current, subKey, meta) => {
                if (meta.isEnd) {
                  const { clone, diff, diffData } = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(data, current[subKey])
                  if (diff) {
                    current[subKey] = clone
                    if (diffData && _index__WEBPACK_IMPORTED_MODULE_2__["default"].config.useStrictDiff) {
                      this.processRenderDataWithDiffData(result, key, diffData)
                    } else {
                      result[key] = clone
                    }
                  }
                } else if (!current[subKey]) {
                  current[subKey] = {}
                }
                return current[subKey]
              })
              processed = true
              break
            }
          }
          if (!processed) {
            // 如果当前数据和上次的miniRenderData完全无关，但存在于组件的视图数据中，则与组件视图数据进行diff
            if (this.target.data && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(this.target.data, firstKey)) {
              const localInitialData = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getByPath)(this.target.data, key)
              const { clone, diff, diffData } = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(data, localInitialData)
              this.miniRenderData[key] = clone
              if (diff) {
                if (diffData && _index__WEBPACK_IMPORTED_MODULE_2__["default"].config.useStrictDiff) {
                  this.processRenderDataWithDiffData(result, key, diffData)
                } else {
                  result[key] = clone
                }
              }
            } else {
              if (!clone) clone = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(data).clone
              this.miniRenderData[key] = result[key] = clone
            }
          }
        }
        if (this.forceUpdateAll) {
          if (!clone) clone = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(data).clone
          this.forceUpdateData[key] = clone
        }
      }
    }
    return result
  }

  doRender (data, cb) {
    if (typeof this.target.__render !== 'function') {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)('Please specify a [__render] function to render view.', this.options.mpxFileResource)
      return
    }
    if (typeof cb !== 'function') {
      cb = undefined
    }

    const isEmpty = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject)(data) && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject)(this.forceUpdateData)
    const renderTask = this.createRenderTask(isEmpty)

    if (isEmpty) {
      cb && cb()
      return
    }

    // 使用forceUpdateData后清空
    if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject)(this.forceUpdateData)) {
      data = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.mergeData)({}, data, this.forceUpdateData)
      this.forceUpdateData = {}
      this.forceUpdateAll = false
    }

    let callback = cb
    // mounted之后才会触发BEFOREUPDATE/UPDATED
    if (this.isMounted()) {
      this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREUPDATE)
      callback = () => {
        cb && cb()
        this.callHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UPDATED)
        renderTask && renderTask.resolve()
      }
    }

    data = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.processUndefined)(data)
    if (typeof _index__WEBPACK_IMPORTED_MODULE_2__["default"].config.setDataHandler === 'function') {
      try {
        _index__WEBPACK_IMPORTED_MODULE_2__["default"].config.setDataHandler(data, this.target)
      } catch (e) {
      }
    }

    this.target.__render(data, callback)
  }

  initRender () {
    if (this.options.__nativeRender__) return this.doRender()

    this.effect = new _observer_effect__WEBPACK_IMPORTED_MODULE_7__.ReactiveEffect(() => {
      if (this.target.__injectedRender) {
        try {
          return this.target.__injectedRender()
        } catch (e) {
          (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)('Failed to execute render function, degrade to full-set-data mode.', this.options.mpxFileResource, e)
          this.render()
        }
      } else {
        this.render()
      }
    }, () => (0,_observer_scheduler__WEBPACK_IMPORTED_MODULE_3__.queueJob)(update), this.scope)

    const update = this.effect.run.bind(this.effect)
    update.id = this.uid
    update()
  }

  forceUpdate (data, options, callback) {
    if (this.isUnmounted()) return
    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(data)) {
      callback = data
      data = undefined
    }

    options = options || {}

    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(options)) {
      callback = options
      options = {}
    }

    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(data)) {
      Object.keys(data).forEach(key => {
        if (!this.options.__nativeRender__ && !this.localKeysMap[(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.getFirstKey)(key)]) {
          (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`ForceUpdate data includes a props key [${key}], which may yield a unexpected result.`, this.options.mpxFileResource)
        }
        (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.setByPath)(this.target, key, data[key])
      })
      this.forceUpdateData = data
    } else {
      this.forceUpdateAll = true
    }

    if (this.effect) {
      options.sync ? this.effect.run() : this.effect.update()
    } else {
      if (this.forceUpdateAll) {
        Object.keys(this.localKeysMap).forEach((key) => {
          this.forceUpdateData[key] = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.diffAndCloneA)(this.target[key]).clone
        })
      }
      options.sync ? this.doRender() : (0,_observer_scheduler__WEBPACK_IMPORTED_MODULE_3__.queueJob)(this.doRender.bind(this))
    }

    if (callback) {
      callback = callback.bind(this.target)
      const doCallback = () => {
        if (this.currentRenderTask?.resolved === false) {
          this.currentRenderTask.promise.then(callback)
        } else {
          callback()
        }
      }
      options.sync ? doCallback() : (0,_observer_scheduler__WEBPACK_IMPORTED_MODULE_3__.nextTick)(doCallback)
    }
  }
}

let currentInstance = null

const getCurrentInstance = () => currentInstance?.target

const setCurrentInstance = (instance) => {
  currentInstance = instance
  instance?.scope?.on()
}

const unsetCurrentInstance = () => {
  currentInstance?.scope?.off()
  currentInstance = null
}

const injectHook = (hookName, hook, instance = currentInstance) => {
  if (instance) {
    const wrappedHook = (...args) => {
      if (instance.isUnmounted()) return
      setCurrentInstance(instance)
      const res = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(hook, instance, `${hookName} hook`, args)
      unsetCurrentInstance()
      return res
    }
    if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(hook)) (instance.hooks[hookName] || (instance.hooks[hookName] = [])).push(wrappedHook)
  }
}

const createHook = (hookName) => (hook, instance) => injectHook(hookName, hook, instance)
// 在代码中调用以下生命周期钩子时, 将生命周期钩子注入到mpxProxy实例上
const onBeforeMount = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREMOUNT)
const onMounted = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.MOUNTED)
const onBeforeUpdate = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREUPDATE)
const onUpdated = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UPDATED)
const onBeforeUnmount = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREUNMOUNT)
const onUnmounted = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UNMOUNTED)
const onLoad = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.ONLOAD)
const onShow = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.ONSHOW)
const onHide = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.ONHIDE)
const onResize = createHook(_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.ONRESIZE)
const onPullDownRefresh = createHook('__onPullDownRefresh__')
const onReachBottom = createHook('__onReachBottom__')
const onShareAppMessage = createHook('__onShareAppMessage__')
const onShareTimeline = createHook('__onShareTimeline__')
const onAddToFavorites = createHook('__onAddToFavorites__')
const onPageScroll = createHook('__onPageScroll__')
const onTabItemTap = createHook('__onTabItemTap__')
const onSaveExitState = createHook('__onSaveExitState__')


/***/ }),
/* 81 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flushPostFlushCbs": function() { return /* binding */ flushPostFlushCbs; },
/* harmony export */   "flushPreFlushCbs": function() { return /* binding */ flushPreFlushCbs; },
/* harmony export */   "nextTick": function() { return /* binding */ nextTick; },
/* harmony export */   "queueJob": function() { return /* binding */ queueJob; },
/* harmony export */   "queuePostFlushCb": function() { return /* binding */ queuePostFlushCb; },
/* harmony export */   "queuePreFlushCb": function() { return /* binding */ queuePreFlushCb; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);



let isFlushing = false
let isFlushPending = false

const queue = []
let flushIndex = 0

const pendingPreFlushCbs = []
let activePreFlushCbs = null
let preFlushIndex = 0

const pendingPostFlushCbs = []
let activePostFlushCbs = null
let postFlushIndex = 0

const resolvedPromise = Promise.resolve()
let currentFlushPromise = null

const RECURSION_LIMIT = 100

const getId = (job) => job.id == null ? Infinity : job.id

function findInsertionIndex (id) {
  // the start index should be `flushIndex + 1`
  let start = flushIndex + 1
  let end = queue.length

  while (start < end) {
    const middle = (start + end) >>> 1
    const middleJobId = getId(queue[middle])
    middleJobId < id ? (start = middle + 1) : (end = middle)
  }

  return start
}

function nextTick (fn) {
  const p = currentFlushPromise || resolvedPromise
  return fn ? p.then(this ? fn.bind(this) : fn) : p
}

function queuePreFlushCb (cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)
}

function queuePostFlushCb (cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)
}

function queueCb (cb, activeQueue, pendingQueue, index) {
  if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(cb)) {
    pendingQueue.push(...cb)
  } else if (
    !activeQueue ||
    !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)
  ) {
    pendingQueue.push(cb)
  }
  queueFlush()
}

function queueJob (job) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if (
    !queue.length ||
    !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)
  ) {
    if (job.id == null) {
      queue.push(job)
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job)
    }
    queueFlush()
  }
}

function queueFlush () {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    if (_index__WEBPACK_IMPORTED_MODULE_1__["default"].config.forceFlushSync) {
      flushJobs()
    } else {
      currentFlushPromise = resolvedPromise.then(flushJobs)
    }
  }
}

function flushPreFlushCbs (seen) {
  if (pendingPreFlushCbs.length) {
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)]
    pendingPreFlushCbs.length = 0
    if (_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev) seen = seen || new Map()
    for (
      preFlushIndex = 0;
      preFlushIndex < activePreFlushCbs.length;
      preFlushIndex++
    ) {
      if (_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev && checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) continue
      activePreFlushCbs[preFlushIndex]()
    }
    activePreFlushCbs = null
    preFlushIndex = 0
    // recursively flush until it drains
    flushPreFlushCbs(seen)
  }
}

function flushPostFlushCbs (seen) {
  if (pendingPostFlushCbs.length) {
    activePostFlushCbs = [...new Set(pendingPostFlushCbs)]
    pendingPostFlushCbs.length = 0
    if (_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev) seen = seen || new Map()

    // activePostFlushCbs.sort((a, b) => getId(a) - getId(b))
    for (
      postFlushIndex = 0;
      postFlushIndex < activePostFlushCbs.length;
      postFlushIndex++
    ) {
      if (_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) continue
      activePostFlushCbs[postFlushIndex]()
    }
    activePostFlushCbs = null
    postFlushIndex = 0
    // recursively flush until it drains
    flushPostFlushCbs(seen)
  }
}

function flushJobs (seen) {
  isFlushPending = false
  isFlushing = true

  if (_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev) seen = seen || new Map()

  flushPreFlushCbs(seen)

  queue.sort((a, b) => getId(a) - getId(b))

  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex]
      if (job && job.active !== false) {
        if (_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isDev && checkRecursiveUpdates(seen, job)) continue
        ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(job, null, 'render job')
      }
    }
  } finally {
    flushIndex = 0
    queue.length = 0

    flushPostFlushCbs(seen)

    isFlushing = false
    currentFlushPromise = null
    // some postFlushCb queued jobs!
    // keep flushing until it drains.
    if (
      queue.length ||
      pendingPreFlushCbs.length ||
      pendingPostFlushCbs.length
    ) {
      flushJobs(seen)
    }
  }
}

function checkRecursiveUpdates (seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1)
  } else {
    const count = seen.get(fn)
    if (count > RECURSION_LIMIT) {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(
        'Maximum recursive updates exceeded.\n' +
        'This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself'
      )
      return true
    } else {
      seen.set(fn, count + 1)
    }
  }
}


/***/ }),
/* 82 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Observer": function() { return /* binding */ Observer; },
/* harmony export */   "defineReactive": function() { return /* binding */ defineReactive; },
/* harmony export */   "del": function() { return /* binding */ del; },
/* harmony export */   "getObserver": function() { return /* binding */ getObserver; },
/* harmony export */   "isReactive": function() { return /* binding */ isReactive; },
/* harmony export */   "markRaw": function() { return /* binding */ markRaw; },
/* harmony export */   "reactive": function() { return /* binding */ reactive; },
/* harmony export */   "set": function() { return /* binding */ set; },
/* harmony export */   "setForceTrigger": function() { return /* binding */ setForceTrigger; },
/* harmony export */   "shallowReactive": function() { return /* binding */ shallowReactive; }
/* harmony export */ });
/* harmony import */ var _dep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83);
/* harmony import */ var _helper_const__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85);
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);






const arrayKeys = Object.getOwnPropertyNames(_array__WEBPACK_IMPORTED_MODULE_1__.arrayMethods)

const rawSet = new WeakSet()

let isForceTrigger = false

function setForceTrigger (val) {
  isForceTrigger = val
}

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
class Observer {
  dep = new _dep__WEBPACK_IMPORTED_MODULE_2__["default"]()

  constructor (value, shallow) {
    this.value = value
    ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.def)(value, _helper_const__WEBPACK_IMPORTED_MODULE_3__.ObKey, this)
    if (Array.isArray(value)) {
      const augment = _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasProto && _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.arrayProtoAugment
        ? protoAugment
        : copyAugment
      augment(value, _array__WEBPACK_IMPORTED_MODULE_1__.arrayMethods, arrayKeys)
      !shallow && this.observeArray(value)
    } else {
      this.walk(value, shallow)
    }
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj, shallow) {
    Object.keys(obj).forEach((key) => {
      defineReactive(obj, key, obj[key], shallow)
    })
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (arr) {
    for (let i = 0, l = arr.length; i < l; i++) {
      observe(arr[i])
    }
  }
}

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (let i = 0, l = keys.length; i < l; i++) {
    const key = keys[i]
    ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.def)(target, key, src[key])
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, shallow) {
  if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || rawSet.has(value)) {
    return
  }
  let ob = getObserver(value)
  if (!ob && (Array.isArray(value) || (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) && Object.isExtensible(value)) {
    ob = new Observer(value, shallow)
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (obj, key, val, shallow) {
  const dep = new _dep__WEBPACK_IMPORTED_MODULE_2__["default"]()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (_dep__WEBPACK_IMPORTED_MODULE_2__["default"].target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return !shallow && (0,_ref__WEBPACK_IMPORTED_MODULE_4__.isRef)(value) ? value.value : value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (!(shallow && isForceTrigger) && !(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(newVal, value)) {
        return
      }
      if (!shallow && (0,_ref__WEBPACK_IMPORTED_MODULE_4__.isRef)(value) && !(0,_ref__WEBPACK_IMPORTED_MODULE_4__.isRef)(newVal)) {
        value.value = newVal
      } else if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (Array.isArray(target) && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isValidArrayIndex)(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key)) {
    target[key] = val
    return val
  }
  const ob = getObserver(target)
  if (!ob) {
    target[key] = val
    return val
  }
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (Array.isArray(target) && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isValidArrayIndex)(key)) {
    target.splice(key, 1)
    return
  }
  const ob = getObserver(target)
  if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(target, key)) {
    return
  }
  delete target[key]
  if (!ob) {
    return
  }
  ob.dep.notify()
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (arr) {
  for (let i = 0, l = arr.length; i < l; i++) {
    const item = arr[i]
    const ob = getObserver(item)
    ob && ob.dep.depend()
    if (Array.isArray(item)) {
      dependArray(item)
    }
  }
}

function reactive (value) {
  observe(value)
  return value
}

function shallowReactive (value) {
  observe(value, true)
  return value
}

function isReactive (value) {
  return value && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(value, _helper_const__WEBPACK_IMPORTED_MODULE_3__.ObKey) && value[_helper_const__WEBPACK_IMPORTED_MODULE_3__.ObKey] instanceof Observer
}

function getObserver (value) {
  if (isReactive(value)) return value[_helper_const__WEBPACK_IMPORTED_MODULE_3__.ObKey]
}

function markRaw (value) {
  if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {
    rawSet.add(value)
  }
  return value
}


/***/ }),
/* 83 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayMethods": function() { return /* binding */ arrayMethods; }
/* harmony export */ });
/* harmony import */ var _reactive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);



const arrayProto = Array.prototype

const arrayMethods = Object.create(arrayProto)

;[
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
].forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.def)(arrayMethods, method, function mutator (...args) {
    const result = original.apply(this, args)
    const ob = (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.getObserver)(this)
    if (ob) {
      let inserted
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args
          break
        case 'splice':
          inserted = args.slice(2)
          break
      }
      if (inserted) ob.observeArray(inserted)
      // notify change
      ob.dep.notify()
    }
    return result
  })
})


/***/ }),
/* 84 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Dep; },
/* harmony export */   "popTarget": function() { return /* binding */ popTarget; },
/* harmony export */   "pushTarget": function() { return /* binding */ pushTarget; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);


let uid = 0

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
class Dep {
  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub) {
    this.subs.push(sub)
  }

  removeSub (sub) {
    (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.remove)(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null
const targetStack = []

function pushTarget (_target) {
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target = _target
}

function popTarget () {
  Dep.target = targetStack.pop()
}


/***/ }),
/* 85 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultLocale": function() { return /* binding */ DefaultLocale; },
/* harmony export */   "ObKey": function() { return /* binding */ ObKey; },
/* harmony export */   "PausedState": function() { return /* binding */ PausedState; },
/* harmony export */   "RefKey": function() { return /* binding */ RefKey; }
/* harmony export */ });
const RefKey = '__composition_api_ref_key__'
const ObKey = '__ob__'

const PausedState = {
  paused: 0,
  dirty: 1,
  resumed: 2
}

const DefaultLocale = 'zh-CN'


/***/ }),
/* 86 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RefImpl": function() { return /* binding */ RefImpl; },
/* harmony export */   "createRef": function() { return /* binding */ createRef; },
/* harmony export */   "customRef": function() { return /* binding */ customRef; },
/* harmony export */   "isRef": function() { return /* binding */ isRef; },
/* harmony export */   "ref": function() { return /* binding */ ref; },
/* harmony export */   "shallowRef": function() { return /* binding */ shallowRef; },
/* harmony export */   "toRef": function() { return /* binding */ toRef; },
/* harmony export */   "toRefs": function() { return /* binding */ toRefs; },
/* harmony export */   "triggerRef": function() { return /* binding */ triggerRef; },
/* harmony export */   "unref": function() { return /* binding */ unref; }
/* harmony export */ });
/* harmony import */ var _reactive__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82);
/* harmony import */ var _helper_const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(85);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);




class RefImpl {
  constructor (options) {
    Object.defineProperty(this, 'value', { enumerable: true, ...options })
  }
}

function createRef (options, effect) {
  const ref = new RefImpl(options)
  if (effect) {
    ref.effect = effect
    effect.computed = ref
  }
  return Object.seal(ref)
}

function isRef (val) {
  return val instanceof RefImpl
}

function unref (ref) {
  return isRef(ref) ? ref.value : ref
}

function ref (raw) {
  if (isRef(raw)) return raw
  const wrapper = (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.reactive)({ [_helper_const__WEBPACK_IMPORTED_MODULE_2__.RefKey]: raw })
  return createRef({
    get: () => wrapper[_helper_const__WEBPACK_IMPORTED_MODULE_2__.RefKey],
    set: (val) => {
      wrapper[_helper_const__WEBPACK_IMPORTED_MODULE_2__.RefKey] = val
    }
  })
}

function toRef (obj, key) {
  if (!(0,_reactive__WEBPACK_IMPORTED_MODULE_1__.isReactive)(obj)) (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)('toRef() expects a reactive object but received a plain one.')
  if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(obj, key)) (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.set)(obj, key)
  const val = obj[key]
  if (isRef(val)) return val
  return createRef({
    get: () => obj[key],
    set: (val) => {
      obj[key] = val
    }
  })
}

function toRefs (obj) {
  if (!(0,_reactive__WEBPACK_IMPORTED_MODULE_1__.isReactive)(obj)) (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)('toRefs() expects a reactive object but received a plain one.')
  if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) return obj
  const result = {}
  Object.keys(obj).forEach((key) => {
    result[key] = toRef(obj, key)
  })
  return result
}

function customRef (factory) {
  const version = ref(0)
  return createRef(
    factory(
      // track
      () => version.value,
      // trigger
      () => {
        version.value++
      }
    )
  )
}

function shallowRef (raw) {
  if (isRef(raw)) return raw
  const wrapper = (0,_reactive__WEBPACK_IMPORTED_MODULE_1__.shallowReactive)({ [_helper_const__WEBPACK_IMPORTED_MODULE_2__.RefKey]: raw })
  return createRef({
    get: () => wrapper[_helper_const__WEBPACK_IMPORTED_MODULE_2__.RefKey],
    set: (val) => {
      wrapper[_helper_const__WEBPACK_IMPORTED_MODULE_2__.RefKey] = val
    }
  })
}

function triggerRef (ref) {
  if (!isRef(ref)) return
  ;(0,_reactive__WEBPACK_IMPORTED_MODULE_1__.setForceTrigger)(true)
  /* eslint-disable no-self-assign */
  ref.value = ref.value
  ;(0,_reactive__WEBPACK_IMPORTED_MODULE_1__.setForceTrigger)(false)
}


/***/ }),
/* 87 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computed": function() { return /* binding */ computed; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _dep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84);
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86);
/* harmony import */ var _effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88);





function computed (getterOrOptions) {
  let getter, setter
  if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getterOrOptions)) {
    getter = getterOrOptions
    setter = _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.noop
  } else {
    getter = getterOrOptions.get
    setter = getterOrOptions.set
  }
  // 复用createRef创建computedRef，使用闭包变量存储dirty/value/effect
  let dirty = true
  let value
  const effect = new _effect__WEBPACK_IMPORTED_MODULE_1__.ReactiveEffect(getter, () => {
    dirty = true
  })

  return (0,_ref__WEBPACK_IMPORTED_MODULE_2__.createRef)({
    get: () => {
      if (dirty) {
        value = effect.run()
        dirty = false
      }
      if (_dep__WEBPACK_IMPORTED_MODULE_3__["default"].target) {
        effect.depend()
      }
      return value
    },
    set: (val) => {
      setter(val)
    }
  }, effect)
}


/***/ }),
/* 88 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReactiveEffect": function() { return /* binding */ ReactiveEffect; }
/* harmony export */ });
/* harmony import */ var _dep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(84);
/* harmony import */ var _effectScope__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(89);
/* harmony import */ var _helper_const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85);




let uid = 0

class ReactiveEffect {
  active = true
  deps = []
  newDeps = []
  depIds = new Set()
  newDepIds = new Set()

  constructor (
    fn,
    scheduler,
    scope
  ) {
    this.id = ++uid
    this.fn = fn
    this.scheduler = scheduler
    this.pausedState = _helper_const__WEBPACK_IMPORTED_MODULE_0__.PausedState.resumed
    ;(0,_effectScope__WEBPACK_IMPORTED_MODULE_1__.recordEffectScope)(this, scope)
  }

  // run fn and return value
  run () {
    if (!this.active) return this.fn()
    ;(0,_dep__WEBPACK_IMPORTED_MODULE_2__.pushTarget)(this)
    try {
      return this.fn()
    } finally {
      (0,_dep__WEBPACK_IMPORTED_MODULE_2__.popTarget)()
      this.deferStop ? this.stop() : this.cleanupDeps()
    }
  }

  // add dependency to this
  addDep (dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  // Clean up for dependency collection.
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  // same as trigger
  update () {
    // avoid dead cycle
    if (_dep__WEBPACK_IMPORTED_MODULE_2__["default"].target === this) return
    if (this.pausedState !== _helper_const__WEBPACK_IMPORTED_MODULE_0__.PausedState.resumed) {
      this.pausedState = _helper_const__WEBPACK_IMPORTED_MODULE_0__.PausedState.dirty
    } else {
      this.scheduler ? this.scheduler() : this.run()
    }
  }

  // pass through deps for computed
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  // Remove self from all dependencies' subscriber list.
  stop () {
    if (_dep__WEBPACK_IMPORTED_MODULE_2__["default"].target === this) {
      this.deferStop = true
    } else if (this.active) {
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      typeof this.onStop === 'function' && this.onStop()
      this.active = false
    }
  }

  pause () {
    this.pausedState = _helper_const__WEBPACK_IMPORTED_MODULE_0__.PausedState.paused
  }

  resume () {
    const lastPausedState = this.pausedState
    this.pausedState = _helper_const__WEBPACK_IMPORTED_MODULE_0__.PausedState.resumed
    if (lastPausedState === _helper_const__WEBPACK_IMPORTED_MODULE_0__.PausedState.dirty) {
      this.scheduler ? this.scheduler() : this.run()
    }
  }
}


/***/ }),
/* 89 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "effectScope": function() { return /* binding */ effectScope; },
/* harmony export */   "getCurrentScope": function() { return /* binding */ getCurrentScope; },
/* harmony export */   "onScopeDispose": function() { return /* binding */ onScopeDispose; },
/* harmony export */   "recordEffectScope": function() { return /* binding */ recordEffectScope; }
/* harmony export */ });
let activeEffectScope

class EffectScope {
  active = true
  effects = []
  cleanups = []

  constructor (detached) {
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1
    }
  }

  run (fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope
      try {
        activeEffectScope = this
        return fn()
      } finally {
        activeEffectScope = currentEffectScope
      }
    }
  }

  on () {
    activeEffectScope = this
  }

  off () {
    activeEffectScope = this.parent
  }

  stop (fromParent) {
    if (this.active) {
      let i, l
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop()
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]()
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true)
        }
      }
      // nested scope, dereference from parent to avoid memory leaks
      if (this.parent && !fromParent) {
        // optimized O(1) removal
        const last = this.parent.scopes.pop()
        if (last && last !== this) {
          this.parent.scopes[this.index] = last
          last.index = this.index
        }
      }
      this.active = false
    }
  }

  pause () {
    if (this.active) {
      let i, l
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause()
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause()
        }
      }
    }
  }

  resume () {
    if (this.active) {
      let i, l
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].resume()
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].resume()
        }
      }
    }
  }
}

function effectScope (detached) {
  return new EffectScope(detached)
}

function recordEffectScope (effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect)
  }
}

function getCurrentScope () {
  return activeEffectScope
}

function onScopeDispose (fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn)
  }
}


/***/ }),
/* 90 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "traverse": function() { return /* binding */ traverse; },
/* harmony export */   "watch": function() { return /* binding */ watch; },
/* harmony export */   "watchEffect": function() { return /* binding */ watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* binding */ watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* binding */ watchSyncEffect; }
/* harmony export */ });
/* harmony import */ var _effect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88);
/* harmony import */ var _ref__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86);
/* harmony import */ var _reactive__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(82);
/* harmony import */ var _scheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81);
/* harmony import */ var _core_proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);







function watchEffect (effect, options) {
  return watch(effect, null, options)
}

function watchPostEffect (effect, options) {
  return watch(effect, null, { ...options, flush: 'post' })
}

function watchSyncEffect (effect, options) {
  return watch(effect, null, { ...options, flush: 'sync' })
}

const warnInvalidSource = (s) => {
  (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.warn)(`Invalid watch source: ${s}\nA watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`)
}

const shouldTrigger = (value, oldValue) => (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.hasChanged)(value, oldValue) || (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)

const processWatchOptionsCompat = (options) => {
  const newOptions = { ...options }
  if (options.sync) {
    newOptions.flush = 'sync'
  }
  return newOptions
}

function watch (source, cb, options = {}) {
  let { immediate, deep, flush, immediateAsync } = processWatchOptionsCompat(options)
  const instance = _core_proxy__WEBPACK_IMPORTED_MODULE_1__.currentInstance
  let getter
  let isMultiSource = false
  if ((0,_ref__WEBPACK_IMPORTED_MODULE_2__.isRef)(source)) {
    getter = () => source.value
  } else if ((0,_reactive__WEBPACK_IMPORTED_MODULE_3__.isReactive)(source)) {
    getter = () => source
    deep = true
  } else if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(source)) {
    isMultiSource = true
    getter = () =>
      source.map(s => {
        if ((0,_ref__WEBPACK_IMPORTED_MODULE_2__.isRef)(s)) {
          return s.value
        } else if ((0,_reactive__WEBPACK_IMPORTED_MODULE_3__.isReactive)(s)) {
          return traverse(s)
        } else if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(s)) {
          return (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(s, instance, 'watch getter')
        } else {
          warnInvalidSource(s)
          return s
        }
      })
  } else if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source)) {
    if (cb) {
      // getter with cb
      getter = () => (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(source, instance, 'watch getter')
    } else {
      // no cb -> simple effect
      getter = () => {
        if (instance && instance.isUnmounted()) {
          return
        }
        if (cleanup) {
          cleanup()
        }
        return (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(source, instance, 'watch callback', [onCleanup])
      }
    }
  } else {
    getter = _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.noop
    warnInvalidSource(source)
  }

  if (cb && deep) {
    const baseGetter = getter
    getter = () => traverse(baseGetter())
  }

  let cleanup
  const onCleanup = (fn) => {
    cleanup = effect.onStop = () => (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(fn, instance, 'watch cleanup')
  }

  let oldValue = isMultiSource ? [] : undefined
  const job = () => {
    if (!effect.active) return
    if (cb) {
      const newValue = effect.run()
      if (
        deep ||
        (isMultiSource
          ? newValue.some((v, i) => shouldTrigger(v, oldValue[i]))
          : shouldTrigger(newValue, oldValue))
      ) {
        // cleanup before running cb again
        if (cleanup) {
          cleanup()
        }
        (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.callWithErrorHandling)(cb, instance, 'watch callback', [newValue, oldValue, onCleanup])
        oldValue = newValue
      }
    } else {
      // watchEffect
      effect.run()
    }
  }

  let scheduler
  if (flush === 'sync') {
    // the scheduler function gets called directly
    scheduler = job
  } else if (flush === 'post') {
    scheduler = () => (0,_scheduler__WEBPACK_IMPORTED_MODULE_4__.queuePostFlushCb)(job)
  } else {
    // default: 'pre'
    scheduler = () => (0,_scheduler__WEBPACK_IMPORTED_MODULE_4__.queuePreFlushCb)(job)
  }

  job.allowRecurse = !!cb

  const effect = new _effect__WEBPACK_IMPORTED_MODULE_5__.ReactiveEffect(getter, scheduler)

  if (cb) {
    if (immediate) {
      job()
    } else if (immediateAsync) {
      (0,_scheduler__WEBPACK_IMPORTED_MODULE_4__.queuePreFlushCb)(job)
    } else {
      oldValue = effect.run()
    }
  } else if (flush === 'post') {
    (0,_scheduler__WEBPACK_IMPORTED_MODULE_4__.queuePostFlushCb)(effect.run.bind(effect))
  } else {
    effect.run()
  }

  return () => {
    effect.stop()
    if (instance && instance.scope) {
      (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.remove)(instance.scope.effects, effect)
    }
  }
}

function traverse (value, seen) {
  if (!(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) return value
  seen = seen || new Set()
  if (seen.has(value)) return value
  seen.add(value)
  if ((0,_ref__WEBPACK_IMPORTED_MODULE_2__.isRef)(value)) {
    traverse(value.value, seen)
  } else if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen)
    }
  } else if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {
    for (const key in value) {
      traverse(value[key], seen)
    }
  }
  return value
}


/***/ }),
/* 91 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getBuiltInMixins; }
/* harmony export */ });
/* harmony import */ var _pageStatusMixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _proxyEventMixin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _refsMixin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);
/* harmony import */ var _relationsMixin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(116);
/* harmony import */ var _pageTitleMixin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/* harmony import */ var _pageScrollMixin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/* harmony import */ var _componentGenericsMixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(113);
/* harmony import */ var _getTabBarMixin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(114);
/* harmony import */ var _pageRouteMixin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(115);













function getBuiltInMixins (options, type) {
  let bulitInMixins = []
  if (true) {
    bulitInMixins = [
      (0,_proxyEventMixin__WEBPACK_IMPORTED_MODULE_0__["default"])(),
      (0,_refsMixin__WEBPACK_IMPORTED_MODULE_1__["default"])(),
      (0,_pageTitleMixin__WEBPACK_IMPORTED_MODULE_2__["default"])(type),
      (0,_pageStatusMixin__WEBPACK_IMPORTED_MODULE_3__["default"])(type),
      (0,_pageScrollMixin__WEBPACK_IMPORTED_MODULE_4__["default"])(type),
      (0,_componentGenericsMixin__WEBPACK_IMPORTED_MODULE_5__["default"])(type),
      (0,_getTabBarMixin__WEBPACK_IMPORTED_MODULE_6__["default"])(type),
      (0,_pageRouteMixin__WEBPACK_IMPORTED_MODULE_7__["default"])(type),
      // 由于relation可能是通过mixin注入的，不能通过当前的用户options中是否存在relations来简单判断是否注入该项mixin
      (0,_relationsMixin__WEBPACK_IMPORTED_MODULE_8__["default"])(type)
    ]
  } else {}
  return bulitInMixins.filter(item => item)
}


/***/ }),
/* 92 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ proxyEventMixin; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);


function proxyEventMixin () {
  return {
    beforeCreate () {
      const modelEvent = this.$attrs.mpxModelEvent
      if (modelEvent) {
        this.$on(modelEvent, (e) => {
          this.$emit('mpxModel', e)
        })
      }
    },
    methods: {
      __model (expr, $event, valuePath = ['value'], filterMethod) {
        const innerFilter = {
          trim: val => typeof val === 'string' && val.trim()
        }
        const originValue = valuePath.reduce((acc, cur) => acc[cur], $event.detail)
        const value = filterMethod ? (innerFilter[filterMethod] ? innerFilter[filterMethod](originValue) : typeof this[filterMethod] === 'function' && this[filterMethod]) : originValue
        ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.setByPath)(this, expr, value)
      },
      getOpenerEventChannel () {
        const router = __webpack_require__.g.__mpxRouter
        const eventChannel = router && router.__mpxAction && router.__mpxAction.eventChannel
        return eventChannel
      }
    }
  }
}


/***/ }),
/* 93 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getRefsMixin; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _mpxjs_api_proxy_src_web_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);



function getEl (ref) {
  if (ref && ref.nodeType === 1) return ref
  if (ref && ref.$options && ref.$options.__mpxBuiltIn) return ref.$el
}

function processRefs (refs) {
  Object.keys(refs).forEach((key) => {
    const matched = /^__mpx_ref_([^_]+)__$/.exec(key)
    const rKey = matched && matched[1]
    if (rKey) {
      const ref = refs[key]
      if (Array.isArray(ref)) {
        if (getEl(ref[0])) {
          refs[rKey] = _mpxjs_api_proxy_src_web_api__WEBPACK_IMPORTED_MODULE_0__.createSelectorQuery().in(this).selectAll(ref.map(getEl))
        } else {
          refs[rKey] = ref
        }
      } else {
        if (getEl(ref)) {
          refs[rKey] = _mpxjs_api_proxy_src_web_api__WEBPACK_IMPORTED_MODULE_0__.createSelectorQuery().in(this).select(getEl(ref))
        } else {
          refs[rKey] = ref
        }
      }
    }
  })
}

function getRefsMixin () {
  return {
    [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREMOUNT] () {
      processRefs(this.$refs || {})
    },
    [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.UPDATED] () {
      processRefs(this.$refs || {})
    }
  }
}


/***/ }),
/* 94 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createSelectorQuery": function() { return /* binding */ createSelectorQuery; }
/* harmony export */ });
/* harmony import */ var _SelectQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);


function createSelectorQuery () {
  return new _SelectQuery__WEBPACK_IMPORTED_MODULE_0__["default"]()
}




/***/ }),
/* 95 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _NodesRef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);


class SelectQuery {
  constructor () {
    this._component = null
    this._queue = []
    this._queueCb = []
  }

  in (component) {
    this._component = component
    return this
  }

  select (selector) {
    if (typeof selector === 'string') {
      selector = selector.replace('>>>', '>')
    }
    return new _NodesRef__WEBPACK_IMPORTED_MODULE_0__["default"](selector, this, true)
  }

  selectAll (selector) {
    if (typeof selector === 'string') {
      selector = selector.replace('>>>', '>')
    }
    return new _NodesRef__WEBPACK_IMPORTED_MODULE_0__["default"](selector, this, false)
  }

  selectViewport () {
    return new _NodesRef__WEBPACK_IMPORTED_MODULE_0__["default"]('html', this, true)
  }

  exec (callback) {
    const res = []
    const handleFields = this._handleFields
    const queueCb = this._queueCb
    this._queue.forEach(item => {
      const { selector, component, single, fields } = item

      let curComponent = document
      if (component && component.$el) {
        curComponent = component.$el
      } else if (component && component.nodeType === 1) {
        curComponent = component
      }
      if (this._isEl(selector)) {
        if (single) {
          res.push(handleFields(fields, selector, null))
        } else {
          res.push(selector.map(el => handleFields(fields, el, null)))
        }
      } else {
        const selectSelf =
          curComponent === document
            ? false
            : Array
              .from(curComponent.parentNode.querySelectorAll(selector))
              .every(item => item === curComponent)
        if (single) {
          const el = selectSelf ? curComponent : curComponent.querySelector(selector)
          res.push(handleFields(fields, el, selector))
        } else {
          const els = selectSelf
            ? [curComponent]
            : curComponent.querySelectorAll(selector)
          const elsArr = Array.from(els).map(el => handleFields(fields, el, null))
          res.push(elsArr)
        }
      }
    })
    res.forEach((item, idx) => {
      typeof queueCb[idx] === 'function' && queueCb[idx].call(this, item)
    })
    typeof callback === 'function' && callback.call(this, res)
  }

  _handleFields (fields, el, selector) {
    if (!el) return null
    const { id, dataset, rect, size, scrollOffset, properties = [], computedStyle = [], node } = fields
    const { left, right, top, bottom, width, height } = el.getBoundingClientRect()

    const res = {}
    const isViewport = selector === 'html'
    if (id) res.id = el.id
    if (dataset) res.dataset = Object.assign({}, el.dataset)
    if (rect) {
      if (isViewport) {
        res.left = 0
        res.right = 0
        res.top = 0
        res.bottom = 0
      } else {
        res.left = left
        res.right = right
        res.top = top
        res.bottom = bottom
      }
    }
    if (size) {
      if (isViewport) {
        res.width = el.clientWidth
        res.height = el.clientHeight
      } else {
        res.width = width
        res.height = height
      }
    }
    // 添加获取节点信息
    if (node) {
      res.node = el
      // 如果是canvas节点，需要做特殊处理
      if (isCanvas(el)) {
        // 避免lint检查报错
        el.createImage = function () {
          return new Image()  // eslint-disable-line
        }

        el.createPath2D = function (path) {
          return window.Path2D(path)
        }

        el.requestAnimationFrame = function (callback) {
          return window.requestAnimationFrame(callback)
        }

        el.cancelAnimationFrame = function (requestID) {
          return window.cancelAnimationFrame(requestID)
        }

        const rawGetContext = el.getContext
        el.getContext = function (...args) {
          const context = rawGetContext.apply(this, args)
          // 如果实例方法有变动，可以在这里进行处理
          return context
        }
      }
    }
    if (scrollOffset) {
      res.scrollLeft = el.scrollLeft
      res.scrollTop = el.scrollTop
    }
    properties.forEach(prop => {
      const attr = el.getAttribute(prop)
      if (attr) {
        res[prop] = attr
      }
    })
    if (computedStyle.length) {
      const styles = window.getComputedStyle(el)
      computedStyle.forEach(style => {
        const midLineStyle = style.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`)
        const value = styles.getPropertyValue(midLineStyle)
        if (value) {
          res[style] = value
        }
      })
    }
    return res
  }

  _push (selector, component, single, fields, callback) {
    this._queue.push({
      component,
      selector,
      single,
      fields
    })
    this._queueCb.push(callback)
  }

  _isEl (selector) {
    if (Array.isArray(selector)) return this._isEl(selector[0])
    return selector && selector.nodeType === 1
  }
}

/* harmony default export */ __webpack_exports__["default"] = (SelectQuery);

// 判断是不是canvas元素
function isCanvas (el) {
  return el.nodeName && el.nodeName.toLowerCase() === 'canvas'
}


/***/ }),
/* 96 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class NodesRef {
  constructor (selector, selectorQuery, single) {
    this._selector = selector
    this._selectorQuery = selectorQuery
    this._component = selectorQuery._component
    this._single = single
  }

  boundingClientRect (callback) {
    this._selectorQuery._push(
      this._selector,
      this._component,
      this._single,
      {
        id: true,
        dataset: true,
        rect: true,
        size: true
      },
      callback
    )
    return this._selectorQuery
  }

  scrollOffset (callback) {
    this._selectorQuery._push(
      this._selector,
      this._component,
      this._single,
      {
        id: true,
        dataset: true,
        scrollOffset: true
      },
      callback
    )
    return this._selectorQuery
  }

  fields (fields, callback) {
    this._selectorQuery._push(
      this._selector,
      this._component,
      this._single,
      fields,
      callback
    )
    return this._selectorQuery
  }

  // 获取Node节点实例
  node (callback) {
    this._selectorQuery._push(
      this._selector,
      this._component,
      this._single,
      {
        node: true
      },
      callback
    )
    return this._selectorQuery
  }
}

/* harmony default export */ __webpack_exports__["default"] = (NodesRef);


/***/ }),
/* 97 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ pageTitleMixin; }
/* harmony export */ });
// web专用mixin，在web中实现页面title功能
function pageTitleMixin (mixinType) {
  if (mixinType === 'page') {
    return {
      activated () {
        if (this.$options.__mpxPageConfig.navigationBarTitleText) {
          document.title = this.$options.__mpxPageConfig.navigationBarTitleText
        }
      }
    }
  }
}


/***/ }),
/* 98 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ pageStatusMixin; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);



let systemInfo = {}

let count = 0

function getCurrentPageInstance () {
  const vnode = __webpack_require__.g.__mpxRouter && __webpack_require__.g.__mpxRouter.__mpxActiveVnode
  let pageInstance
  if (vnode && vnode.componentInstance) {
    pageInstance = vnode.tag.endsWith('mpx-tab-bar-container') ? vnode.componentInstance.$children[1] : vnode.componentInstance
  }
  return pageInstance
}

function onResize () {
  // 设备屏幕状态
  const deviceOrientation = window.screen.width > window.screen.height ? 'landscape' : 'portrait'

  // 设备参数
  systemInfo = {
    deviceOrientation,
    size: {
      screenWidth: window.screen.width,
      screenHeight: window.screen.height,
      windowWidth: document.documentElement.clientWidth,
      windowHeight: document.documentElement.clientHeight
    }
  }

  const _t = getCurrentPageInstance()

  if (_t) {
    _t.mpxPageStatus = `resize${count++}`
    ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(_t.onResize) && _t.onResize(systemInfo)
  }
}

// listen resize
if (_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
  window.addEventListener('resize', onResize)
}

function pageStatusMixin (mixinType) {
  const mixin = {}

  if (mixinType === 'page') {
    Object.assign(mixin, {
      data: {
        mpxPageStatus: null
      },
      activated () {
        this.mpxPageStatus = 'show'
      },
      deactivated () {
        this.mpxPageStatus = 'hide'
      },
      created () {
        // onLoad应该在用户声明周期CREATED后再执行，故此处使用原生created声明周期来触发onLoad
        const query = (__webpack_require__.g.__mpxRouter && __webpack_require__.g.__mpxRouter.currentRoute && __webpack_require__.g.__mpxRouter.currentRoute.query) || {}
        this.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.ONLOAD, [query])
      }
    })
  }

  Object.assign(mixin, {
    [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.CREATED] () {
      const pageInstance = mixinType === 'page' ? this : getCurrentPageInstance()
      if (pageInstance) {
        this.$watch(() => pageInstance.mpxPageStatus, status => {
          if (!status) return
          if (status === 'show') this.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.ONSHOW)
          if (status === 'hide') this.__mpxProxy.callHook(_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.ONHIDE)
          const pageLifetimes = this.__mpxProxy.options.pageLifetimes
          if (pageLifetimes) {
            if (/^resize/.test(status) && (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(pageLifetimes.resize)) {
              // resize
              pageLifetimes.resize.call(this, systemInfo)
            } else if ((0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(pageLifetimes[status])) {
              // show & hide
              pageLifetimes[status].call(this)
            }
          }
        }, {
          sync: true
        })
      }
    }
  })

  return mixin
}


/***/ }),
/* 99 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ pageScrollMixin; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _helper_MpxScroll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
/* harmony import */ var _helper_MpxScroll_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);




let ms

function refreshMs () {
  if (ms) ms.destroy()
  try {
    __webpack_require__.g.__ms = ms = new _helper_MpxScroll__WEBPACK_IMPORTED_MODULE_1__["default"]()
    return true
  } catch (e) {
    (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)('MpxScroll init error, please check.', undefined, e)
  }
}

let loading = null

function showLoading (vm) {
  const { backgroundColor = 'transparent', backgroundTextStyle = 'dark' } = vm.$options.__mpxPageConfig
  loading = document.createElement('div')
  loading.className = 'pull-down-loading'
  loading.style.cssText = `background-color: ${backgroundColor};`
  const dot = document.createElement('div')
  dot.className = `dot-flashing ${backgroundTextStyle}`
  loading.append(dot)
  vm.$el.prepend(loading)
}

function hideLoading (vm) {
  if (loading) {
    vm.$el.removeChild(loading)
    loading = null
  }
}

function pageScrollMixin (mixinType) {
  if (mixinType !== 'page') {
    return
  }
  return {
    mounted () {
      this.__lastScrollY = 0
    },
    activated () {
      if (!refreshMs()) {
        return
      }

      const { disableScroll, enablePullDownRefresh } = this.$options.__mpxPageConfig

      // 下拉刷新
      if (enablePullDownRefresh) {
        showLoading(this)
        ms.usePullDownRefresh()
        ms.hooks.pullingDown.on(this.__mpxPullDownHandler)
      }

      // 页面滚动
      if (!disableScroll) {
        ms.pageScrollTo({
          scrollTop: this.__lastScrollY,
          duration: 0
        })

        if (this.onPageScroll || this.onReachBottom) {
          ms.useScroll()
          ms.hooks.scroll.on(this.__mpxPageScrollHandler)
        }
      } else {
        document.body.style.overflow = 'hidden'
      }
    },
    deactivated () {
      if (ms) {
        this.__lastScrollY = (0,_helper_MpxScroll_dom__WEBPACK_IMPORTED_MODULE_2__.getScrollTop)()
        ms.destroy()
        hideLoading(this)
      }
    },
    beforeDestroy () {
      if (ms) {
        ms.destroy()
        hideLoading(this)
      }
    },
    methods: {
      __mpxPullDownHandler (autoStop = false, isRefresh = false) {
        this.__pullingDown = true
        // 同微信保持一致
        // 如果是手动触摸下拉，3s 后用户还没有调用过 __stopPullDownRefresh，则自动调用关闭 pullDown
        // 如果是手动调用 startPullDownRefresh 的 api，则一直处于 pull down 状态，除非用户手动调用 stopPullDownRefresh
        if (isRefresh) {
          this.__clearPullDownTimer()
        }
        if (autoStop) {
          this.__mpxPullDownTimer = setTimeout(() => {
            if (this.__pullingDown) {
              this.__stopPullDownRefresh()
            }
          }, 3000)
        }
        this.onPullDownRefresh && this.onPullDownRefresh()
      },
      __stopPullDownRefresh () {
        this.__pullingDown = false
        if (this.$options.__mpxPageConfig.enablePullDownRefresh && ms) {
          ms.stopPullDownRefresh()
          this.__clearPullDownTimer()
        }
      },
      __startPullDownRefresh () {
        if (!this.__pullingDown && this.$options.__mpxPageConfig.enablePullDownRefresh && ms) {
          ms.startPullDownRefresh()
        }
      },
      __mpxPageScrollHandler (e) {
        const { onReachBottomDistance = 50 } = this.$options.__mpxPageConfig
        if (this.onPageScroll) {
          const _e = {}
          Object.defineProperty(_e, 'scrollTop', {
            configurable: false,
            enumerable: true,
            get: () => e.scrollTop
          })
          this.onPageScroll(_e)
        }
        if (this.onReachBottom) {
          ms.onReachBottom(onReachBottomDistance, this.onReachBottom)
        }
      },
      __clearPullDownTimer () {
        if (this.__mpxPullDownTimer) {
          clearTimeout(this.__mpxPullDownTimer)
          this.__mpxPullDownTimer = null
        }
      }
    }
  }
}


/***/ }),
/* 100 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ MpxScroll; }
/* harmony export */ });
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(109);
/* harmony import */ var _EventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(110);
/* harmony import */ var _EventRegister__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _ScrollAnimation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(111);
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_0__);






function isDef (val) {
  return val !== undefined
}

class MpxScroll {
  constructor (options = {}) {
    const defaultOptions = {
      threshold: 60, // 滑动触发下拉刷新的距离
      stop: 56, // 下拉刷新时停留的位置距离屏幕顶部的距离
      bounceTime: 800, // 设置回弹动画的动画时长
      throttle: 50 // 页面滚动节流
    }
    this.options = Object.assign({}, defaultOptions, options)

    // 下拉阻尼系数
    this.ratio = 0.5

    this.el = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getElement)('.page')
    this.touchstartY = 0
    this.currentY = 0
    this.translateY = 0

    // 为了不阻断用户交互，在 pull down 过程中允许用户可以再次做下拉动作。
    // 记录上次 pull down 的 translateY，再次下拉时加上这个 legacy 作为起始点
    // 避免再次 touchstart 的时候 translateY 从某个值突然小于正处于 pull down 状态的 loading 高度
    this.legacyY = 0

    this.isIntersecting = false
    this.isRefresh = false
    this.bottomReached = false

    const hooks = [
      'scroll', // 页面自然滚动
      'pullingDown' // pullDown 事件
    ]
    this.hooks = {}
    hooks.forEach(hook => {
      this.hooks[hook] = new _EventEmitter__WEBPACK_IMPORTED_MODULE_2__["default"]()
    })
    this.scrollAnimation = new _ScrollAnimation__WEBPACK_IMPORTED_MODULE_3__["default"]()
    this.pullDownEventRegister = null
    this.scrollEventRegister = null
    this.intersectionOb = null
  }

  usePullDownRefresh () {
    // fix lint
    const IntersectionObserver = window.IntersectionObserver
    const ob = this.intersectionOb = new IntersectionObserver(changes => {
      const [change] = changes
      const isIntersecting = change.isIntersecting
      this.isIntersecting = isIntersecting
      if (!isIntersecting) {
        // 非 inter section 状态下及时清除 transtorm，以免影响正常滚动时元素的 fixed 定位
        this.el.style.cssText = ''
        this.pullDownEventRegister && this.pullDownEventRegister.destroy()
      } else {
        this.pullDownEventRegister = new _EventRegister__WEBPACK_IMPORTED_MODULE_4__["default"](this.el, [
          {
            name: 'touchstart',
            handler: e => this.onTouchStart(e)
          },
          {
            name: 'touchmove',
            handler: e => this.onTouchMove(e)
          },
          {
            name: 'touchend',
            handler: e => this.onTouchEnd(e)
          }
        ])
      }
    })
    ob.observe(document.querySelector('.pull-down-loading'))
  }

  onTouchStart (e) {
    this.touchstartY = e.changedTouches[0].clientY
  }

  onTouchMove (e) {
    this.currentY = e.targetTouches[0].clientY
    if (this.currentY - this.touchstartY >= 0 && this.isIntersecting) {
      (0,_dom__WEBPACK_IMPORTED_MODULE_1__.preventDefault)(e)
      if (this.isRefresh) {
        this.legacyY = this.translateY
        this.isRefresh = false
      }
      this.pullDown(this.currentY - this.touchstartY)
    }
  }

  pullDown (distance) {
    const alteredDistance = distance * this.ratio + this.legacyY
    this.transformPage(alteredDistance)
  }

  transformPage (distance) {
    this.translateY = distance
    this.el.style.cssText = `transform: translateY(${distance}px)`
  }

  onTouchEnd (e) {
    if (this.isRefresh) {
      return
    }

    if (this.translateY >= this.options.threshold) {
      this.isRefresh = true
      this.hooks.pullingDown.emit(true, true)
      this.moveBack(this.translateY)
    } else if (this.translateY > 0) {
      this.moveBack(this.translateY)
      this.isRefresh = false
    }
  }

  moveBack (distance) {
    const { stop, threshold, bounceTime } = this.options
    const finalDistance = distance >= threshold
      ? stop
      : 0
    this.move(bounceTime, distance, finalDistance)
  }

  useScroll () {
    const pageScrollHandler = lodash_throttle__WEBPACK_IMPORTED_MODULE_0___default()(e => {
      const _e = {}
      Object.defineProperty(_e, 'scrollTop', {
        configurable: false,
        enumerable: true,
        get: () => (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getScrollTop)()
      })
      this.hooks.scroll.emit(_e)
    }, this.options.throttle, {
      leading: true,
      trailing: true
    })
    this.scrollEventRegister = new _EventRegister__WEBPACK_IMPORTED_MODULE_4__["default"](document, [
      {
        name: 'scroll',
        handler: pageScrollHandler
      }
    ])
  }

  destroy () {
    const hooks = this.hooks
    Object.keys(hooks).forEach(hook => {
      this.hooks[hook].destroy()
    })
    this.scrollEventRegister && this.scrollEventRegister.destroy()
    this.pullDownEventRegister && this.pullDownEventRegister.destroy()
    this.intersectionOb && this.intersectionOb.disconnect()
  }

  startPullDownRefresh () {
    if (this.isRefresh) {
      return
    }

    this.hooks.pullingDown.emit()
    this.pageScrollTo({
      scrollTop: 0,
      duration: 0
    })

    this.isRefresh = true

    const { stop, bounceTime } = this.options
    this.move(bounceTime, 0, stop)
  }

  stopPullDownRefresh () {
    if (!this.isRefresh) {
      return
    }
    const { stop, bounceTime } = this.options
    this.move(bounceTime, stop, 0)
    this.isRefresh = false
    this.legacyY = 0
  }

  move (bounceTime, beginPosition, endPosition) {
    this.scrollAnimation.easeOutQuart(
      bounceTime,
      beginPosition,
      endPosition,
      distance => this.transformPage(distance)
    )
  }

  pageScrollTo ({ scrollTop, selector, duration = 300 }) {
    let _scrollTop

    if (isDef(scrollTop)) {
      _scrollTop = scrollTop
    } else if (isDef(selector)) {
      _scrollTop = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getOffsetTop)((0,_dom__WEBPACK_IMPORTED_MODULE_1__.getElement)(selector))
    } else {
      return console.error('[pageScrollTo error]: scrollTop and selector are not defined')
    }

    if (duration === 0) {
      return window.scrollTo(0, _scrollTop)
    }

    const position = (0,_dom__WEBPACK_IMPORTED_MODULE_1__.getScrollTop)()

    this.scrollAnimation.easeOutQuart(duration, position, _scrollTop, distance => {
      window.scrollTo(0, distance)
    })
  }

  onReachBottom (onReachBottomDistance, callback) {
    const { bottom } = this.el.getBoundingClientRect()
    const mark = bottom - window.innerHeight <= onReachBottomDistance

    if (!this.bottomReached && mark) {
      this.bottomReached = true
      callback()
    } else if (!mark) {
      this.bottomReached = false
    }
  }
}


/***/ }),
/* 101 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var debounce = __webpack_require__(102),
    isObject = __webpack_require__(103);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;


/***/ }),
/* 102 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(103),
    now = __webpack_require__(104),
    toNumber = __webpack_require__(105);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),
/* 103 */
/***/ (function(module) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 104 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(54);

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),
/* 105 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseTrim = __webpack_require__(106),
    isObject = __webpack_require__(103),
    isSymbol = __webpack_require__(108);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),
/* 106 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var trimmedEndIndex = __webpack_require__(107);

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),
/* 107 */
/***/ (function(module) {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),
/* 108 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseGetTag = __webpack_require__(58),
    isObjectLike = __webpack_require__(61);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 109 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getElement": function() { return /* binding */ getElement; },
/* harmony export */   "getOffsetTop": function() { return /* binding */ getOffsetTop; },
/* harmony export */   "getScrollTop": function() { return /* binding */ getScrollTop; },
/* harmony export */   "preventDefault": function() { return /* binding */ preventDefault; }
/* harmony export */ });
function getOffsetTop (el) {
  let top = el.offsetTop
  let op = el.offsetParent
  while (op) {
    top += op.offsetTop
    op = op.offsetParent
  }
  return top
}

function getElement (el) {
  return typeof el === 'string'
    ? document.querySelector(el)
    : el
}

function getScrollTop () {
  return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop
}

function preventDefault (e, isStopPropagation) {
  if (typeof e.cancelable !== 'boolean' || e.cancelable) {
    e.preventDefault()
  }

  if (isStopPropagation) {
    e.stopPropagation()
  }
}


/***/ }),
/* 110 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ EventEmitter; }
/* harmony export */ });
class EventEmitter {
  constructor () {
    this.disposer = []
  }

  on (handler) {
    this.disposer.push(handler)
    return this
  }

  emit (...args) {
    this.disposer.forEach(handler => handler(...args))
    return this
  }

  destroy () {
    this.disposer = []
    return this
  }
}


/***/ }),
/* 111 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ScrollAnimation; }
/* harmony export */ });
class ScrollAnimation {
  easeOutQuart (time, beginPosition, endPosition, callback) {
    const startTime = Date.now()
    const endTime = startTime + time
    const bounceFn = t => 1 - (--t) * t * t * t
    let timer = null
    const scheduler = () => {
      const now = Date.now()
      if (now >= endTime) {
        window.cancelAnimationFrame(timer)
        timer = null
        return
      }
      const ratio = bounceFn((now - startTime) / time)
      const currentPosition = ratio * (endPosition - beginPosition) + beginPosition
      callback(Math.floor(currentPosition))
      timer = window.requestAnimationFrame(scheduler)
    }
    scheduler()
  }
}


/***/ }),
/* 112 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ EventRegister; }
/* harmony export */ });
function addEvent (el, type, handler, capture) {
  el.addEventListener(type, handler, {
    passive: false,
    capture: !!capture
  })
}

function removeEvent (el, type, handler, capture) {
  el.removeEventListener(type, handler, {
    capture: !!capture
  })
}

class EventRegister {
  constructor (wrapper, events) {
    this.wrapper = wrapper
    this.events = events
    this.addDOMEvents()
  }

  addDOMEvents (el, type, handler) {
    this.handleDOMEvents(addEvent)
  }

  removeDOMEvents () {
    this.handleDOMEvents(removeEvent)
  }

  handleDOMEvents (eventOperation) {
    const wrapper = this.wrapper
    this.events.forEach(event => {
      eventOperation(wrapper, event.name, event.handler, !!event.capture)
    })
  }

  destroy () {
    this.removeDOMEvents()
    this.events = []
  }
}


/***/ }),
/* 113 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ componentGenericsMixin; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
// web专用mixin，在web中实现抽象节点功能


function componentGenericsMixin (mixinType) {
  if (__webpack_require__.g.__mpxGenericsMap && mixinType === 'component') {
    return {
      [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.CREATED] () {
        if (this.generichash && __webpack_require__.g.__mpxGenericsMap[this.generichash]) {
          Object.keys(__webpack_require__.g.__mpxGenericsMap[this.generichash]).forEach((name) => {
            const value = __webpack_require__.g.__mpxGenericsMap[this.generichash][name]
            this.$options.components[name] = value
          })
        }
      }
    }
  }
}


/***/ }),
/* 114 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getTabBarMixin; }
/* harmony export */ });
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
// web专用mixin，在web中实现getTabBar功能


function getTabBarMixin (mixinType) {
  if (mixinType === 'page') {
    return {
      [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_0__.CREATED] () {
        if (this.$parent && this.$parent.$vnode && this.$parent.$vnode.tag && this.$parent.$vnode.tag.endsWith('mpx-tab-bar-container')) {
          this.getTabBar = () => {
            return this.$parent.$refs.tabBar
          }
        }
      }
    }
  }
}


/***/ }),
/* 115 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ pageRouteMixin; }
/* harmony export */ });
// web专用mixin，在web页面上挂载route属性
function pageRouteMixin (mixinType) {
  if (mixinType === 'page') {
    return {
      beforeCreate () {
        this.route = this.$options.__mpxPageRoute || ''
      }
    }
  }
}


/***/ }),
/* 116 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ relationsMixin; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);



const targets = []
let curTarget = null

function pushTarget (cur) {
  targets.push(curTarget)
  curTarget = cur
}

function popTarget () {
  curTarget = targets.pop()
}

function parsePath (path, absolute) {
  if (path.indexOf('/') === 0) {
    return path
  }
  const dirs = absolute.split('/').slice(0, -1)
  let relatives = path.split('/')
  relatives = relatives.filter(path => {
    if (path === '..') {
      dirs.pop()
      return false
    } else {
      return path !== '.'
    }
  })
  return dirs.concat(relatives).join('/')
}

function transferPath (relations, base) {
  const newRelations = {}
  Object.keys(relations).forEach(key => {
    newRelations[parsePath(key, base)] = relations[key]
  })
  return newRelations
}

const relationTypeMap = {
  parent: 'child',
  ancestor: 'descendant'
}

function relationsMixin (mixinType) {
  if (false) {} else if ( true && mixinType === 'component') {
    return {
      [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.CREATED] () {
        this.__mpxRelations = {}
      },
      [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.MOUNTED] () {
        this.__mpxCollectRelations()
        this.__mpxExecRelations('linked')
      },
      [_core_innerLifecycle__WEBPACK_IMPORTED_MODULE_1__.BEFOREUNMOUNT] () {
        this.__mpxExecRelations('unlinked')
      },
      methods: {
        __mpxCollectRelations () {
          const relations = this.__mpxProxy.options.relations
          if (!relations) return
          Object.keys(relations).forEach(path => {
            const relation = relations[path]
            // 向上查找parent是否为relation目标
            this.__mpxCheckParent(this, relation, path)
          })
        },
        __mpxCheckParent (current, relation, path) {
          const type = relation.type
          const target = current.$parent
          if (!target) return

          // target为内建组件时，直接跳过，继续向上查找
          if (target.$options.__mpxBuiltIn) {
            return this.__mpxCheckParent(target, relation, path)
          }

          // 当前组件在target的slots当中
          if ((type === 'parent' || type === 'ancestor') && target.$vnode.context === this.$vnode.context) {
            const targetRelation = target?.__mpxProxy.options.relations?.[this.$options.componentPath]
            if (
              targetRelation &&
              targetRelation.type === relationTypeMap[type] &&
              target.$options.componentPath === path
            ) {
              // 当前匹配成功
              this.__mpxRelations[path] = {
                target,
                targetRelation,
                relation
              }
            } else if (type === 'ancestor') {
              // 当前匹配失败，但type为ancestor时，继续向上查找
              return this.__mpxCheckParent(target, relation, path)
            }
          }
        },
        __mpxExecRelations (type) {
          Object.keys(this.__mpxRelations).forEach(path => {
            const { target, targetRelation, relation } = this.__mpxRelations[path]
            if (typeof targetRelation[type] === 'function') {
              targetRelation[type].call(target, this)
            }
            if (typeof relation[type] === 'function') {
              relation[type].call(this, target)
            }
          })
        }
      }
    }
  }
}


/***/ }),
/* 117 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);


/* harmony default export */ __webpack_exports__["default"] = ((0,_patch__WEBPACK_IMPORTED_MODULE_0__["default"])('component'));


/***/ }),
/* 118 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "APIs": function() { return /* binding */ APIs; },
/* harmony export */   "InstanceAPIs": function() { return /* binding */ InstanceAPIs; }
/* harmony export */ });
/* harmony import */ var _vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var _core_injectMixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);



const vm = new _vue__WEBPACK_IMPORTED_MODULE_0__["default"]()
const observable = _vue__WEBPACK_IMPORTED_MODULE_0__["default"].observable.bind(_vue__WEBPACK_IMPORTED_MODULE_0__["default"])
const watch = vm.$watch.bind(vm)
const set = _vue__WEBPACK_IMPORTED_MODULE_0__["default"].set.bind(_vue__WEBPACK_IMPORTED_MODULE_0__["default"])
const del = _vue__WEBPACK_IMPORTED_MODULE_0__["default"]["delete"].bind(_vue__WEBPACK_IMPORTED_MODULE_0__["default"])

const APIs = {
  injectMixins: _core_injectMixins__WEBPACK_IMPORTED_MODULE_1__.injectMixins,
  mixin: _core_injectMixins__WEBPACK_IMPORTED_MODULE_1__.injectMixins,
  observable,
  watch,
  set,
  delete: del
}

const InstanceAPIs = {}




/***/ }),
/* 119 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _vuePlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);



vue__WEBPACK_IMPORTED_MODULE_0__["default"].use(_vuePlugin__WEBPACK_IMPORTED_MODULE_1__["default"])

/* harmony default export */ __webpack_exports__["default"] = (vue__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),
/* 120 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ install; }
/* harmony export */ });
/* harmony import */ var _mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _mpxjs_api_proxy_src_web_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94);
/* harmony import */ var _mpxjs_api_proxy_src_web_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(121);



function install (Vue) {
  Vue.prototype.triggerEvent = function (eventName, eventDetail) {
    return this.$emit(eventName, {
      type: eventName,
      detail: eventDetail
    })
  }
  Vue.prototype.selectComponent = function (selector, all) {
    const result = []
    if (/[>\s]/.test(selector)) {
      const location = this.__mpxProxy.options.mpxFileResource
      ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.error)('The selectComponent or selectAllComponents only supports the basic selector, the relation selector is not supported.', location)
    } else {
      const selectorGroups = (0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.parseSelector)(selector)
      ;(0,_mpxjs_utils__WEBPACK_IMPORTED_MODULE_0__.walkChildren)(this, selectorGroups, this, result, all)
    }
    return all ? result : result[0]
  }
  Vue.prototype.selectAllComponents = function (selector) {
    return this.selectComponent(selector, true)
  }
  Vue.prototype.createSelectorQuery = function () {
    return _mpxjs_api_proxy_src_web_api__WEBPACK_IMPORTED_MODULE_1__.createSelectorQuery().in(this)
  }
  Vue.prototype.createIntersectionObserver = function (component, options) {
    return _mpxjs_api_proxy_src_web_api__WEBPACK_IMPORTED_MODULE_2__.createIntersectionObserver(component, options)
  }
}


/***/ }),
/* 121 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createIntersectionObserver": function() { return /* binding */ createIntersectionObserver; }
/* harmony export */ });
/* harmony import */ var _IntersectionObserver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(122);


function createIntersectionObserver (component, options) {
  return new _IntersectionObserver__WEBPACK_IMPORTED_MODULE_0__["default"](component, options)
}




/***/ }),
/* 122 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _next_tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(123);


let isInit = true

class WebIntersectionObserver {
  constructor (_component, options) {
    this._component = _component
    this._options = options || {}
    this._relativeInfo = []
    this._callback = null
    this._observer = null
    this._root = null
    this._rootMargin = ''
    this._disconnected = false
    this._minThreshold = this.getMinThreshold()
  }

  initObserver () {
    if (this._observer) {
      this._observer = null
    }
    this._disconnected = false
    // eslint-disable-next-line no-undef
    return new IntersectionObserver((entries, observer) => {
      const initialRatio = this._options.initialRatio || 0
      entries.forEach(entry => {
        if (!isInit || (isInit && (entry.intersectionRatio !== initialRatio && (this._minThreshold <= entry.intersectionRatio)))) {
          Object.defineProperties(entry, {
            id: {
              value: entry.target.getAttribute('id') || '',
              writable: false,
              enumerable: true,
              configurable: true
            },
            dataset: {
              value: entry.target.dataset || {},
              writable: false,
              enumerable: true,
              configurable: true
            },
            relativeRect: {
              value: entry.rootBounds || {},
              writable: false,
              enumerable: true,
              configurable: true
            },
            time: {
              value: new Date().valueOf(),
              writable: false,
              enumerable: true,
              configurable: true
            }
          })
          this._callback && this._callback(entry)
        }
      })
      isInit = false
    }, {
      root: this._root || null,
      rootMargin: this._rootMargin,
      threshold: this._options.thresholds || [0]
    })
  }

  observe (targetSelector, callback) {
    (0,_next_tick__WEBPACK_IMPORTED_MODULE_0__.nextTick)(async () => {
      if (!targetSelector) {
        const res = { errMsg: 'observe:targetSelector can not be empty' }
        return Promise.reject(res)
      }
      this._observer = await this.initObserver()
      this._callback = callback
      let targetElement = []
      if (this._options.observeAll) {
        targetElement = [...document.querySelectorAll(targetSelector)]
      } else {
        targetElement = [document.querySelector(targetSelector)]
      }
      targetElement.forEach((element) => {
        this._observer && this._observer.observe(element)
      })
    })
  }

  relativeTo (selector, margins) {
    (0,_next_tick__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
      const marginsTemp = margins || {}
      const { left = 0, right = 0, top = 0, bottom = 0 } = marginsTemp
      this._root = document.querySelector(selector)
      this._rootMargin = `${top}px ${right}px ${bottom}px ${left}px`
      this._relativeInfo.push({ selector, margins })
    })
    return this
  }

  relativeToViewport (margins) {
    (0,_next_tick__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
      const marginsTemp = margins || {}
      const { left = 0, right = 0, top = 0, bottom = 0 } = marginsTemp
      this._root = document.querySelector('html')
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight
      const rootWidth = this._root.offsetWidth || 0
      const rootHeight = this._root.offsetHeight || 0
      if (rootHeight >= viewportHeight) {
        this._rootMargin = `${top}px ${viewportWidth - rootWidth + right}px ${viewportHeight - rootHeight + bottom}px ${left}px`
      } else {
        this._rootMargin = `${top}px ${right}px ${bottom}px ${left}px`
      }
      this._relativeInfo.push({ selector: null, margins })
    })
    return this
  }

  disconnect () {
    this._disconnected = true
    this._observer.disconnect()
  }

  getMinThreshold () {
    const thresholds = this._options.thresholds || [0]
    const thresholdsSortArr = thresholds.sort((a, b) => a - b)
    return thresholdsSortArr[0] || 0
  }
}

/* harmony default export */ __webpack_exports__["default"] = (WebIntersectionObserver);


/***/ }),
/* 123 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isNative": function() { return /* binding */ isNative; },
/* harmony export */   "nextTick": function() { return /* binding */ nextTick; }
/* harmony export */ });
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

function nextTick (cb) {
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    Promise.resolve().then(cb)
  } else if (
    typeof MessageChannel !== 'undefined' &&
    (isNative(window.MessageChannel) ||
    // PhantomJS
    window.MessageChannel.toString() === '[object MessageChannelConstructor]')
  ) {
    const channel = new window.MessageChannel()
    const port = channel.port2
    channel.port1.onmessage = cb
    port.postMessage(1)
  } else {
    setTimeout(cb, 0)
  }
}




/***/ }),
/* 124 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _mpxjs_api_proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(125);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);

  
  
  
  // import Vconsole from 'vconsole'
  // const vconsole = new Vconsole()
  _mpxjs_core__WEBPACK_IMPORTED_MODULE_0__["default"].use(_mpxjs_api_proxy__WEBPACK_IMPORTED_MODULE_1__["default"], { usePromise: false })
  ;(0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_2__["default"])({})


/***/ }),
/* 125 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ install; },
/* harmony export */   "getProxy": function() { return /* binding */ getProxy; }
/* harmony export */ });
/* harmony import */ var _web_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(128);
/* harmony import */ var _web_api_event_channel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(127);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);




function install (target) {
  const fromMap = (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.genFromMap)()

  __webpack_require__.g.EventChannel = new _web_api_event_channel__WEBPACK_IMPORTED_MODULE_1__.EventChannel()

  Object.keys(_web_api__WEBPACK_IMPORTED_MODULE_2__).forEach(api => {
    target[api] = function (...args) {
      if (args.length > 0) {
        const from = args.pop()
        if (typeof from !== 'string' || !fromMap[from]) {
          args.push(from)
        }
      }

      return _web_api__WEBPACK_IMPORTED_MODULE_2__[api].apply(target, args)
    }
  })
}
function getProxy () {
  const apiProxy = {}
  install(apiProxy)
  return apiProxy
}


/***/ }),
/* 126 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* mpx cjs variable */ var mpx = __webpack_require__(38);
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "changeOpts": function() { return /* binding */ changeOpts; },
/* harmony export */   "error": function() { return /* binding */ error; },
/* harmony export */   "genFromMap": function() { return /* binding */ genFromMap; },
/* harmony export */   "getEnvObj": function() { return /* binding */ getEnvObj; },
/* harmony export */   "handleSuccess": function() { return /* binding */ handleSuccess; },
/* harmony export */   "hasOwn": function() { return /* binding */ hasOwn; },
/* harmony export */   "isBrowser": function() { return /* binding */ isBrowser; },
/* harmony export */   "makeMap": function() { return /* binding */ makeMap; },
/* harmony export */   "noop": function() { return /* binding */ noop; },
/* harmony export */   "warn": function() { return /* binding */ warn; }
/* harmony export */ });
/**
 *
 * @param {Object} options 原参数
 * @param {Object} updateOrRemoveOpt 要修改或者删除的参数
 * @param {Object} extraOpt 额外增加的参数
 * @returns {Object} 返回参数
 * @example
 * changeOpts({ a: 1, b: 2 }, {
 *  a: 'c', // a 变为 c
 *  b: '' // 删除 b
 * }, {
 *  d: 4 // 增加 d
 * })
 */
const hasOwnProperty = Object.prototype.hasOwnProperty

function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

function changeOpts (options, updateOrRemoveOpt = {}, extraOpt = {}) {
  let opts = {}

  Object.keys(options).forEach(key => {
    const myKey = hasOwn(updateOrRemoveOpt, key) ? updateOrRemoveOpt[key] : key
    if (myKey !== '') {
      opts[myKey] = options[key]
    }
  })

  opts = Object.assign({}, opts, extraOpt)

  return opts
}

/**
 * @param {Object} opts 原参数
 * @param {Function} getOptions 获取 success 回调修改后的参数
 * @param {Object} thisObj this对象
 */
const handleSuccess = (opts, getOptions = noop, thisObj) => {
  if (!opts.success) {
    return
  }
  const _this = thisObj || undefined
  const cacheSuc = opts.success
  opts.success = res => {
    const changedRes = getOptions(res) || res
    cacheSuc.call(_this, changedRes)
  }
}

function genFromMap () {
  const result = {}
  const platforms = ['wx', 'ali', 'swan', 'qq', 'tt', 'web', 'qa', 'jd', 'dd']
  platforms.forEach((platform) => {
    result[`__mpx_src_mode_${platform}__`] = platform
  })
  return result
}

function getEnvObj () {
  switch ("web") {
    case 'wx':
      return /* mpx replace */ mpx
    case 'ali':
      return my
    case 'swan':
      return swan
    case 'qq':
      return qq
    case 'tt':
      return tt
    case 'jd':
      return jd
    case 'qa':
      return qa
    case 'dd':
      return dd
  }
}

function warn (msg) {
  console.warn && console.warn(`[@mpxjs/api-proxy warn]:\n ${msg}`)
}

function error (msg) {
  console.error && console.error(`[@mpxjs/api-proxy error]:\n ${msg}`)
}

function noop () {
}

function makeMap (arr) {
  return arr.reduce((obj, item) => {
    obj[item] = true
    return obj
  }, {})
}

const isBrowser = typeof window !== 'undefined'




/***/ }),
/* 127 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventChannel": function() { return /* binding */ EventChannel; }
/* harmony export */ });
class EventChannel {
  constructor () {
    this.listener = {}
  }

  emit (eventName, ...args) {
    const cbs = this.listener[eventName]
    if (cbs) {
      cbs.forEach((item, index) => {
        try {
          item.fn.apply(this, args)
        } catch (e) {
          console.log(`event "${eventName}" error ${e}`)
        }
        if (item.type === 'once') {
          cbs.splice(index, 1)
        }
      })
    }
  }

  off (eventName, EventCallback) {
    if (EventCallback) {
      const cbs = this.listener[eventName]
      const copyCbs = []
      if (cbs) {
        cbs.forEach((item) => {
          if (item.fn !== EventCallback) {
            copyCbs.push(item)
          }
        })
      }
      this.listener[eventName] = copyCbs
    } else {
      this.listener[eventName] && (this.listener[eventName].length = 0)
    }
  }

  on (eventName, EventCallback) {
    (this.listener[eventName] || (this.listener[eventName] = [])).push({ fn: EventCallback, type: 'on' })
  }

  once (eventName, EventCallback) {
    (this.listener[eventName] || (this.listener[eventName] = [])).push({ fn: EventCallback, type: 'once' })
  }

  _addListener (eventName, EventCallback, type) {
    (this.listener[eventName] || (this.listener[eventName] = [])).push({ fn: EventCallback, type })
  }

  _addListeners (events) {
    if (Object.prototype.toString.call(events) === '[object Object]') {
      Object.keys(events).forEach((eventName) => {
        (this.listener[eventName] || (this.listener[eventName] = [])).push({ fn: events[eventName], type: 'on' })
      })
    }
  }
}



/***/ }),
/* 128 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayBufferToBase64": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.arrayBufferToBase64; },
/* harmony export */   "base64ToArrayBuffer": function() { return /* reexport safe */ _base__WEBPACK_IMPORTED_MODULE_0__.base64ToArrayBuffer; },
/* harmony export */   "clearStorage": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.clearStorage; },
/* harmony export */   "clearStorageSync": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.clearStorageSync; },
/* harmony export */   "closeSocket": function() { return /* reexport safe */ _socket__WEBPACK_IMPORTED_MODULE_10__.closeSocket; },
/* harmony export */   "connectSocket": function() { return /* reexport safe */ _socket__WEBPACK_IMPORTED_MODULE_10__.connectSocket; },
/* harmony export */   "createAnimation": function() { return /* reexport safe */ _animation__WEBPACK_IMPORTED_MODULE_20__.createAnimation; },
/* harmony export */   "createInnerAudioContext": function() { return /* reexport safe */ _audio__WEBPACK_IMPORTED_MODULE_15__.createInnerAudioContext; },
/* harmony export */   "createIntersectionObserver": function() { return /* reexport safe */ _create_intersection_observer__WEBPACK_IMPORTED_MODULE_21__.createIntersectionObserver; },
/* harmony export */   "createSelectorQuery": function() { return /* reexport safe */ _create_selector_query__WEBPACK_IMPORTED_MODULE_1__.createSelectorQuery; },
/* harmony export */   "createVideoContext": function() { return /* reexport safe */ _video__WEBPACK_IMPORTED_MODULE_16__.createVideoContext; },
/* harmony export */   "getNetworkType": function() { return /* reexport safe */ _device_network__WEBPACK_IMPORTED_MODULE_7__.getNetworkType; },
/* harmony export */   "getStorage": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.getStorage; },
/* harmony export */   "getStorageInfo": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.getStorageInfo; },
/* harmony export */   "getStorageInfoSync": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.getStorageInfoSync; },
/* harmony export */   "getStorageSync": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.getStorageSync; },
/* harmony export */   "getSystemInfo": function() { return /* reexport safe */ _system__WEBPACK_IMPORTED_MODULE_6__.getSystemInfo; },
/* harmony export */   "getSystemInfoSync": function() { return /* reexport safe */ _system__WEBPACK_IMPORTED_MODULE_6__.getSystemInfoSync; },
/* harmony export */   "hideLoading": function() { return /* reexport safe */ _toast__WEBPACK_IMPORTED_MODULE_3__.hideLoading; },
/* harmony export */   "hideTabBar": function() { return /* reexport safe */ _tab_bar__WEBPACK_IMPORTED_MODULE_18__.hideTabBar; },
/* harmony export */   "hideToast": function() { return /* reexport safe */ _toast__WEBPACK_IMPORTED_MODULE_3__.hideToast; },
/* harmony export */   "isNative": function() { return /* reexport safe */ _next_tick__WEBPACK_IMPORTED_MODULE_12__.isNative; },
/* harmony export */   "navigateBack": function() { return /* reexport safe */ _route__WEBPACK_IMPORTED_MODULE_9__.navigateBack; },
/* harmony export */   "navigateTo": function() { return /* reexport safe */ _route__WEBPACK_IMPORTED_MODULE_9__.navigateTo; },
/* harmony export */   "nextTick": function() { return /* reexport safe */ _next_tick__WEBPACK_IMPORTED_MODULE_12__.nextTick; },
/* harmony export */   "offAppHide": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_19__.offAppHide; },
/* harmony export */   "offAppShow": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_19__.offAppShow; },
/* harmony export */   "offError": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_19__.offError; },
/* harmony export */   "offNetworkStatusChange": function() { return /* reexport safe */ _device_network__WEBPACK_IMPORTED_MODULE_7__.offNetworkStatusChange; },
/* harmony export */   "offWindowResize": function() { return /* reexport safe */ _window__WEBPACK_IMPORTED_MODULE_13__.offWindowResize; },
/* harmony export */   "onAppHide": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_19__.onAppHide; },
/* harmony export */   "onAppShow": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_19__.onAppShow; },
/* harmony export */   "onError": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_19__.onError; },
/* harmony export */   "onNetworkStatusChange": function() { return /* reexport safe */ _device_network__WEBPACK_IMPORTED_MODULE_7__.onNetworkStatusChange; },
/* harmony export */   "onSocketClose": function() { return /* reexport safe */ _socket__WEBPACK_IMPORTED_MODULE_10__.onSocketClose; },
/* harmony export */   "onSocketError": function() { return /* reexport safe */ _socket__WEBPACK_IMPORTED_MODULE_10__.onSocketError; },
/* harmony export */   "onSocketMessage": function() { return /* reexport safe */ _socket__WEBPACK_IMPORTED_MODULE_10__.onSocketMessage; },
/* harmony export */   "onSocketOpen": function() { return /* reexport safe */ _socket__WEBPACK_IMPORTED_MODULE_10__.onSocketOpen; },
/* harmony export */   "onWindowResize": function() { return /* reexport safe */ _window__WEBPACK_IMPORTED_MODULE_13__.onWindowResize; },
/* harmony export */   "pageScrollTo": function() { return /* reexport safe */ _page_scroll_to__WEBPACK_IMPORTED_MODULE_17__.pageScrollTo; },
/* harmony export */   "reLaunch": function() { return /* reexport safe */ _route__WEBPACK_IMPORTED_MODULE_9__.reLaunch; },
/* harmony export */   "redirectTo": function() { return /* reexport safe */ _route__WEBPACK_IMPORTED_MODULE_9__.redirectTo; },
/* harmony export */   "removeStorage": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.removeStorage; },
/* harmony export */   "removeStorageSync": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.removeStorageSync; },
/* harmony export */   "request": function() { return /* reexport safe */ _request__WEBPACK_IMPORTED_MODULE_8__.request; },
/* harmony export */   "sendSocketMessage": function() { return /* reexport safe */ _socket__WEBPACK_IMPORTED_MODULE_10__.sendSocketMessage; },
/* harmony export */   "setNavigationBarColor": function() { return /* reexport safe */ _set_navigation_bar__WEBPACK_IMPORTED_MODULE_11__.setNavigationBarColor; },
/* harmony export */   "setNavigationBarTitle": function() { return /* reexport safe */ _set_navigation_bar__WEBPACK_IMPORTED_MODULE_11__.setNavigationBarTitle; },
/* harmony export */   "setStorage": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.setStorage; },
/* harmony export */   "setStorageSync": function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_5__.setStorageSync; },
/* harmony export */   "setTabBarItem": function() { return /* reexport safe */ _tab_bar__WEBPACK_IMPORTED_MODULE_18__.setTabBarItem; },
/* harmony export */   "setTabBarStyle": function() { return /* reexport safe */ _tab_bar__WEBPACK_IMPORTED_MODULE_18__.setTabBarStyle; },
/* harmony export */   "showActionSheet": function() { return /* reexport safe */ _action_sheet__WEBPACK_IMPORTED_MODULE_2__.showActionSheet; },
/* harmony export */   "showLoading": function() { return /* reexport safe */ _toast__WEBPACK_IMPORTED_MODULE_3__.showLoading; },
/* harmony export */   "showModal": function() { return /* reexport safe */ _modal__WEBPACK_IMPORTED_MODULE_4__.showModal; },
/* harmony export */   "showTabBar": function() { return /* reexport safe */ _tab_bar__WEBPACK_IMPORTED_MODULE_18__.showTabBar; },
/* harmony export */   "showToast": function() { return /* reexport safe */ _toast__WEBPACK_IMPORTED_MODULE_3__.showToast; },
/* harmony export */   "startPullDownRefresh": function() { return /* reexport safe */ _pull_down__WEBPACK_IMPORTED_MODULE_14__.startPullDownRefresh; },
/* harmony export */   "stopPullDownRefresh": function() { return /* reexport safe */ _pull_down__WEBPACK_IMPORTED_MODULE_14__.stopPullDownRefresh; },
/* harmony export */   "switchTab": function() { return /* reexport safe */ _route__WEBPACK_IMPORTED_MODULE_9__.switchTab; }
/* harmony export */ });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _create_selector_query__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94);
/* harmony import */ var _action_sheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(131);
/* harmony import */ var _toast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(137);
/* harmony import */ var _modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(143);
/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(147);
/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(148);
/* harmony import */ var _device_network__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(149);
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(152);
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(183);
/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(184);
/* harmony import */ var _set_navigation_bar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(186);
/* harmony import */ var _next_tick__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(123);
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(187);
/* harmony import */ var _pull_down__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(188);
/* harmony import */ var _audio__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(189);
/* harmony import */ var _video__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(190);
/* harmony import */ var _page_scroll_to__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(191);
/* harmony import */ var _tab_bar__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(192);
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(193);
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(194);
/* harmony import */ var _create_intersection_observer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(121);
// base64ToArrayBuffer, arrayBufferToBase64


// createSelectorQuery


// showActionSheet


// showToast, hideToast, showLoading, hideLoading


// showModal


// setStorage, setStorageSync, getStorage, getStorageSync
// getStorageInfo, getStorageInfoSync, removeStorage, removeStorageSync
// clearStorage, clearStorageSync


// getSystemInfo, getSystemInfoSync


// getNetworkType, onNetworkStatusChange, offNetworkStatusChange


// request


// redirectTo, navigateTo, navigateBack, reLaunch, switchTab


// connectSocket, sendSocketMessage, closeSocket
// onSocketOpen, onSocketError, onSocketMessage, onSocketClose


// setNavigationBarTitle setNavigationBarColor


// nextTick


// onWindowResize offWindowResize


// stopPullDownRefresh startPullDownRefresh


// createInnerAudioContext


// createVideoContext








// createAnimation


// createIntersectionObserver



/***/ }),
/* 129 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayBufferToBase64": function() { return /* binding */ arrayBufferToBase64; },
/* harmony export */   "base64ToArrayBuffer": function() { return /* binding */ base64ToArrayBuffer; }
/* harmony export */ });
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(130);


function base64ToArrayBuffer (base64) {
  return (0,_base64__WEBPACK_IMPORTED_MODULE_0__.toByteArray)(base64)
}

function arrayBufferToBase64 (arrayBuffer) {
  return (0,_base64__WEBPACK_IMPORTED_MODULE_0__.fromByteArray)(arrayBuffer)
}




/***/ }),
/* 130 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "byteLength": function() { return /* binding */ byteLength; },
/* harmony export */   "fromByteArray": function() { return /* binding */ fromByteArray; },
/* harmony export */   "toByteArray": function() { return /* binding */ toByteArray; }
/* harmony export */ });
// fork base64-js@1.3.1
const lookup = []
const revLookup = []
const Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (let i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  const len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  let validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  const placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  const lens = getLens(b64)
  const validLen = lens[0]
  const placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  let tmp
  const lens = getLens(b64)
  const validLen = lens[0]
  const placeHoldersLen = lens[1]

  const arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  let curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  const len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  let i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  let tmp
  const output = []
  for (let i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  let tmp
  const len = uint8.length
  const extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  const parts = []
  const maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}




/***/ }),
/* 131 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "showActionSheet": function() { return /* binding */ showActionSheet; }
/* harmony export */ });
/* harmony import */ var _ActionSheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(132);


let actionSheet = null

function showActionSheet (options = { itemList: [] }) {
  if (!actionSheet) { actionSheet = new _ActionSheet__WEBPACK_IMPORTED_MODULE_0__["default"]() }
  return actionSheet.show(options)
}




/***/ }),
/* 132 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ActionSheet; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(135);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136);
/* harmony import */ var _common_stylus_ActionSheet_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(133);
/* harmony import */ var _common_stylus_ActionSheet_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_common_stylus_ActionSheet_styl__WEBPACK_IMPORTED_MODULE_0__);



class ActionSheet extends _common_js__WEBPACK_IMPORTED_MODULE_1__.ToPromise {
  constructor () {
    super()
    this.defaultOpts = {
      itemList: [],
      itemColor: '#000000',
      success: null,
      fail: null,
      complete: null
    }
    this.hideTimer = null

    const actionSheet = document.createElement('div')
    actionSheet.setAttribute('class', '__mpx_actionsheet__')

    const mask = document.createElement('div')
    mask.setAttribute('class', '__mpx_mask__')

    const box = document.createElement('div')
    box.setAttribute('class', '__mpx_actionsheet_box__')

    const list = document.createElement('div')
    list.setAttribute('class', '__mpx_actionsheet_list__')

    const cancelBtn = document.createElement('div')
    cancelBtn.setAttribute('class', '__mpx_actionsheet_cancel__')
    cancelBtn.textContent = '取消'

    box.appendChild(list)
    box.appendChild(cancelBtn)
    actionSheet.appendChild(mask)
    actionSheet.appendChild(box)
    document.body.appendChild(actionSheet)

    this.actionSheet = actionSheet
    this.mask = mask
    this.box = box
    this.list = list
    this.cancelBtn = cancelBtn
  }

  show (options) {
    if (this.hideTimer) {
      clearTimeout(this.hideTimer)
      this.hideTimer = null
    }

    const opts = Object.assign({}, this.defaultOpts, options)

    const list = document.createElement('div')
    list.setAttribute('class', '__mpx_actionsheet_list__')

    opts.itemList.forEach((item, index) => {
      const sheet = document.createElement('div')
      sheet.setAttribute('class', '__mpx_actionsheet_sheet__')
      sheet.textContent = item
      sheet.onclick = () => {
        this.hide()
        const res = {
          errMsg: 'showActionSheet:ok',
          tapIndex: index
        }
        ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(res, opts.success, opts.complete)
        this.toPromiseResolve(res)
      }
      list.appendChild(sheet)
    })

    this.box.replaceChild(list, this.list)
    this.list = list
    this.list.style.color = opts.itemColor

    this.cancelBtn.onclick = () => {
      this.hide()
      const err = { errMsg: 'showActionSheet:fail cancel' }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleFail)(err, opts.fail, opts.complete)
      !opts.fail && this.toPromiseReject(err)
    }

    this.box.classList.add('show')
    this.actionSheet.classList.add('show')

    return this.toPromiseInitPromise()
  }

  hide () {
    if (this.hideTimer) {
      clearTimeout(this.hideTimer)
      this.hideTimer = null
    }

    this.hideTimer = setTimeout(() => {
      this.box.classList.remove('show')
      this.actionSheet.classList.remove('show')
    }, 0)
  }
}


/***/ }),
/* 133 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(134);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("27e18aaa", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.__mpx_actionsheet__ {\n  display: none;\n}\n.__mpx_actionsheet__.show {\n  display: block;\n}\n.__mpx_actionsheet__ .__mpx_mask__ {\n  position: fixed;\n  z-index: 1000;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  background: rgba(0,0,0,0.6);\n}\n.__mpx_actionsheet__ .__mpx_actionsheet_box__ {\n  position: fixed;\n  left: 0;\n  bottom: 0;\n  z-index: 3000;\n  width: 100%;\n  line-height: 1.6;\n  background-color: #efeff4;\n  transform: translate(0, 100%);\n  transition: transform 0.3s;\n}\n.__mpx_actionsheet__ .__mpx_actionsheet_box__.show {\n  transform: translate(0, 0);\n}\n.__mpx_actionsheet__ .__mpx_actionsheet_list__ {\n  background-color: #fcfcfd;\n}\n.__mpx_actionsheet__ .__mpx_actionsheet_list__ .__mpx_actionsheet_sheet__ {\n  position: relative;\n  font-size: 18px;\n  text-align: center;\n  padding: 10px 0;\n}\n.__mpx_actionsheet__ .__mpx_actionsheet_list__ .__mpx_actionsheet_sheet__::before {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform-origin: 0 0;\n  width: 100%;\n  border-top: 1px solid rgba(0,0,0,0.2);\n}\n@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 2dppx) {\n.__mpx_actionsheet__ .__mpx_actionsheet_list__ .__mpx_actionsheet_sheet__::before {\n    width: 200%;\n    transform: scale(0.5);\n}\n}\n@media (-webkit-min-device-pixel-ratio: 3), (min-resolution: 3dppx) {\n.__mpx_actionsheet__ .__mpx_actionsheet_list__ .__mpx_actionsheet_sheet__::before {\n    width: 300%;\n    transform: scale(0.333);\n}\n}\n.__mpx_actionsheet__ .__mpx_actionsheet_cancel__ {\n  font-size: 18px;\n  text-align: center;\n  color: #000;\n  background-color: #fcfcfd;\n  padding: 10px 0;\n  margin-top: 6px;\n}\n", ""]);

// exports


/***/ }),
/* 135 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToPromise": function() { return /* binding */ ToPromise; }
/* harmony export */ });
class ToPromise {
  constructor () {
    this._resolve = null
    this._reject = null
  }

  toPromiseInitPromise () {
    return new Promise((resolve, reject) => {
      this._resolve = resolve
      this._reject = reject
    })
  }

  toPromiseResolve (res) {
    this._resolve(res)
  }

  toPromiseReject (err) {
    this._reject(err)
  }
}




/***/ }),
/* 136 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isTabBarPage": function() { return /* binding */ isTabBarPage; },
/* harmony export */   "webHandleFail": function() { return /* binding */ webHandleFail; },
/* harmony export */   "webHandleSuccess": function() { return /* binding */ webHandleSuccess; }
/* harmony export */ });
function webHandleSuccess (result, success, complete) {
  typeof success === 'function' && success(result)
  typeof complete === 'function' && complete(result)
}

function webHandleFail (result, fail, complete) {
  typeof fail === 'function' && fail(result)
  typeof complete === 'function' && complete(result)
}

function isTabBarPage (url, router) {
  const tabBarPagesMap = __webpack_require__.g.__tabBarPagesMap
  if (!tabBarPagesMap || !url) return false
  const path = router.match(url, router.history.current).path
  return !!tabBarPagesMap[path.slice(1)]
}




/***/ }),
/* 137 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hideLoading": function() { return /* binding */ hideLoading; },
/* harmony export */   "hideToast": function() { return /* binding */ hideToast; },
/* harmony export */   "showLoading": function() { return /* binding */ showLoading; },
/* harmony export */   "showToast": function() { return /* binding */ showToast; }
/* harmony export */ });
/* harmony import */ var _Toast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(138);


let toast = null

function showToast (options = { title: '' }) {
  if (!toast) { toast = new _Toast__WEBPACK_IMPORTED_MODULE_0__["default"]() }
  return toast.show(options, 'toast')
}

function hideToast (options = {}) {
  if (!toast) { return }
  return toast.hide(Object.assign({ duration: 0 }, options), 'toast')
}

function showLoading (options = { title: '' }) {
  if (!toast) { toast = new _Toast__WEBPACK_IMPORTED_MODULE_0__["default"]() }
  return toast.show(Object.assign({
    icon: 'loading',
    duration: -1
  }, options), 'loading')
}

function hideLoading (options = {}) {
  if (!toast) { return }
  return toast.hide(Object.assign({
    icon: 'loading',
    duration: 0
  }, options), 'loading')
}




/***/ }),
/* 138 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Toast; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136);
/* harmony import */ var _common_stylus_Toast_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(139);
/* harmony import */ var _common_stylus_Toast_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_common_stylus_Toast_styl__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_stylus_Loading_styl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(141);
/* harmony import */ var _common_stylus_Loading_styl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_common_stylus_Loading_styl__WEBPACK_IMPORTED_MODULE_1__);




function createDom (tag, attrs = {}, children = []) {
  const dom = document.createElement(tag)
  Object.keys(attrs).forEach(k => dom.setAttribute(k, attrs[k]))
  children.length && children.forEach(child => dom.appendChild(child))
  return dom
}

class Toast {
  constructor () {
    this.defaultOpts = {
      title: '',
      icon: 'success',
      image: '',
      duration: 1500,
      mask: false,
      success: () => {},
      fail: () => {},
      complete: () => {}
    }
    this.hideTimer = null
    this.type = null

    // create & combine toast
    this.toast = createDom('div', { class: '__mpx_toast__' }, [
      this.mask = createDom('div', { class: '__mpx_mask__' }),
      this.content = createDom('div', { class: '__mpx_toast_box__' }, [
        this.icon = createDom('div', { class: '__mpx_toast_icon__' }),
        this.title = createDom('div', { class: '__mpx_toast_title__' })
      ])
    ])

    // loading animation dom
    this.loading = createDom('div', { class: '__mpx_loading_wrapper__' }, Array.from({ length: 12 }, (_, i) => {
      return createDom('div', { class: `line${i + 1}` })
    }))

    document.body.appendChild(this.toast)
  }

  show (options, type) {
    if (this.hideTimer) {
      clearTimeout(this.hideTimer)
      this.hideTimer = null
    }

    const opts = Object.assign({}, this.defaultOpts, options)

    this.type = type

    if (opts.mask) {
      this.mask.classList.add('show')
    } else {
      this.mask.classList.remove('show')
    }

    if (opts.icon === 'loading') {
      this.icon.parentNode && this.content.replaceChild(this.loading, this.icon) // if loading, replace with loading dom
    } else {
      this.loading.parentNode && this.content.replaceChild(this.icon, this.loading) // set icon to default

      const defaultIconClass = '__mpx_toast_icon__'

      const iconClass = opts.image
        ? '' // image
        : opts.icon === 'none'
          ? 'hide' // none
          : opts.icon === 'error'
            ? 'error'
            : 'success' // default

      this.icon.className = `${iconClass} ${defaultIconClass}`
      this.icon.style.cssText = opts.image && `background-image: url(${opts.image})`
    }

    this.title.textContent = opts.title || ''

    this.toast.classList.add('show')

    opts.duration >= 0 && this.hide({ duration: opts.duration }, type)

    const errMsg = type === 'loading' ? 'showLoading:ok' : 'showToast:ok'
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)({ errMsg }, opts.success, opts.complete)
    return Promise.resolve({ errMsg })
  }

  hide (options = {}, type) {
    if (this.type !== type) return

    const duration = options.duration || 0
    const errMsg = type === 'loading' ? 'hideLoading:ok' : 'hideToast:ok'
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)({ errMsg }, options.success, options.complete)

    if (this.hideTimer) {
      clearTimeout(this.hideTimer)
      this.hideTimer = null
    }

    this.hideTimer = setTimeout(() => { this.toast.classList.remove('show') }, duration)
    return Promise.resolve({ errMsg })
  }
}


/***/ }),
/* 139 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(140);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("14eca26b", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.__mpx_toast__ {\n  display: none;\n}\n.__mpx_toast__.show {\n  display: block;\n}\n.__mpx_toast__ .__mpx_mask__ {\n  position: fixed;\n  z-index: 1000;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  display: none;\n}\n.__mpx_toast__ .__mpx_mask__.show {\n  display: block;\n}\n.__mpx_toast__ .__mpx_toast_box__ {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  z-index: 2000;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  min-width: 100px;\n  max-width: 80%;\n  overflow: hidden;\n  text-align: center;\n  line-height: 1.6;\n  color: #fff;\n  word-break: normal;\n  padding: 15px 6px;\n  border-radius: 5px;\n  background: rgba(20,20,20,0.7);\n  transform: translate(-50%, -50%);\n}\n.__mpx_toast__ .__mpx_toast_box__ .__mpx_toast_icon__ {\n  width: 40px;\n  height: 40px;\n  background-size: 100%;\n  background-color: transparent;\n  background-repeat: no-repeat;\n  background-position-y: center;\n  margin: 6px auto;\n}\n.__mpx_toast__ .__mpx_toast_box__ .__mpx_toast_icon__.hide {\n  display: none;\n  height: 0;\n  margin: 0;\n}\n.__mpx_toast__ .__mpx_toast_box__ .__mpx_toast_icon__.success {\n  background-image: url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTczMDE0ODkyMTM3IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjY1OTAiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iNjQiIGhlaWdodD0iNjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTEyMi4yODA5NiA1MzYuNjIzMTA0Yy05Ljk0MDk5Mi05LjkyNTYzMi0xMS41NDg2NzItMjUuMzYwMzg0LTIuNzg1MjgtMzYuNDA3Mjk2bDIwLjQ4NzE2OC0yNS44MjgzNTJjOC4zOTc4MjQtMTAuNTg4MTYgMjQuMTA4MDMyLTEzLjI0NjQ2NCAzNS4yMTEyNjQtNS44MzU3NzZsMTc3LjMzMTIgMTE4LjM1OTA0YzkuMzUzMjE2IDYuMjQzMzI4IDI1LjQ1MjU0NCA1LjQzMDI3MiAzNC4xODUyMTYtMS42NTQ3ODRsNDY4LjU4MjQtMzgwLjE2YzEwLjUzMjg2NC04LjU0NTI4IDI3LjAzMDUyOC03LjgxNzIxNiAzNi4yNjE4ODggMS40MDA4MzJsMTEuNTQyNTI4IDExLjUyNTEyYzEwLjA0NTQ0IDEwLjAzMDA4IDkuMzE0MzA0IDI1Ljk1MTIzMi0xLjIxNTQ4OCAzNi40NjU2NjRsLTUwMi45MjczNiA1MDIuMTgzOTM2Yy0xNS42NDY3MiAxNS42MjQxOTItNDEuMzM3ODU2IDE0Ljk0MDE2LTU3LjQ0NTM3Ni0xLjE0Mjc4NGwtMjE5LjIyODE2LTIxOC45MDU2eiIgZmlsbD0iI2ZmZmZmZiIgcC1pZD0iNjU5MSI+PC9wYXRoPjwvc3ZnPg==\");\n}\n.__mpx_toast__ .__mpx_toast_box__ .__mpx_toast_icon__.error {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAW+UlEQVR4Xu2dC5RdVXnHv+/cmcyM1tFGS0RU5JFamZLM7L1vwiMJDFQE0SKo5aWtFXzXtqLGYq2EZX1Ro32pCPiqiqhogSpQXhEJIcw9+9wZNDxKEC2+WYQ1g02GzL3n69rhgiEhmbv32ed1z3fWmjUsZu/v8f/2L+e1z94IfLACrMAeFUDWhhVgBfasAAPCo4MV2IsCDAgPD1aAAeExwAq4KcBnEDfduFdFFGBAKlJoTtNNAQbETTfuVREFGJCKFJrTdFOAAXHTjXtVRAEGpCKF5jTdFGBA3HTjXhVRgAHJsNDr1q3rGxgYGEbE4QULFgwT0Y6fWq2243cQBMNxHA8Q0UwQBNOION1ut2cQcQYApmdnZ2f22Wef6cWLFz+aYdiVdsWAeC7/hg0bhgYGBhYDwMHmBxF3/DcRmd/7+XBHRFsQ8V4A2BzH8eYgCO4los1DQ0P3joyMbPHhg208pgADknAkTE5OjsVxfBwAHO8TAtewdoLn5lqtdm2r1VqvlJpztVf1fgyI5QjQWpszwwoAOIqIjkfE51qayLr5dgC4FhFvJKJbpZQ66wDK7I8B6aJ6URQdS0QnIuKRRLSsiy5FbnIPANwax/H1iHiVUmprkYPNOzYGZA8VCMPwjwDgZAB4FSKWHYo9jbP/BYCrEPFKIcQNeQ/GIvpnQHaqyt133/2MrVu3nhzH8cmI+KoiFizFmCIDSxzHV9Xr9WaKfkplmgEBgGazWY/j+C8MFETk5UlTqUbBLsEi4vVEdLmU8qIy5+Ej9koD0mw2j4zj+GwAeIMPMXvNBiKGRHRxlUGpJCBa62MQ8SwiOqPXBnVK+YRBEFw0NjZ2cUr2C2u2UoA0Go0TgiA4CwBeXdiKFDuwEAAuklJWBpRKAKK1XomI7yaik4o9/koTXYiInxRCfL00ETsG2tOATE5O7tdut98DAH/rqA9324sC5kYeEddKKTf2qlA9C0gYhu80Zw0A2L9Xi1eQvNoAsHZ2dnbtkUce+ZuCxOQtjJ4DJAxD88bbgDHuTSU21I0CmwHgE1LKz3XTuCxtegaQiYmJ5/b19f0jEZmbcD7yU+C6IAjOHxsb25BfCP489wQgWuvjAeACADjUnzRsKYEC/0dEq5VSn0lgoxBdSw9IGIbnIuJHCqEmB/EkBYjokm3btq1euXLlw2WVprSARFG0PxGZs8aflVX8isRt3sabs8m6MuZbSkCazeZJ7Xb7AkT8wzKKXsGYWwCwWkr5qbLlXjpAtNbnAcCasgnN8QIg4n9MT0+fNT4+boApxVEqQLTWnwSAd5VCWQ5yTwrcQESvUUpNl0Gi0gCitf48ALyxDKJyjPMqMEVEJyilfjlvy5wblAKQKIq+Zf7VyVkrdu9XgV8S0Uql1H1+zfq1VnhAwjC8DhFf6jdttlYQBcy9iJRS3lGQeHYLo9CARFG0joiOLqp4HJc3BQ4v6oTHwgKitb4eAP7EWwnYUNEVWFrEM0khAQnD8GJENJ/C8lEhBfr6+hYtXbq0UDOCCweI1vr9APDhCo0LTrWjACI+OD09/cLx8fHZoohSKEDCMHwbIpZ+gltRilvSONZJKY8pSuyFASSKojcSkXnXwUfFFTCTHJVSbyqCDIUARGt9JgB8tQiCcAzFUICIPqmUMh++5XrkDojW2izv+Z1cVWDnRVVgjZTy/DyDyxWQRqPx4iAIrgWAF+UpAvsurgKI+FohxOV5RZgrIGEYfg8RX55X8uy3FAo8gIjHCyHuzCPa3ADRWpuPnd6bR9Lss3QKXCulPCGPqHMBRGtt1sL9Yh4Js89yKpDXTXvmgJiV1InoWiJaWM5ScdR5KWAWGq/X65m+CsgUkKmpqae3Wi1zU262MOODFbBVwHxkdXyWExszBURr/U8AYJYC5eMpFCCiSUQ0T/SexQI9tQKIeIMQIrPPHzIDZHJycrzdbt/Ehd9NgdsQ8cLt27ffdNhhh/3M/NUstg0AxwKA+f6ej10UIKJ3K6XM59epH5kBEkXRdUSUGfmpK+fHgdmc5s17MtVsNo+O4/hSANjXj7uesfIgEa1SSt2ddkaZAKK1Nqurl27Jl5TFP01K+Y1ufERR9CsiWtRN26q0QcQvCyFS3xksdUA6b8t/AAD7VKV48+VpW9yJiYlVtVrt5vnsVvDvXf8j46pN6oBorc37jtRJdxUgj35xHK+o1+u32vjWWl8JAH9q06fX2yLi5NatW1etWLHikbRyTRUQrbVZFrSry4i0EiygXdq2bdszbYvKMw/2WMmPSCn/Pq06pw1IAwBUWsGX1O7dUsqX2MYehuEZiPg1234VaE8AMJrW9+ypAdJoNE4PgsA8geFjJwWI6PtKKevNfRqNxtFBEJRyAei0B4DZBk4Ikcr7tdQA0VpfY956pi1O2ewzIKlU7EFEHBVC/MK39VQAaTQaLw2C4DrfwfaCPQYknSoS0blKqY/5tp4KIFrrrwDA63wH2wv2GJDUqnjX4ODg6MjIyHafHrwD0mg0xoIgiHwG2Uu2GJD0qklEb1JKXeLTg3dAtNbmjTnvS76HKjEgPofvbrZukVKu8unBKyATExMvqNVqTQB4ts8ge8kWA5JuNYnoZKXUFb68eAUkiqJziGitr+B60Q4DknpVL5NSnu7Li1dAtNZmzpWZqs0HX2LlNQZmW63WIcuXL7/fRwDeAAnDcAUi3uIjqF62wWeQTKp7jq8NQ30CshYRz8kk/RI7YUAyKZ63m3UvgFx99dUDixYtMusWHZhJ+iV2woBkU7wgCFaMjY1ZzZh+qsi8AKK1PhUALssm9XJ7YUCyqZ95WKSUSjw/ywsgURR9nYhOyyb1cnthQDKr332Dg4OHJH2znhiQqampA1qt1l0AMJBZ6iV2xIBkWrxTpZTfTOIxMSBa67cAwIVJgqhSXwYk02p/UUr5xiQeEwMShuGliOjtxUySZMrQlwHJrkpE9GOl1EFJPCYGRGv9cwB4XpIgqtSXAcm22oh4hBDiNleviQCJomgVEfFqGxbqMyAWYvlp+gEppfOmsEkBOZ+IPugnj2pYYUCyrTMRXa+UOs7VayJAeO6VvewMiL1mCXtsJ6LfU0rNudhxBmTDhg1DAwMDW12cVrkPA5JL9U+QUppdBawPZ0C01q8EgKusPVa8AwOS/QBI8lY9CSAfB4DV2adbbo8MSC712yilPNzFcxJAvg0Ap7g4rXIfBiSX6j8kpXyOi+ckgEwBwBIXp1Xuw4DkU/3+/v6FS5YsedjWexJAzA36kK3DqrdnQPIZAXEcL6/X6xO23p0AmZyc3K/dbu/YDYkPOwUYEDu9PLZ+nZTSem1jJ0B4nVj3sjEg7tol7LlGSnm+rQ0nQMIwPBsRL7Z1xu0BGJB8RgERfU0pZb3apxMgWmt+xOtYZwbEUbjk3W6XUh5ma8YVEH7Ea6t0pz0D4ihcwm5EtEUpZb2goSsgGwDA6cVLwjxL350Bya+Ew8PDg4sXL37UJgInQKIo+hERjdg44raPKcCA5DcSEHEfIcSDNhE4ARKG4QOI+HwbR9yWAcl7DBDRwUqp+2zicAVkGhGHbRxxWwYk7zFQq9XE6OioWVy968MJEK212TiRDwcF+BLLQTRPXRDxaCGE1Rew1oBs3LhxuL+/f9pTzJUzw4DkV/I4jk+q1+tWn2hYAzI1NfX8Vqv1QH5pltszA5Jr/V4vpfyqTQTWgERRdAgRbbJxwm1/pwADkt9oIKJ3KKU+YxOBCyCHE5F5D8KHgwIMiINonrq47IRrDYjW2ryud15nyFOupTXDgORXukwA4UusZAVmQJLpl6Q3Eb1dKfVZGxvWZxD+FsRG3t3bMiDJ9EvSOwiCM8fGxi61sWENyPr1658xNDQ0Y+OE2/JNekHGwCullN+1icUaEGNca90GgMDGEbd9TAE+g+Q6ElZJKa320XQFxHz8/qxcUy2pcwYkv8Ih4qgQwiw20vXhCshPAGD/rr1wwycUYEDyGwytVutA2+2hXQHhJX8c68yAOArnodvg4OCzR0ZGttiYcgXEXMetsHHEbfkeJO8xMDMz0z8+Pt6yicMVEDOf5UwbR9yWAclzDCDiz4QQL7CNwQmQRqOxJgiC82ydcXt+ipXXGEDE7wshxm39OwGitTZnD6tZkbaB9Wp7vgfJrbIXSynfbOvdCZAwDJcj4kZbZ9weABEnhBDLbbUIw/BERLR6yWXro8fbv09KeYFtjk6AbNq0aeHs7OxDts64/Q5AfiuEeIatFlrr9wKAdYFt/fRw+1OklP9pm58TIMZJGIYPIeJCW4fcfocCS6WUd9hoobX+CgBYrwxo46OX2xLREqXUD21zdAZEa20usawvFWwD7NH2n5NSvrXb3DqXtDcBwNO67cPtnqzAwoULhw444IBZW12SAMKPem3VfnL7rvfN01qHACCTuatubyL6mVLK+hGvUSwJIOYx75rqyp44c4rjeEm9Xv/R3ixprf8ZAP4msbdqG1gnpTzGRQJnQJrN5hFxHN/q4pT7PEmBj8RxfHm9Xn9ivaYoip4HAAoAzD70o6xXMgWI6P1KqY+6WHEGxDiLougRswe1i2Pus5sCZseuuwDgDwDghayPPwUQsS6EMJep1kciQLTW3wGAk629cgdWICMFXFd1fzy8RIA0m823x3H86YxyZTesgIsCl0kpT3fpaPokBWQ0jmOrtU5dA+V+rICLAoj4NiHEhS59EwNiDGitNwPAQa4BcD9WIGUFrF/K7hxPojNIB5AvAMBfppwkm2cFXBS4S0p5iEtHL/cgxghv6JlEfu6bpgJE9Hml1NlJfCQ+gzQajQNrtdqdRDSQJBDuywqkoMCpUspvJrGbGJDOZdZlAHBqkkC4LyvgUwEi+vHQ0NBLRkZGtiex6wsQA4eBhA9LBYho0nztRkQ312q178/Nzb2oVqsdDQBHAYD5zcsrWWpqmiPiWiHEexy6PqmLF0CuvvrqgUWLFt0JAAcmDahC/X+BiP8ghDAPOZ7yuP322w/o6+v7EH//bz8qiGilUmq9fc8n9/ACiDEZhuFaRDwnaUAV6f8lKWXXT/601i9DxEuJiL+/6W6A3CKlXNVd07238gbI5OTkina7bbWso48EymYDEU8XQjhdjmqtf9OZq1W2tLOO9xwp5ad8OPUGiAlGa/0DAFjpI7BetEFElyil3uSam9Z6CQBYLZ3p6qvE/WZbrdYhtiso7ilfr4BEUXQOEa0tsbiphW6eqvT39x++dOlScxZwPqIo+jsicpq67ey0XB0Tzb3aNVWvgGzcuPH5/f39EV8G7D6iiOi9SqlPJB1rRITNZvPXRGSmxfOxiwKIeJIQwmon272J6BWQzmWWWXnDrMDBx04KENErlFLf8yFKFEU3E5GXm1Af8RTIxk1SymN9xpMGIC8BADPDl9+s71SpwcHBfUdGRn7lo3hRFF1IRG/xYavHbFhv8zxf/t4B6ZxFzPRiLuDv1H9ASuntK0GttdHWeQr3fIOijH9HxIYQYpnv2FMBhFde3K1MDSmlt+JprV8JAN6us30PqjzsueyB3k2cqQBiHEdR9DUiOqObICrQZk4IMYSIZuu6xEcURR8gIvOGnY/HFLiHiIRSynzX7/VIDZBGo/HSIAiu8xptiY212+1ly5Yta/hIQWt9OQC82oetXrDhsv95t3mnBkjnLHIFEZ3UbTA93u4tUsqLfOSotb4XAA72YasHbPx0wYIFyw899NBfp5FLqoB07kXM9JP+NIIvmc3bpJRHJI1Za/0OAPj3pHZ6qP9bpZSfSyufVAHpnEXM4mcfTCuBMtlFxEuEEM5TTcyCcuaNPD9Cf6LqV0kpU71CSR2Q+++/f3DLli3mLGJWCqz8kWQattbazFIYq7yIjwlg9hpcKaVMdZ+a1AExmWitTwGAb3NhdyhAQRC8eGxszNxHdH2EYfgviPjXXXfo8YaI+CEhROpXJpkAYmoVhuEliHhWj9fNJr13SSnNwtR7PSYmJuq1Ws18VPXH87Wt0N+1mWqTxmPdXTXMEpCDENFcau1boULOl+oNiPiddrt9h1LqdkTcsUVxs9l8UavVUkEQjPAK+rtLiIivEUJkckWSGSAmzSiK3klE/zrfqKno3w0cZtep5wKAWd2dj6dW4AtSysyuRDIFpHOp9VVE5D3WefhbK0BEP4zj+Lhly5Z5mfTZTQCZA2IeVcZxfB0imssHPlgBGwW63pXLxuje2mYOSOca++VxHHv5NsKXEGyn2Aog4rlCiI9lHWUugJgktdbvB4APZ50w+yulAt+QUp6WR+S5AdK5af8mEb02j8TZZ2kUuAcRXyaE+GkeEecKSGdhNDPjlyfe5VH9EviM4/hV9Xr9yrxCzRWQzqWW2cLNbOXGByuwqwJrpJTn5ylL7oB0LrXeSkSfzVMI9l0sBXxsXeAjo0IAYhIJw/CDiJjrvxY+BGUbXhT4bynl8V4sJTRSGEA6l1v/BgB/lTAn7l5uBe6UUhbmHVmhAOlAwnuNlHuAO0dPRI8MDQ09b2Rk5LfORjx3LBwgHUj+CwBe4TlXNldwBfr6+g5cunTp/UUKs5CAdCC5CQDGiyQWx5KeAkR0mJnRnJ4HN8uFBaTzdOvLRPTnbqlxr7IoQEQHK6XuK2K8hQakcyY5j7+JKOLQSR4TIv5kbm5OLV++/KHk1tKxUHhATNphGL4dET+djgRsNScFvktEpyil5nLy35XbUgBiMmk0GmcFQXBJV1lxo0IrgIgXCiHeVuggO8GVBpDO5dbrAOArZRCWY9yjAhdIKd9XFn1KBUgHEjN3y+xBwhMcyzLKHoszJqLVSqlS7UBWOkCM0mYWcH9//8d5qnxpCNGI+D4hxI2libiMl1i7issfXRV/uCHi5wcGBlaPjIxsKX60u0dYyjPIzmk0m82Xt9vtC/gb98INv20AsFpKWep1hEsPiBkWnYUgDCS8WkoxOLmtc7+xvhjhuEfRE4A8nn5n3a1zeXE69wHhoecnZmZmzh8fHy/MhMMkOfUUIEaIMAwPAoBzeZnTJMPCvi8RXQ8AH1VKrbPvXdwePQfI41J3Fsw2ZxNeVT7d8fcbA0Y36wynG0Y61nsWECOX2Xrh4YcfPtds0cWb+KQygL5Uq9U+Ojo6+j+pWC+A0Z4G5HF9zU5XQRAYUFLdbKUA9cwqBLO6+seVUt/KymFefioByE438ScQkVn4mDfAdBtxGgAu8rXXolsI2faqFCA73Z8cQ0RnI+Lp2cpdWm+VA+PxSlUSkJ0uvVZ0nna9obRDN93AKwsGA7LTwGo2m3Uiej0RnQgAB6Y75kph/RoAuKJKl1J7qkqlzyC7ikJEtWazeWIHFAPLfqUYzn6CvAYRryGia6SUm/2YLL8VBmQPNQzD8GkAYCA5ERHN7+eUv9y7ZcBQzFNUBqSLUX/HHXf8/tzc3HGIeBQRHQUAh3TRrYhNfkFENyPizQBwI58p5i8RAzK/Rru1CMPwUEQ8FgCOAQADzLCDmay63IKIZvrHjUKIH2TltFf8MCAeKhmGoXkaZoBZbL50JKLFiLjQg2kbE2Z6udl73dw/mJ/1jz766A1HHHGE+f98OCrAgDgKN1+3TZs2Ldy2bZsBxXwavAMcANi/c7YZRsThOI6fiYi1+WwBwCMAMAMA052fXxoIiOheItrc399/7+jo6M+7sMNNLBVgQCwF8918amrq6XNzc8NENNzX1zfcbrcHFixYMN1qtWYQcfrKK6+cWbNmTezbL9vrTgEGpDuduFVFFWBAKlp4Trs7BRiQ7nTiVhVVgAGpaOE57e4UYEC604lbVVQBBqSihee0u1OAAelOJ25VUQUYkIoWntPuTgEGpDuduFVFFWBAKlp4Trs7BRiQ7nTiVhVVgAGpaOE57e4U+H8jfYFBjKc7iwAAAABJRU5ErkJggg==\");\n}\n.__mpx_toast__ .__mpx_toast_box__ .__mpx_toast_title__ {\n  font-size: 12px;\n  margin: 0;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n}\n", ""]);

// exports


/***/ }),
/* 141 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(142);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("60ac584b", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.__mpx_loading_wrapper__ {\n  width: 40px;\n  height: 40px;\n  position: relative;\n  margin: 6px auto;\n  display: inline-block;\n}\n.__mpx_loading_wrapper__ div {\n  width: 2px;\n  height: 10px;\n  border-radius: 1px;\n  background: #bec2cb;\n  position: absolute;\n  left: 50%;\n  top: 41%;\n}\n.__mpx_loading_wrapper__ .line1 {\n  opacity: 1;\n  transform: rotate(0deg) translate(0, -13px);\n  animation: __mpx__loading0_start__ 0s linear 1, __mpx__loading__ 1.2s linear 0s infinite;\n}\n@-moz-keyframes __mpx__loading0_start__ {\nfrom {\n    opacity: 0;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading0_start__ {\nfrom {\n    opacity: 0;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading0_start__ {\nfrom {\n    opacity: 0;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading0_start__ {\nfrom {\n    opacity: 0;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line2 {\n  opacity: 0.9167;\n  transform: rotate(30deg) translate(0, -13px);\n  animation: __mpx__loading1_start__ 0.1s linear 1, __mpx__loading__ 1.2s linear 0.1s infinite;\n}\n@-moz-keyframes __mpx__loading1_start__ {\nfrom {\n    opacity: 0.0833;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading1_start__ {\nfrom {\n    opacity: 0.0833;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading1_start__ {\nfrom {\n    opacity: 0.0833;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading1_start__ {\nfrom {\n    opacity: 0.0833;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line3 {\n  opacity: 0.8334;\n  transform: rotate(60deg) translate(0, -13px);\n  animation: __mpx__loading2_start__ 0.2s linear 1, __mpx__loading__ 1.2s linear 0.2s infinite;\n}\n@-moz-keyframes __mpx__loading2_start__ {\nfrom {\n    opacity: 0.1666;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading2_start__ {\nfrom {\n    opacity: 0.1666;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading2_start__ {\nfrom {\n    opacity: 0.1666;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading2_start__ {\nfrom {\n    opacity: 0.1666;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line4 {\n  opacity: 0.7501;\n  transform: rotate(90deg) translate(0, -13px);\n  animation: __mpx__loading3_start__ 0.3s linear 1, __mpx__loading__ 1.2s linear 0.3s infinite;\n}\n@-moz-keyframes __mpx__loading3_start__ {\nfrom {\n    opacity: 0.2499;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading3_start__ {\nfrom {\n    opacity: 0.2499;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading3_start__ {\nfrom {\n    opacity: 0.2499;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading3_start__ {\nfrom {\n    opacity: 0.2499;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line5 {\n  opacity: 0.6668;\n  transform: rotate(120deg) translate(0, -13px);\n  animation: __mpx__loading4_start__ 0.4s linear 1, __mpx__loading__ 1.2s linear 0.4s infinite;\n}\n@-moz-keyframes __mpx__loading4_start__ {\nfrom {\n    opacity: 0.3332;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading4_start__ {\nfrom {\n    opacity: 0.3332;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading4_start__ {\nfrom {\n    opacity: 0.3332;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading4_start__ {\nfrom {\n    opacity: 0.3332;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line6 {\n  opacity: 0.5835;\n  transform: rotate(150deg) translate(0, -13px);\n  animation: __mpx__loading5_start__ 0.5s linear 1, __mpx__loading__ 1.2s linear 0.5s infinite;\n}\n@-moz-keyframes __mpx__loading5_start__ {\nfrom {\n    opacity: 0.4165;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading5_start__ {\nfrom {\n    opacity: 0.4165;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading5_start__ {\nfrom {\n    opacity: 0.4165;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading5_start__ {\nfrom {\n    opacity: 0.4165;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line7 {\n  opacity: 0.5002;\n  transform: rotate(180deg) translate(0, -13px);\n  animation: __mpx__loading6_start__ 0.6s linear 1, __mpx__loading__ 1.2s linear 0.6s infinite;\n}\n@-moz-keyframes __mpx__loading6_start__ {\nfrom {\n    opacity: 0.4998;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading6_start__ {\nfrom {\n    opacity: 0.4998;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading6_start__ {\nfrom {\n    opacity: 0.4998;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading6_start__ {\nfrom {\n    opacity: 0.4998;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line8 {\n  opacity: 0.4169;\n  transform: rotate(210deg) translate(0, -13px);\n  animation: __mpx__loading7_start__ 0.7s linear 1, __mpx__loading__ 1.2s linear 0.7s infinite;\n}\n@-moz-keyframes __mpx__loading7_start__ {\nfrom {\n    opacity: 0.5831;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading7_start__ {\nfrom {\n    opacity: 0.5831;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading7_start__ {\nfrom {\n    opacity: 0.5831;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading7_start__ {\nfrom {\n    opacity: 0.5831;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line9 {\n  opacity: 0.3336;\n  transform: rotate(240deg) translate(0, -13px);\n  animation: __mpx__loading8_start__ 0.8s linear 1, __mpx__loading__ 1.2s linear 0.8s infinite;\n}\n@-moz-keyframes __mpx__loading8_start__ {\nfrom {\n    opacity: 0.6664;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading8_start__ {\nfrom {\n    opacity: 0.6664;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading8_start__ {\nfrom {\n    opacity: 0.6664;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading8_start__ {\nfrom {\n    opacity: 0.6664;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line10 {\n  opacity: 0.2503;\n  transform: rotate(270deg) translate(0, -13px);\n  animation: __mpx__loading9_start__ 0.9s linear 1, __mpx__loading__ 1.2s linear 0.9s infinite;\n}\n@-moz-keyframes __mpx__loading9_start__ {\nfrom {\n    opacity: 0.7497;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading9_start__ {\nfrom {\n    opacity: 0.7497;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading9_start__ {\nfrom {\n    opacity: 0.7497;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading9_start__ {\nfrom {\n    opacity: 0.7497;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line11 {\n  opacity: 0.167;\n  transform: rotate(300deg) translate(0, -13px);\n  animation: __mpx__loading10_start__ 1s linear 1, __mpx__loading__ 1.2s linear 1s infinite;\n}\n@-moz-keyframes __mpx__loading10_start__ {\nfrom {\n    opacity: 0.833;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading10_start__ {\nfrom {\n    opacity: 0.833;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading10_start__ {\nfrom {\n    opacity: 0.833;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading10_start__ {\nfrom {\n    opacity: 0.833;\n}\nto {\n    opacity: 0;\n}\n}\n.__mpx_loading_wrapper__ .line12 {\n  opacity: 0.0837;\n  transform: rotate(330deg) translate(0, -13px);\n  animation: __mpx__loading11_start__ 1.1s linear 1, __mpx__loading__ 1.2s linear 1.1s infinite;\n}\n@-moz-keyframes __mpx__loading11_start__ {\nfrom {\n    opacity: 0.9163;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading11_start__ {\nfrom {\n    opacity: 0.9163;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading11_start__ {\nfrom {\n    opacity: 0.9163;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading11_start__ {\nfrom {\n    opacity: 0.9163;\n}\nto {\n    opacity: 0;\n}\n}\n@-moz-keyframes __mpx__loading__ {\nfrom {\n    opacity: 1;\n}\nto {\n    opacity: 0;\n}\n}\n@-webkit-keyframes __mpx__loading__ {\nfrom {\n    opacity: 1;\n}\nto {\n    opacity: 0;\n}\n}\n@-o-keyframes __mpx__loading__ {\nfrom {\n    opacity: 1;\n}\nto {\n    opacity: 0;\n}\n}\n@keyframes __mpx__loading__ {\nfrom {\n    opacity: 1;\n}\nto {\n    opacity: 0;\n}\n}\n", ""]);

// exports


/***/ }),
/* 143 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "showModal": function() { return /* binding */ showModal; }
/* harmony export */ });
/* harmony import */ var _Modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(144);


let modal = null

function showModal (options = {}) {
  if (!modal) { modal = new _Modal__WEBPACK_IMPORTED_MODULE_0__["default"]() }
  return modal.show(options)
}




/***/ }),
/* 144 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Modal; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(135);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136);
/* harmony import */ var _common_stylus_Modal_styl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(145);
/* harmony import */ var _common_stylus_Modal_styl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_common_stylus_Modal_styl__WEBPACK_IMPORTED_MODULE_0__);


// import { forEach } from '@didi/mpx-fetch/src/util'
// 汉字为两个字符，字母/数字为一个字符
const _getLength = (t) => {
  let len = 0
  for (let i = 0; i < t.length; i++) {
    if (t.charCodeAt(i) > 127 || t.charCodeAt(i) === 94) {
      len += 2
    } else {
      len++
    }
  }
  return len
}
class Modal extends _common_js__WEBPACK_IMPORTED_MODULE_1__.ToPromise {
  constructor () {
    super()
    this.defaultOpts = {
      title: '',
      content: '',
      showCancel: true,
      cancelText: '取消',
      cancelColor: '#000000',
      confirmText: '确定',
      confirmColor: '#576B95',
      success: (...args) => {},
      fail: (...args) => {},
      complete: (...args) => {}
    }
    this.hideTimer = null

    const modal = document.createElement('div')
    modal.setAttribute('class', '__mpx_modal__')

    const mask = document.createElement('div')
    mask.setAttribute('class', '__mpx_mask__')

    const box = document.createElement('div')
    box.setAttribute('class', '__mpx_modal_box__')

    const title = document.createElement('div')
    title.setAttribute('class', '__mpx_modal_title__')

    const content = document.createElement('div')
    content.setAttribute('class', '__mpx_modal_content__')

    const btns = document.createElement('div')
    btns.setAttribute('class', '__mpx_modal_btns__')

    const cancelBtn = document.createElement('div')
    cancelBtn.setAttribute('class', '__mpx_modal_cancel__')

    const confirmBtn = document.createElement('div')
    confirmBtn.setAttribute('class', '__mpx_modal_confirm__')

    btns.appendChild(cancelBtn)
    btns.appendChild(confirmBtn)
    box.appendChild(title)
    box.appendChild(content)
    box.appendChild(btns)
    modal.appendChild(mask)
    modal.appendChild(box)
    document.body.appendChild(modal)

    this.modal = modal
    this.mask = mask
    this.box = box
    this.title = title
    this.content = content
    this.btns = btns
    this.cancelBtn = cancelBtn
    this.confirmBtn = confirmBtn
  }

  show (options = {}) {
    if (options.confirmText && _getLength(options.confirmText) > 8) {
      // eslint-disable-next-line
      return Promise.reject({errMsg: 'showModal:fail confirmText length should not larger than 4 Chinese characters'})
    }
    if (options.cancelText && _getLength(options.cancelText) > 8) {
      // eslint-disable-next-line
      return Promise.reject({errMsg: 'showModal:fail cancelText length should not larger than 4 Chinese characters'})
    }
    if (this.hideTimer) {
      clearTimeout(this.hideTimer)
      this.hideTimer = null
    }
    const opts = Object.assign({}, this.defaultOpts, options)

    this.title.textContent = opts.title
    this.content.textContent = opts.content

    if (!opts.showCancel) {
      this.cancelBtn.classList.add('hide')
    } else {
      this.cancelBtn.classList.remove('hide')
    }
    this.cancelBtn.style.color = opts.cancelColor
    this.cancelBtn.textContent = opts.cancelText

    this.confirmBtn.style.color = opts.confirmColor
    this.confirmBtn.textContent = opts.confirmText

    this.cancelBtn.onclick = () => {
      this.hide()
      const result = {
        errMsg: 'showModal:ok',
        cancel: true,
        confirm: false
      }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(result, opts.success, opts.complete)
      this.toPromiseResolve(result)
    }
    this.confirmBtn.onclick = () => {
      this.hide()
      const result = {
        errMsg: 'showModal:ok',
        cancel: false,
        confirm: true
      }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(result, opts.success, opts.complete)
      this.toPromiseResolve(result)
    }

    this.modal.classList.add('show')

    return this.toPromiseInitPromise()
  }

  hide () {
    if (this.hideTimer) {
      clearTimeout(this.hideTimer)
      this.hideTimer = null
    }

    this.hideTimer = setTimeout(() => {
      this.modal.classList.remove('show')
    }, 0)
  }
}


/***/ }),
/* 145 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(146);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("f2d8b9aa", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.__mpx_modal__ {\n  display: none;\n}\n.__mpx_modal__.show {\n  display: block;\n}\n.__mpx_modal__ .__mpx_mask__ {\n  position: fixed;\n  z-index: 1000;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  background: rgba(0,0,0,0.6);\n}\n.__mpx_modal__ .__mpx_modal_box__ {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  z-index: 3000;\n  overflow: hidden;\n  width: 80%;\n  max-width: 300px;\n  text-align: center;\n  line-height: 1.6;\n  background: #fff;\n  padding-top: 20px;\n  border-radius: 15px;\n  transform: translate(-50%, -50%);\n}\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_title__ {\n  font-size: 18px;\n  padding: 0 20px;\n}\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_content__ {\n  font-size: 17px;\n  line-height: 1.6;\n  color: #808080;\n  padding: 10px 20px 0;\n  word-break: break-all;\n  max-height: 45vh;\n  overflow-y: auto;\n  letter-spacing: 1px;\n}\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_btns__ {\n  position: relative;\n  display: flex;\n  line-height: 48px;\n  font-size: 18px;\n  margin-top: 25px;\n  font-weight: 500;\n}\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_btns__::before {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform-origin: 0 0;\n  width: 100%;\n  border-top: 1px solid rgba(0,0,0,0.2);\n}\n@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 2dppx) {\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_btns__::before {\n    width: 200%;\n    transform: scale(0.5);\n}\n}\n@media (-webkit-min-device-pixel-ratio: 3), (min-resolution: 3dppx) {\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_btns__::before {\n    width: 300%;\n    transform: scale(0.333);\n}\n}\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_cancel__ {\n  flex: 1;\n}\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_cancel__.hide {\n  display: none;\n}\n.__mpx_modal__ .__mpx_modal_box__ .__mpx_modal_confirm__ {\n  flex: 1;\n}\n", ""]);

// exports


/***/ }),
/* 147 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearStorage": function() { return /* binding */ clearStorage; },
/* harmony export */   "clearStorageSync": function() { return /* binding */ clearStorageSync; },
/* harmony export */   "getStorage": function() { return /* binding */ getStorage; },
/* harmony export */   "getStorageInfo": function() { return /* binding */ getStorageInfo; },
/* harmony export */   "getStorageInfoSync": function() { return /* binding */ getStorageInfoSync; },
/* harmony export */   "getStorageSync": function() { return /* binding */ getStorageSync; },
/* harmony export */   "removeStorage": function() { return /* binding */ removeStorage; },
/* harmony export */   "removeStorageSync": function() { return /* binding */ removeStorageSync; },
/* harmony export */   "setStorage": function() { return /* binding */ setStorage; },
/* harmony export */   "setStorageSync": function() { return /* binding */ setStorageSync; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126);


function setStorage (options = {}) {
  const { key, data, success, fail, complete } = options

  try {
    setStorageSync(key, data)

    const res = { errMsg: 'setStorage:ok' }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, success, complete)
    return Promise.resolve(res)
  } catch (err) {
    const res = { errMsg: `setStorage:fail ${err}` }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, fail, complete)
    return Promise.reject(res)
  }
}

function setStorageSync (key = '', data) {
  let obj = {}

  if (typeof data === 'symbol') {
    obj = { data: '' }
  } else {
    obj = { data }
  }
  window.localStorage.setItem(key, JSON.stringify(obj))
}

function getStorage (options = {}) {
  const { key, success, fail, complete } = options
  const { result, data } = getItem(key)

  if (result) {
    const res = { errMsg: 'getStorage:ok', data: data }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, success, complete)
    return Promise.resolve(res)
  } else {
    const res = { errMsg: 'getStorage:fail', data: null }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, fail, complete)
    return Promise.reject(res)
  }
}

function getStorageSync (key) {
  const res = getItem(key)
  if (res.result) return res.data

  return ''
}

function getItem (key) {
  let item
  try {
    item = JSON.parse(window.localStorage.getItem(key))
  } catch (e) {
  }

  if (item && typeof item === 'object' && (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(item, 'data')) {
    return { result: true, data: item.data }
  } else {
    return { result: false }
  }
}

function getStorageInfo (options = {}) {
  const { success, fail, complete } = options

  try {
    const info = getStorageInfoSync()

    const res = Object.assign({}, { errMsg: 'getStorageInfo:ok' }, info)
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, success, complete)
    return Promise.resolve(res)
  } catch (err) {
    const res = { errMsg: `getStorageInfo:fail ${err}` }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, fail, complete)
    return Promise.reject(res)
  }
}

function getStorageInfoSync () {
  return {
    keys: Object.keys(window.localStorage),
    limitSize: null,
    currentSize: null
  }
}

function removeStorage (options = { key: '' }) {
  const { key, success, fail, complete } = options

  try {
    removeStorageSync(key)

    const res = { errMsg: 'removeStorage:ok' }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, success, complete)
    return Promise.resolve(res)
  } catch (err) {
    const res = { errMsg: `removeStorage:fail ${err}` }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, fail, complete)
    return Promise.reject(res)
  }
}

function removeStorageSync (key) {
  window.localStorage.removeItem(key)
}

function clearStorage (options = {}) {
  const { success, fail, complete } = options

  try {
    clearStorageSync()

    const res = { errMsg: 'clearStorage:ok' }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, success, complete)
    return Promise.resolve(res)
  } catch (err) {
    const res = { errMsg: `clearStorage:fail ${err}` }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, fail, complete)
    return Promise.reject(res)
  }
}

function clearStorageSync () {
  window.localStorage.clear()
}




/***/ }),
/* 148 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSystemInfo": function() { return /* binding */ getSystemInfo; },
/* harmony export */   "getSystemInfoSync": function() { return /* binding */ getSystemInfoSync; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);


function getSystemInfoSync () {
  const ua = navigator.userAgent.split('(')[1].split(')')[0]
  const phones = new Map([
    ['iPhone', /iPhone|iPad|iPod|iOS/i],
    ['Huawei', /huawei/i],
    ['Xiaomi', /mi/i],
    ['Vivo', /vivo/i],
    ['Oppo', /OPPO/i],
    ['Samsung', /samsung/i],
    ['Sony', /SONY/i],
    ['Nokia', /Nokia/i],
    ['HTC', /HTC/i],
    ['ZTE', /ZTE/i],
    ['Lenovo', /Lenovo|ZUK/i]
  ])

  let brand = ''
  let system = ''

  for (const item of phones.entries()) {
    if (item[1].test(ua)) {
      brand = item[0]
      break
    }
  }

  !brand && (brand = 'Android')

  if (brand === 'iPhone') {
    system = `iOS ${ua.replace(/^.*OS ([\d_]+) like.*$/, '$1').replace(/_/g, '.')}`
  } else {
    system = `Android ${ua.replace(/^.*Android ([\d.]+);.*$/, '$1')}`
  }

  return {
    brand: brand,
    model: brand,
    pixelRatio: window.devicePixelRatio,
    screenWidth: window.screen.width,
    screenHeight: window.screen.height,
    windowWidth: document.documentElement.clientWidth,
    windowHeight: document.documentElement.clientHeight,
    statusBarHeight: null,
    language: navigator.language,
    version: null,
    system,
    platform: navigator.platform,
    fontSizeSetting: null,
    SDKVersion: null,
    benchmarkLevel: null,
    albumAuthorized: null,
    cameraAuthorized: null,
    locationAuthorized: null,
    microphoneAuthorized: null,
    notificationAlertAuthorized: null,
    notificationAuthorized: null,
    notificationBadgeAuthorized: null,
    notificationSoundAuthorized: null,
    bluetoothEnabled: null,
    locationEnabled: null,
    wifiEnabled: null,
    safeArea: null
  }
}

function getSystemInfo (options = {}) {
  const info = getSystemInfoSync()
  const res = Object.assign({ errMsg: 'getSystemInfo:ok' }, info)
  ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
  return Promise.resolve(res)
}




/***/ }),
/* 149 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNetworkType": function() { return /* reexport safe */ _getNetworkType__WEBPACK_IMPORTED_MODULE_0__.getNetworkType; },
/* harmony export */   "offNetworkStatusChange": function() { return /* reexport safe */ _onNetworkStatusChange__WEBPACK_IMPORTED_MODULE_1__.offNetworkStatusChange; },
/* harmony export */   "onNetworkStatusChange": function() { return /* reexport safe */ _onNetworkStatusChange__WEBPACK_IMPORTED_MODULE_1__.onNetworkStatusChange; }
/* harmony export */ });
/* harmony import */ var _getNetworkType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(150);
/* harmony import */ var _onNetworkStatusChange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(151);




/***/ }),
/* 150 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNetworkType": function() { return /* binding */ getNetworkType; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);


function getNetworkType ({ success, fail = () => {}, complete = () => {} }) {
  try {
    if (navigator.connection) {
      (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)({ networkType: navigator.connection.effectiveType }, success, complete)
    } else {
      (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)({ networkType: 'unknow' }, success, complete)
    }
  } catch (err) {
    (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(err, fail, complete)
  }
}


/***/ }),
/* 151 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "offNetworkStatusChange": function() { return /* binding */ offNetworkStatusChange; },
/* harmony export */   "onNetworkStatusChange": function() { return /* binding */ onNetworkStatusChange; }
/* harmony export */ });
/* harmony import */ var _common_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);

const fnMap = new Map()

const oldObserveList = new Set()

if (_common_js_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
  window.addEventListener('offline', () => {
    oldObserveList.forEach(fn => fn({ isConnected: false, type: 'none' }))
  })
  window.addEventListener('online', () => {
    oldObserveList.forEach(fn => fn({ isConnected: true, type: 'unknow' }))
  })
}

function onNetworkStatusChange (callbackFn) {
  if (navigator.connection) {
    const proxyCallback = evt => {
      const isConnected = navigator.onLine
      callbackFn({
        isConnected,
        type: isConnected ? evt.currentTarget.effectiveType : 'none'
      })
    }
    fnMap.set(callbackFn, proxyCallback)
    navigator.connection.addEventListener('change', proxyCallback)
  } else {
    typeof callbackFn === 'function' && oldObserveList.add(callbackFn)
  }
}

function offNetworkStatusChange (callbackFn) {
  if (navigator.connection) {
    navigator.connection.removeEventListener('change', fnMap.get(callbackFn))
  } else {
    oldObserveList.has(callbackFn) && oldObserveList.delete(callbackFn)
  }
}


/***/ }),
/* 152 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "request": function() { return /* binding */ request; }
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(153);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136);
/* harmony import */ var _RequestTask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(182);




function request (options = { url: '' }) {
  const CancelToken = (axios__WEBPACK_IMPORTED_MODULE_0___default().CancelToken)
  const source = CancelToken.source()
  const requestTask = new _RequestTask__WEBPACK_IMPORTED_MODULE_1__["default"](source.cancel)

  let {
    data = {},
    method = 'GET',
    dataType = 'json',
    responseType = 'text',
    timeout = 60 * 1000,
    header = {},
    success = null,
    fail = null,
    complete = null
  } = options

  method = method.toUpperCase()

  if (
    method === 'POST' &&
    typeof data !== 'string' && // string 不做处理
    (header['Content-Type'] === 'application/x-www-form-urlencoded' ||
      header['content-type'] === 'application/x-www-form-urlencoded')
  ) {
    data = Object.keys(data).reduce((pre, curKey) => {
      return `${pre}&${encodeURIComponent(curKey)}=${encodeURIComponent(data[curKey])}`
    }, '').slice(1)
  }

  const rOptions = {
    method,
    url: options.url,
    data,
    headers: header,
    responseType,
    timeout,
    cancelToken: source.token
  }

  if (method === 'GET') {
    rOptions.params = rOptions.data || {}
    delete rOptions.data
  }

  const promise = axios__WEBPACK_IMPORTED_MODULE_0___default()(rOptions).then(res => {
    let data = res.data
    if (responseType === 'text' && dataType === 'json') {
      try {
        data = JSON.parse(data)
      } catch (e) {
      }
    }
    const result = {
      errMsg: 'request:ok',
      data,
      statusCode: res.status,
      header: res.headers
    }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(result, success, complete)
    return result
  }).catch(err => {
    const res = { errMsg: `request:fail ${err}` }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleFail)(res, fail, complete)
    if (!fail) {
      return Promise.reject(res)
    }
  })

  promise.__returned = requestTask
  return promise
}




/***/ }),
/* 153 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(154);

/***/ }),
/* 154 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);
var bind = __webpack_require__(156);
var Axios = __webpack_require__(157);
var mergeConfig = __webpack_require__(175);
var defaults = __webpack_require__(162);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(178);
axios.CancelToken = __webpack_require__(179);
axios.isCancel = __webpack_require__(174);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(180);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(181);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),
/* 155 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(156);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),
/* 156 */
/***/ (function(module) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 157 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);
var buildURL = __webpack_require__(158);
var InterceptorManager = __webpack_require__(159);
var dispatchRequest = __webpack_require__(160);
var mergeConfig = __webpack_require__(175);
var validator = __webpack_require__(176);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 158 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 159 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 160 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);
var transformData = __webpack_require__(161);
var isCancel = __webpack_require__(174);
var defaults = __webpack_require__(162);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 161 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);
var defaults = __webpack_require__(162);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),
/* 162 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);
var normalizeHeaderName = __webpack_require__(163);
var enhanceError = __webpack_require__(164);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(165);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(165);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),
/* 163 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 164 */
/***/ (function(module) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),
/* 165 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);
var settle = __webpack_require__(166);
var cookies = __webpack_require__(168);
var buildURL = __webpack_require__(158);
var buildFullPath = __webpack_require__(169);
var parseHeaders = __webpack_require__(172);
var isURLSameOrigin = __webpack_require__(173);
var createError = __webpack_require__(167);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),
/* 166 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(167);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 167 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(164);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 168 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),
/* 169 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(170);
var combineURLs = __webpack_require__(171);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),
/* 170 */
/***/ (function(module) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 171 */
/***/ (function(module) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 172 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 173 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),
/* 174 */
/***/ (function(module) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 175 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(155);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),
/* 176 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var pkg = __webpack_require__(177);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),
/* 177 */
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ }),
/* 178 */
/***/ (function(module) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 179 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(178);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 180 */
/***/ (function(module) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 181 */
/***/ (function(module) {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),
/* 182 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class RequestTask {
  constructor (abortCb) {
    this._abortCb = abortCb
  }

  abort () {
    if (typeof this._abortCb === 'function') {
      this._abortCb()
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (RequestTask);


/***/ }),
/* 183 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "navigateBack": function() { return /* binding */ navigateBack; },
/* harmony export */   "navigateTo": function() { return /* binding */ navigateTo; },
/* harmony export */   "reLaunch": function() { return /* binding */ reLaunch; },
/* harmony export */   "redirectTo": function() { return /* binding */ redirectTo; },
/* harmony export */   "switchTab": function() { return /* binding */ switchTab; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/* harmony import */ var _event_channel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(127);



function redirectTo (options = {}) {
  const router = __webpack_require__.g.__mpxRouter
  if (router) {
    if ((0,_common_js__WEBPACK_IMPORTED_MODULE_0__.isTabBarPage)(options.url, router)) {
      const res = { errMsg: 'redirectTo:fail can not redirectTo a tabBar page' }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
      return Promise.reject(res)
    }
    router.__mpxAction = { type: 'redirect' }
    return new Promise((resolve, reject) => {
      router.replace(
        {
          path: options.url
        },
        () => {
          const res = { errMsg: 'redirectTo:ok' }
          ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
          resolve(res)
        },
        err => {
          const res = { errMsg: `redirectTo:fail ${err}` }
          ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
          reject(res)
        }
      )
    })
  }
}

function navigateTo (options = {}) {
  const router = __webpack_require__.g.__mpxRouter
  if (router) {
    if ((0,_common_js__WEBPACK_IMPORTED_MODULE_0__.isTabBarPage)(options.url, router)) {
      const res = { errMsg: 'navigateTo:fail can not navigateTo a tabBar page' }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
      return Promise.reject(res)
    }
    const eventChannel = new _event_channel__WEBPACK_IMPORTED_MODULE_1__.EventChannel()
    router.__mpxAction = {
      type: 'to',
      eventChannel
    }
    if (options.events) {
      eventChannel._addListeners(options.events)
    }
    return new Promise((resolve, reject) => {
      router.push(
        {
          path: options.url
        },
        () => {
          const res = { errMsg: 'navigateTo:ok', eventChannel }
          ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
          resolve(res)
        },
        err => {
          const res = { errMsg: err }
          ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
          reject(res)
        }
      )
    })
  }
}

function navigateBack (options = {}) {
  const router = __webpack_require__.g.__mpxRouter
  if (router) {
    const delta = options.delta || 1
    router.__mpxAction = {
      type: 'back',
      delta
    }
    router.go(-delta)
    const res = { errMsg: 'navigateBack:ok' }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
    return Promise.resolve(res)
  }
}

let reLaunchCount = 0

function reLaunch (options = {}) {
  const router = __webpack_require__.g.__mpxRouter
  if (router) {
    if (reLaunchCount === 0 && router.currentRoute.query.reLaunchCount) reLaunchCount = router.currentRoute.query.reLaunchCount
    const delta = router.stack.length - 1
    router.__mpxAction = {
      type: 'reLaunch',
      path: options.url,
      reLaunchCount: ++reLaunchCount,
      replaced: false
    }
    // 在需要操作后退时，先操作后退，在beforeEach中基于当前action通过next()进行replace操作，避免部分浏览器的表现不一致
    if (delta > 0) {
      router.go(-delta)
    } else {
      router.__mpxAction.replaced = true
      return new Promise((resolve, reject) => {
        router.replace(
          {
            path: options.url,
            query: {
              reLaunchCount
            }
          },
          () => {
            const res = { errMsg: 'reLaunch:ok' }
            ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
            resolve(res)
          },
          err => {
            const res = { errMsg: err }
            ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
            !options.fail && reject(res)
          }
        )
      })
    }
    const res = { errMsg: 'reLaunch:ok' }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
    return Promise.resolve(res)
  }
}

function switchTab (options = {}) {
  const router = __webpack_require__.g.__mpxRouter
  if (router) {
    const toRoute = router.match(options.url, router.history.current)
    const currentRoute = router.currentRoute
    if (toRoute.path !== currentRoute.path) {
      if (!(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.isTabBarPage)(options.url, router)) {
        const res = { errMsg: 'switchTab:fail can not switch to no-tabBar page!' }
        ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
        return Promise.reject(res)
      }
      const delta = router.stack.length - 1
      router.__mpxAction = {
        type: 'switch',
        path: options.url,
        replaced: false
      }
      if (delta > 0) {
        router.go(-delta)
      } else {
        router.__mpxAction.replaced = true
        return new Promise((resolve, reject) => {
          router.replace(
            {
              path: options.url
            },
            () => {
              const res = { errMsg: 'switchTab:ok' }
              ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
              resolve(res)
            },
            err => {
              const res = { errMsg: err }
              ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
              !options.fail && reject(res)
            }
          )
        })
      }
    }
    const res = { errMsg: 'switchTab:ok' }
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
    return Promise.resolve(res)
  }
}




/***/ }),
/* 184 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "closeSocket": function() { return /* binding */ closeSocket; },
/* harmony export */   "connectSocket": function() { return /* binding */ connectSocket; },
/* harmony export */   "onSocketClose": function() { return /* binding */ onSocketClose; },
/* harmony export */   "onSocketError": function() { return /* binding */ onSocketError; },
/* harmony export */   "onSocketMessage": function() { return /* binding */ onSocketMessage; },
/* harmony export */   "onSocketOpen": function() { return /* binding */ onSocketOpen; },
/* harmony export */   "sendSocketMessage": function() { return /* binding */ sendSocketMessage; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(136);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(126);
/* harmony import */ var _SocketTask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(185);



function connectSocket (options = { url: '' }) {
  const { url, protocols, success, fail, complete } = options

  try {
    const socketTask = new _SocketTask__WEBPACK_IMPORTED_MODULE_0__["default"](url, protocols)
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_1__.webHandleSuccess)({ errMsg: 'connectSocket:ok' }, success, complete)
    return socketTask
  } catch (e) {
    (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.webHandleFail)({ errMsg: `connectSocket:fail ${e}` }, fail, complete)
  }
}

function sendSocketMessage () {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.warn)('sendSocketMessage 请使用 socketTask.send')
}

function closeSocket () {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.warn)('closeSocket 请使用 socketTask.close')
}

function onSocketOpen () {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.warn)('onSocketOpen 请使用 socketTask.onOpen')
}

function onSocketError () {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.warn)('onSocketError 请使用 socketTask.onError')
}

function onSocketMessage () {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.warn)('onSocketMessage 请使用 socketTask.onMessage')
}

function onSocketClose () {
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.warn)('onSocketClose 请使用 socketTask.onClose')
}




/***/ }),
/* 185 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);


const socketTasks = new Set()

class SocketTask {
  constructor (url, protocols) {
    this._openCb = null
    this._closeCb = null
    this._messageCb = null
    this._errorCb = null
    this._closeData = null

    if (protocols && protocols.length > 0) {
      this._socket = new window.WebSocket(url, protocols)
    } else {
      this._socket = new window.WebSocket(url)
    }
    this.addListener(this._socket)
    socketTasks.add(this._socket)
  }

  get CONNECTING () {
    return this._socket.CONNECTING || 0
  }

  get OPEN () {
    return this._socket.OPEN || 1
  }

  get CLOSING () {
    return this._socket.CLOSING || 2
  }

  get CLOSED () {
    return this._socket.CLOSED || 3
  }

  get readyState () {
    return this._socket.readyState
  }

  send (options) {
    const { data = '', success, fail, complete } = options

    if (this._socket.readyState === 1) {
      this._socket.send(data)
      const res = { errMsg: 'sendSocketMessage:ok' }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, success, complete)
      return Promise.resolve(res)
    } else {
      const res = { errMsg: 'sendSocketMessage:fail' }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, fail, complete)
      if (!fail) {
        return Promise.reject(res)
      }
    }
  }

  close (options) {
    const { code = 1000, reason = '', success, fail, complete } = options
    this._closeData = {
      code,
      reason
    }
    try {
      this._socket.close()
      const res = { errMsg: 'closeSocket:ok' }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, success, complete)
      return Promise.resolve(res)
    } catch (err) {
      const res = { errMsg: `closeSocket:fail ${err}` }
      ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, fail, complete)
      if (!fail) {
        return Promise.reject(res)
      }
    }
  }

  addListener (socket) {
    socket.onOpen = event => { typeof this._openCb === 'function' && this._openCb(event) }
    socket.onmessage = event => { typeof this._messageCb === 'function' && this._messageCb(event) }
    socket.onerror = event => {
      socketTasks.delete(this._socket)
      typeof this._errorCb === 'function' && this._errorCb(event)
    }
    socket.onclose = event => {
      socketTasks.delete(this._socket)
      if (typeof this._closeCb !== 'function') {
        return
      }
      if (this._closeData) {
        this._closeCb(event)
      } else {
        this._closeCb({ code: 2000, reason: `${event}` })
      }
    }
  }

  onOpen (cb) {
    this._openCb = cb
  }

  onMessage (cb) {
    this._messageCb = cb
  }

  onError (cb) {
    this._errorCb = cb
  }

  onClose (cb) {
    this._closeCb = cb
  }
}

/* harmony default export */ __webpack_exports__["default"] = (SocketTask);


/***/ }),
/* 186 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "setNavigationBarColor": function() { return /* binding */ setNavigationBarColor; },
/* harmony export */   "setNavigationBarTitle": function() { return /* binding */ setNavigationBarTitle; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);


function setNavigationBarTitle (options = {}) {
  const { title, success, complete } = options

  if (document.title !== title) {
    document.title = title
  }

  (0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)({ errMsg: 'setNavigationBarTitle:ok' }, success, complete)
}

function setNavigationBarColor (options = {}) {
  const { backgroundColor, success, complete } = options
  const meta = document.createElement('meta')
  meta.setAttribute('name', 'theme-color')
  meta.setAttribute('content', backgroundColor)
  document.head.appendChild(meta)
  ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)({ errMsg: 'setNavigationBarColor:ok' }, success, complete)
}




/***/ }),
/* 187 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "offWindowResize": function() { return /* binding */ offWindowResize; },
/* harmony export */   "onWindowResize": function() { return /* binding */ onWindowResize; }
/* harmony export */ });
/* harmony import */ var _common_js_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);


const callbacks = []

if (_common_js_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
  window.addEventListener('resize', () => {
    const result = {
      size: {
        windowWidth: window.screen.width,
        windowHeight: window.screen.height
      }
    }
    callbacks.forEach(cb => cb(result))
  })
}

function onWindowResize (callback) {
  callbacks.push(callback)
}

function offWindowResize (callback) {
  const index = callbacks.indexOf(callback)
  if (index > -1) {
    callbacks.splice(index, 1)
  }
}




/***/ }),
/* 188 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startPullDownRefresh": function() { return /* binding */ startPullDownRefresh; },
/* harmony export */   "stopPullDownRefresh": function() { return /* binding */ stopPullDownRefresh; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);


function stopPullDownRefresh (options = {}) {
  const router = __webpack_require__.g.__mpxRouter
  if (router) {
    let err

    const vnode = router.__mpxActiveVnode
    if (vnode && vnode.componentInstance) {
      const currentPage = vnode.tag.endsWith('mpx-tab-bar-container') ? vnode.componentInstance.$refs.tabBarPage : vnode.componentInstance
      if (currentPage && currentPage.__stopPullDownRefresh) {
        try {
          currentPage.__stopPullDownRefresh()
        } catch (e) {
          err = e
        }
      }
    }
    return new Promise((resolve, reject) => {
      if (err) {
        const res = { errMsg: `stopPullDownRefresh:fail ${err}` }
        ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
        reject(res)
      } else {
        const res = { errMsg: 'stopPullDownRefresh:ok' }
        ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
        resolve(res)
      }
    })
  }
}

function startPullDownRefresh (options = {}) {
  const router = __webpack_require__.g.__mpxRouter
  if (router) {
    let err

    const vnode = router.__mpxActiveVnode
    if (vnode && vnode.componentInstance) {
      const currentPage = vnode.tag.endsWith('mpx-tab-bar-container') ? vnode.componentInstance.$refs.tabBarPage : vnode.componentInstance
      if (currentPage && currentPage.__startPullDownRefresh) {
        try {
          currentPage.__startPullDownRefresh()
        } catch (e) {
          err = e
        }
      }
    }
    return new Promise((resolve, reject) => {
      if (err) {
        const res = { errMsg: `startPullDownRefresh:fail ${err}` }
        ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleFail)(res, options.fail, options.complete)
        reject(res)
      } else {
        const res = { errMsg: 'startPullDownRefresh:ok' }
        ;(0,_common_js__WEBPACK_IMPORTED_MODULE_0__.webHandleSuccess)(res, options.success, options.complete)
        resolve(res)
      }
    })
  }
}




/***/ }),
/* 189 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createInnerAudioContext": function() { return /* binding */ createInnerAudioContext; }
/* harmony export */ });
const createInnerAudioContext = () => {
  // eslint-disable-next-line no-undef
  const audio = new Audio()
  const __audio = {}

  __audio.play = () => !/mpxFalse/.test(audio.src) ? audio.play() : ''

  __audio.pause = () => audio.pause()

  __audio.stop = () => {
    __audio.pause()
    __audio.seek(0)
  }

  __audio.seek = value => {
    audio.currentTime = value
  }

  __audio.destroy = () => {
    audio.src = 'mpxFalse'
  }

  const parameter = ['src', 'autoplay', 'loop', 'volume', 'duration', 'currentTime', 'buffered', 'paused']
  parameter.forEach(item => {
    Object.defineProperty(__audio, item, {
      get: () => audio[item],
      set (value) {
        audio[item] = value
      }
    })
  })
  Object.defineProperty(__audio, 'startTime', {
    value: 0
  })
  Object.defineProperty(__audio, 'obeyMuteSwitch', {
    value: true
  })
  const eventNames = [
    'Canplay',
    'Ended',
    'Pause',
    'Play',
    'Seeked',
    'Seeking',
    'TimeUpdate',
    'Waiting',
    'Stop',
    'Error'
  ]
  const eventListeners = [
    ['on', audio.addEventListener],
    ['off', audio.removeEventListener]
  ]
  eventNames.forEach(eventName => {
    eventListeners.forEach(([eventNameItem, listenerFn]) => {
      Object.defineProperty(__audio, `${eventNameItem}${eventName}`, {
        get () {
          return (callback = audio.cb) => {
            if (eventNameItem !== 'off') {
              audio.cb = callback
            }
            // debugger
            return listenerFn.call(audio, eventName.toLowerCase(), audio.cb)
          }
        }
      })
    })
  })
  return __audio
}


/***/ }),
/* 190 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createVideoContext": function() { return /* binding */ createVideoContext; }
/* harmony export */ });
const allowPlaybackRate = [0.5, 0.8, 1.0, 1.25, 1.5, 2.0]
const createVideoContext = (id, context) => {
  if (!id) {
    throw new Error('id为必传参数')
  }
  let __videoNode
  if (context && context.$el) {
    __videoNode = context.$el.querySelector(`#${id}`)
  } else {
    __videoNode = document.querySelector(`#${id}`)
  }
  if (!__videoNode) {
    throw new Error(`未找到id为${id}的节点`)
  }
  const __videoContext = {}

  // todo 进入后台音频播放模式
  __videoContext.requestBackgroundPlayback = () => {
    console.warn('暂不支持requestBackgroundPlayback API')
  }

  // todo 退出后台音频播放
  __videoContext.exitBackgroundPlayback = () => {
    console.warn('暂不支持exitBackgroundPlayback API')
  }

  // todo 退出小窗，该方法可在任意页面调用
  __videoContext.exitPictureInPicture = ({ success, fail, complete }) => {
    console.warn('暂不支持exitPictureInPicture API')
  }

  // todo 发送弹幕
  __videoContext.sendDanmu = ({ text, color }) => {
    console.warn('暂不支持发送弹幕')
  }

  // 进入全屏
  __videoContext.requestFullScreen = ({ direction }) => {
    __videoNode.webkitRequestFullScreen && __videoNode.webkitRequestFullScreen() // Chrome
    __videoNode.mozRequestFullScreen && __videoNode.mozRequestFullScreen() // Firefox
    __videoNode.msRequestFullscreen && __videoNode.msRequestFullscreen() // IE
    __videoNode.oRequestFullScreen && __videoNode.oRequestFullScreen() // 欧朋
    __videoNode.webkitEnterFullscreen && __videoNode.webkitEnterFullscreen() // 苹果
    if (direction === 0) {
      __videoNode.setAttribute('x5-video-orientation', 'portraint') // portraint 竖屏 landscape 横屏
    } else if (direction === 90 || direction === -90) {
      __videoNode.setAttribute('x5-video-orientation', 'landscape') // portraint 竖屏 landscape 横屏
    }
  }

  // 退出全屏
  __videoContext.exitFullScreen = () => {
    document.webkitCancelFullScreen && document.webkitCancelFullScreen() // Chrome
    document.mozCancelFullScreen && document.mozCancelFullScreen() // Firefox
    document.exitFullscreen && document.exitFullscreen() // W3C
  }

  // 显示状态栏
  __videoContext.showStatusBar = () => {
    __videoNode.setAttribute('controls', 'controls')
  }

  // 隐藏状态栏
  __videoContext.hideStatusBar = () => {
    __videoNode.removeAttribute('controls')
  }

  // 暂停
  __videoContext.pause = () => {
    __videoNode.pause()
  }

  // 播放
  __videoContext.play = () => {
    __videoNode.play()
  }

  // 停止视频
  __videoContext.stop = () => {
    __videoNode.currentTime = 0
    __videoNode.pause()
  }

  // 设置倍速播放
  __videoContext.playbackRate = (number) => {
    if (allowPlaybackRate.indexOf(number) === -1) {
      console.warn(`不支持${number}倍速播放`)
      return
    }
    __videoNode.playbackRate = number
  }

  // 跳转到指定位置
  __videoContext.seek = (number) => {
    __videoNode.currentTime = number
  }

  return __videoContext
}


/***/ }),
/* 191 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pageScrollTo": function() { return /* binding */ pageScrollTo; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(136);
/* harmony import */ var _next_tick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(123);



function pageScrollTo (options) {
  (0,_next_tick__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
    const ms = __webpack_require__.g.__ms
    const { success, fail, complete } = options

    if (!ms) {
      return (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.webHandleFail)({
        errMsg: 'pageScrollTo:fail'
      }, fail, complete)
    }

    ms.pageScrollTo(options)
    ;(0,_common_js__WEBPACK_IMPORTED_MODULE_1__.webHandleSuccess)({
      errMsg: 'pageScrollTo:ok'
    }, success, complete)
  })
}


/***/ }),
/* 192 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hideTabBar": function() { return /* binding */ hideTabBar; },
/* harmony export */   "setTabBarItem": function() { return /* binding */ setTabBarItem; },
/* harmony export */   "setTabBarStyle": function() { return /* binding */ setTabBarStyle; },
/* harmony export */   "showTabBar": function() { return /* binding */ showTabBar; }
/* harmony export */ });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(126);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(136);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);



function setTabBarStyle (options = {}) {
  const tabBar = __webpack_require__.g.__tabBar
  let resolved, rejected
  if (tabBar) {
    if (tabBar.custom) {
      rejected = { errMsg: 'setTabBarStyle:fail custom Tabbar' }
    } else {
      'color|selectedColor|backgroundColor|borderStyle'.split('|').forEach((key) => {
        if ((0,_common_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(options, key)) {
          vue__WEBPACK_IMPORTED_MODULE_1__["default"].set(tabBar, key, options[key])
        }
      })
      resolved = { errMsg: 'setTabBarStyle:ok' }
    }
  } else {
    rejected = { errMsg: 'setTabBarStyle:fail no tabBar found' }
  }

  if (resolved) {
    (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(resolved, options.success, options.complete)
    return Promise.resolve(resolved)
  }
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleFail)(rejected, options.fail, options.complete)
  return Promise.reject(rejected)
}

function setTabBarItem (options = {}) {
  const tabBar = __webpack_require__.g.__tabBar
  let resolved, rejected
  if (tabBar) {
    if (tabBar.custom) {
      rejected = { errMsg: 'setTabBarItem:fail custom Tabbar' }
    } else {
      const item = tabBar.list[options.index]
      if (item) {
        'text|iconPath|selectedIconPath'.split('|').forEach((key) => {
          if ((0,_common_js__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(options, key)) {
            vue__WEBPACK_IMPORTED_MODULE_1__["default"].set(item, key, options[key])
          }
        })
        resolved = { errMsg: 'setTabBarItem:ok' }
      } else {
        rejected = { errMsg: 'setTabBarItem:fail no Tabbar item found' }
      }
    }
  } else {
    rejected = { errMsg: 'setTabBarItem:fail no tabBar found' }
  }

  if (resolved) {
    (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(resolved, options.success, options.complete)
    return Promise.resolve(resolved)
  }
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleFail)(rejected, options.fail, options.complete)
  return Promise.reject(rejected)
}

function showTabBar (options = {}) {
  const tabBar = __webpack_require__.g.__tabBar
  let resolved, rejected
  if (tabBar) {
    vue__WEBPACK_IMPORTED_MODULE_1__["default"].set(tabBar, 'isShow', true)
    resolved = { errMsg: 'showTabBar:ok' }
  } else {
    rejected = { errMsg: 'showTabBar:fail no tabBar found' }
  }

  if (resolved) {
    (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(resolved, options.success, options.complete)
    return Promise.resolve(resolved)
  }
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleFail)(rejected, options.fail, options.complete)
  return Promise.reject(rejected)
}

function hideTabBar (options = {}) {
  const tabBar = __webpack_require__.g.__tabBar
  let resolved, rejected
  if (tabBar) {
    vue__WEBPACK_IMPORTED_MODULE_1__["default"].set(tabBar, 'isShow', false)
    resolved = { errMsg: 'hideTabBar:ok' }
  } else {
    rejected = { errMsg: 'hideTabBar:fail no tabBar found' }
  }

  if (resolved) {
    (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleSuccess)(resolved, options.success, options.complete)
    return Promise.resolve(resolved)
  }
  (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.webHandleFail)(rejected, options.fail, options.complete)
  return Promise.reject(rejected)
}




/***/ }),
/* 193 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "offAppHide": function() { return /* binding */ offAppHide; },
/* harmony export */   "offAppShow": function() { return /* binding */ offAppShow; },
/* harmony export */   "offError": function() { return /* binding */ offError; },
/* harmony export */   "onAppHide": function() { return /* binding */ onAppHide; },
/* harmony export */   "onAppShow": function() { return /* binding */ onAppShow; },
/* harmony export */   "onError": function() { return /* binding */ onError; }
/* harmony export */ });
__webpack_require__.g.__mpxAppCbs = __webpack_require__.g.__mpxAppCbs || {
  show: [],
  hide: [],
  error: []

}

function onError (callback) {
  __webpack_require__.g.__mpxAppCbs.error.push(callback)
}

function offError (callback) {
  const cbs = __webpack_require__.g.__mpxAppCbs.error
  const index = cbs.indexOf(callback)
  if (index > -1) cbs.splice(index, 1)
}

function onAppShow (callback) {
  __webpack_require__.g.__mpxAppCbs.show.push(callback)
}

function offAppShow (callback) {
  const cbs = __webpack_require__.g.__mpxAppCbs.show
  const index = cbs.indexOf(callback)
  if (index > -1) cbs.splice(index, 1)
}

function onAppHide (callback) {
  __webpack_require__.g.__mpxAppCbs.hide.push(callback)
}

function offAppHide (callback) {
  const cbs = __webpack_require__.g.__mpxAppCbs.hide
  const index = cbs.indexOf(callback)
  if (index > -1) cbs.splice(index, 1)
}




/***/ }),
/* 194 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createAnimation": function() { return /* binding */ createAnimation; }
/* harmony export */ });
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(195);


const createAnimation = function (options = {}) {
  options = Object.assign({
    duration: 400,
    timingFunction: 'linear',
    delay: 0,
    transformOrigin: '50% 50% 0'
  }, options)
  return new _animation__WEBPACK_IMPORTED_MODULE_0__["default"](options)
}




/***/ }),
/* 195 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
class Animation {
  constructor (options) {
    this._actions = []
    this._propMaps = {}
    this._options = options
  }

  _processSize (size) {
    if (typeof size === 'number') {
      return `${size}px`
    } else {
      if (size.indexOf('rpx') !== -1) {
        // 计算rpx折算回px
        const rs = parseInt(size, 10)
        const width = window.screen.width
        const finalRs = Math.floor(rs / 750 * width)
        return `${finalRs}px`
      } else {
        return size
      }
    }
  }

  _collectData (type, value) {
    switch (type) {
      case 'left':
      case 'right':
      case 'top':
      case 'bottom':
      case 'width':
      case 'height':
        value = this._processSize(value)
        this._propMaps[type] = {
          args: [type, value],
          type: 'style'
        }
        break
      case 'background-color':
      case 'opacity':
        this._propMaps[type] = {
          args: [type, value],
          type: 'style'
        }
        break
      default:
        this._propMaps[type] = {
          args: Array.isArray(value) ? value : [value],
          type
        }
        break
    }
  }

  right (value) {
    this._collectData('right', value)
    return this
  }

  left (value) {
    this._collectData('left', value)
    return this
  }

  top (value) {
    this._collectData('top', value)
    return this
  }

  bottom (value) {
    this._collectData('bottom', value)
    return this
  }

  width (value) {
    this._collectData('width', value)
    return this
  }

  height (value) {
    this._collectData('height', value)
    return this
  }

  opacity (value) {
    this._collectData('opacity', parseFloat(value))
    return this
  }

  backgroundColor (color) {
    this._collectData('background-color', color)
    return this
  }

  matrix (...value) {
    this._collectData('matrix', value)
    return this
  }

  matrix3d (...value) {
    const defaultVal = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    defaultVal.splice(0, value.length, ...value)
    this._collectData('matrix3d', defaultVal)
    return this
  }

  rotate (...value) {
    this._collectData('rotate', `${parseFloat(value)}deg`)
    return this
  }

  rotate3d (...value) {
    const defaultVal = [0, 0, 0, 0]
    defaultVal.splice(0, value.length, ...value)
    defaultVal[3] = `${parseFloat(defaultVal[3])}deg` // 手动调整第四位为字符串类型并拼接单位
    this._collectData('rotate3d', defaultVal)
    return this
  }

  rotateX (value) {
    this._collectData('rotateX', `${parseFloat(value)}deg`)
    return this
  }

  rotateY (value) {
    this._collectData('rotateY', `${parseFloat(value)}deg`)
    return this
  }

  rotateZ (value) {
    this._collectData('rotateZ', `${parseFloat(value)}deg`)
    return this
  }

  scale (...value) {
    const [x, y = x] = value
    this._collectData('scale', [x, y])
    return this
  }

  scale3d (...value) {
    const defaultVal = [1, 1, 1]
    defaultVal.splice(0, value.length, ...value)
    this._collectData('scale3d', defaultVal)
    return this
  }

  scaleX (value) {
    this._collectData('scaleX', value)
    return this
  }

  scaleY (value) {
    this._collectData('scaleY', value)
    return this
  }

  scaleZ (value) {
    this._collectData('scaleZ', value)
    return this
  }

  skew (...value) {
    const [x = 0, y = 0] = value
    this._collectData('skew', [`${parseFloat(x)}deg`, `${parseFloat(y)}deg`])
    return this
  }

  skewX (value) {
    this._collectData('skewX', `${parseFloat(value)}deg`)
    return this
  }

  skewY (value) {
    this._collectData('skewY', `${parseFloat(value)}deg`)
    return this
  }

  translate (...value) {
    const [x = 0, y = 0] = value
    this._collectData('translate', [`${parseFloat(x)}px`, `${parseFloat(y)}px`])
    return this
  }

  translate3d (...value) {
    const [x = 0, y = 0, z = 0] = value
    this._collectData('translate3d', [`${parseFloat(x)}px`, `${parseFloat(y)}px`, `${parseFloat(z)}px`])
    return this
  }

  translateX (value) {
    this._collectData('translateX', `${parseFloat(value)}px`)
    return this
  }

  translateY (value) {
    this._collectData('translateY', `${parseFloat(value)}px`)
    return this
  }

  translateZ (value) {
    this._collectData('translateZ', `${parseFloat(value)}px`)
    return this
  }

  step (opt) {
    const option = {}
    const animates = []
    if (opt) {
      Object.assign(option, this._options, opt)
    } else {
      Object.assign(option, this._options)
    }
    Object.keys(this._propMaps).forEach((item) => {
      animates.push(this._propMaps[item])
    })
    this._actions.push({
      animates,
      option
    })
    return this
  }

  export () {
    const actions = this._actions.slice(0)
    this._actions.length = 0
    return {
      actions
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Animation);


/***/ }),
/* 196 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "img/icon1b3c186eccda0451e96bf154d3eec83b1.png";

/***/ }),
/* 197 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_tab_bar_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(198);
/* harmony import */ var _mpx_tab_bar_vue_vue_type_style_index_0_id_53bd82c0_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(202);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
var render, staticRenderFns
;

;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _mpx_tab_bar_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-tab-bar.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 198 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(199);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 199 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);

  

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-tab-bar',
    props: {
      currentIndex: {
        type: Number,
        default: 0
      }
    },
    computed: {
      wrapperStyle () {
        let style = `background-color: ${__webpack_require__.g.__tabBar.backgroundColor}; border-top: 1px solid ${__webpack_require__.g.__tabBar.borderStyle};`
        style += __webpack_require__.g.__tabBar.position === 'bottom' ? 'bottom: 0;' : 'top: 0;'
        return style
      }
    },
    methods: {
      itemClickHandler (item, index) {
        this.$emit('change', item, index)
      }
    },
    render (createElement) {
      const iconImage = (item, index) => createElement('img',
        {
          class: 'icon',
          style: {
            height: '26px',
            width: '26px'
          },
          domProps: {
            src: this.currentIndex === index && item.selectedIconPath ? item.selectedIconPath : item.iconPath
          },
          on: (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__["default"])(this, { ignoredListeners: ['load', 'error'] })
        })
      const textSpan = (item, index) => createElement('span',
        {
          class: 'tab-cell',
          style: { color: this.currentIndex === index ? __webpack_require__.g.__tabBar.selectedColor : __webpack_require__.g.__tabBar.color },
          domProps: { innerHTML: item.text }
        }
      )

      const tabBarWrapper = createElement('div', { class: 'tab-bar-wrapper' },
        [__webpack_require__.g.__tabBar.list.map((item, index) => {
          return createElement('div', {
              class: 'tab-item',
              on: { click: this.itemClickHandler.bind(this, item, index) }
            },
            item.iconPath ? [iconImage(item, index), textSpan(item, index)] : [textSpan(item, index)]
          )
        })])
      return createElement('div',
        {
          class: 'mpx-tab-bar',
          style: this.wrapperStyle,
        },
        [tabBarWrapper]
      )
    }
  });


/***/ }),
/* 200 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ getInnerListeners; },
/* harmony export */   "extendEvent": function() { return /* binding */ extendEvent; },
/* harmony export */   "getCustomEvent": function() { return /* binding */ getCustomEvent; },
/* harmony export */   "inheritEvent": function() { return /* binding */ inheritEvent; }
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(201);

const isTouchDevice = document && ('ontouchstart' in document.documentElement)

function processModel (listeners, context) {
  // 该函数只有wx:model的情况下才调用，而且默认e.detail.value有值
  // 该函数必须在产生merge前执行
  // todo 此处对于$attrs的访问会导致父组件更新时子组件必然更新，暂时用短路效应避免影响，待优化
  // todo 访问$listeners也会导致上述现象，但是为了事件代理还必须访问$listeners，待后续思考处理

  const modelEvent = context.$attrs.mpxModelEvent
  if (modelEvent) {
    // 对于modelEvent，内部获得时间后向外部转发，触发外部listener的同时转发为mpxModel事件
    listeners[modelEvent] = function (e) {
      context.$emit(modelEvent, e)
      context.$emit('mpxModel', e)
    }
    // 内部listener不需要mpxModel
    delete listeners.mpxModel
  }
}

function mergeListeners (listeners, otherListeners, options = {}) {
  if (!otherListeners) {
    return
  }
  Object.keys(otherListeners).forEach((key) => {
    const rawListener = listeners[key]
    const listener = otherListeners[key]
    if (!rawListener) {
      if (options.force) {
        listeners[key] = listener
      }
    } else {
      listeners[key] = function (e) {
        if (options.before) {
          listener.call(this, e)
          rawListener.call(this, e)
        } else {
          rawListener.call(this, e)
          listener.call(this, e)
        }
      }
    }
  })
}

function processTap (listeners, context) {
  const listenerMap = {}
  const tapEvents = ['tap', 'longpress', 'longtap']
  tapEvents.forEach((eventName) => {
    if (listeners[eventName]) {
      listenerMap[eventName] = true
      delete listeners[eventName]
    }
  })
  if ((0,_util__WEBPACK_IMPORTED_MODULE_0__.isEmptyObject)(listenerMap)) return
  context.__mpxTapInfo = context.__mpxTapInfo || {}
  let events
  if (isTouchDevice) {
    events = {
      touchstart (e) {
        context.__mpxTapInfo.detail = {
          x: e.changedTouches[0].pageX,
          y: e.changedTouches[0].pageY
        }
        context.__mpxTapInfo.startTimer = null
        context.__mpxTapInfo.needTap = true
        if (listenerMap.longpress || listenerMap.longtap) {
          context.__mpxTapInfo.startTimer = setTimeout(() => {
            context.__mpxTapInfo.needTap = false
            if (listenerMap.longpress) {
              const re = inheritEvent('longpress', e, context.__mpxTapInfo.detail)
              context.$emit('longpress', re)
            }
            if (listenerMap.longtap) {
              const re = inheritEvent('longtap', e, context.__mpxTapInfo.detail)
              context.$emit('longtap', re)
            }
          }, 350)
        }
      },
      touchmove (e) {
        const tapDetailInfo = context.__mpxTapInfo.detail || {}
        const currentPageX = e.changedTouches[0].pageX
        const currentPageY = e.changedTouches[0].pageY
        if (Math.abs(currentPageX - tapDetailInfo.x) > 1 || Math.abs(currentPageY - tapDetailInfo.y) > 1) {
          context.__mpxTapInfo.needTap = false
          context.__mpxTapInfo.startTimer && clearTimeout(context.__mpxTapInfo.startTimer)
          context.__mpxTapInfo.startTimer = null
        }
      },
      touchend (e) {
        context.__mpxTapInfo.startTimer && clearTimeout(context.__mpxTapInfo.startTimer)
        if (listenerMap.tap && context.__mpxTapInfo.needTap) {
          const re = inheritEvent('tap', e, context.__mpxTapInfo.detail)
          context.$emit('tap', re)
        }
      }
    }
  } else {
    events = {
      click (e) {
        if (listenerMap.tap) {
          context.__mpxTapInfo.detail = {
            x: e.pageX,
            y: e.pageY
          }
          const re = inheritEvent('tap', e, context.__mpxTapInfo.detail)
          context.$emit('tap', re)
        }
      }
    }
  }

  mergeListeners(listeners, events, {
    force: true
  })
}

function extendEvent (e, extendObj = {}) {
  Object.keys(extendObj).forEach((key) => {
    Object.defineProperty(e, key, {
      value: extendObj[key],
      enumerable: true,
      configurable: true,
      writable: true
    })
  })
}

function inheritEvent (type, oe, detail = {}) {
  detail = Object.assign({}, oe.detail, detail)
  const ne = getCustomEvent(type, detail)
  extendEvent(ne, {
    timeStamp: oe.timeStamp,
    target: oe.target,
    currentTarget: oe.currentTarget,
    stopPropagation: oe.stopPropagation.bind(oe),
    preventDefault: oe.preventDefault.bind(oe)
  })
  return ne
}

function getCustomEvent (type, detail = {}, target = null) {
  return {
    type,
    detail,
    target,
    timeStamp: new Date().valueOf()
  }
}

function noop () {

}

function getInnerListeners (context, options = {}) {
  let { mergeBefore = {}, mergeAfter = {}, defaultListeners = [], ignoredListeners = [] } = options
  const listeners = Object.assign({}, context.$listeners)
  defaultListeners.forEach((key) => {
    if (!listeners[key]) listeners[key] = noop
  })
  const mergeBeforeOptions = {
    before: true
  }
  const mergeAfterOptions = {
    before: false
  }

  if (mergeBefore.listeners) {
    mergeBeforeOptions.force = mergeBefore.force
    mergeBefore = mergeBefore.listeners
  }

  if (mergeAfter.listeners) {
    mergeAfterOptions.force = mergeAfter.force
    mergeAfter = mergeAfter.listeners
  }

  processModel(listeners, context)
  processTap(listeners, context)
  mergeListeners(listeners, mergeBefore, mergeBeforeOptions)
  mergeListeners(listeners, mergeAfter, mergeAfterOptions)
  ignoredListeners.forEach((key) => {
    delete listeners[key]
  })
  return listeners
}


/***/ }),
/* 201 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isBrowser": function() { return /* binding */ isBrowser; },
/* harmony export */   "isEmptyObject": function() { return /* binding */ isEmptyObject; },
/* harmony export */   "processSize": function() { return /* binding */ processSize; },
/* harmony export */   "type": function() { return /* binding */ type; }
/* harmony export */ });
/**
 @file web运行时组件抹平中需要用到的一些工具方法
 */

/**
 * 处理字符串类型的宽高数值，兼容rpx
 * @param {object | number} size 宽高
 * @param {object} option 配置项，目前仅支持配置默认值
 * @param {number} option.default 默认值,当传入的size有问题时返回
 * @returns {number} 处理后的数字宽高，单位px
 */
function processSize (size, option = {}) {
  const defaultValue = option.default || 0
  if (typeof size === 'number') {
    return size
  } else if (typeof size === 'string') {
    const rs = parseInt(size, 10)
    if (size.indexOf('rpx') !== -1) {
      // 计算rpx折算回px
      const width = window.screen.width
      const finalRs = Math.floor(rs / 750 * width)
      return finalRs
    } else {
      return isNaN(rs) ? defaultValue : rs
    }
  } else {
    return defaultValue
  }
}

// 判断对象类型
function type (n) {
  return Object.prototype.toString.call(n).slice(8, -1)
}

function isEmptyObject (obj) {
  if (!obj) {
    return true
  }
  for (let key in obj) {
    return false
  }
  return true
}

const isBrowser = typeof window !== 'undefined'


/***/ }),
/* 202 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_vue_vue_type_style_index_0_id_53bd82c0_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(203);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_vue_vue_type_style_index_0_id_53bd82c0_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_vue_vue_type_style_index_0_id_53bd82c0_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_vue_vue_type_style_index_0_id_53bd82c0_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_vue_vue_type_style_index_0_id_53bd82c0_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 203 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(204);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("1a9d9e69", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.mpx-tab-bar {\n  position: fixed;\n  left: 0;\n  right: 0;\n  width: 100%;\n  height: 48px;\n}\n.mpx-tab-bar .tab-bar-wrapper {\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n.mpx-tab-bar .tab-item {\n  flex: 1;\n  text-align: center;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  cursor: pointer;\n}\n", ""]);

// exports


/***/ }),
/* 205 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ normalizeComponent; }
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */,
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options =
    typeof scriptExports === 'function' ? scriptExports.options : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) {
    // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
          injectStyles.call(
            this,
            (options.functional ? this.parent : this).$root.$options.shadowRoot
          )
        }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 206 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_mpx_vue_type_template_id_5750d4a6_scoped_true_isPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(207);
/* harmony import */ var _index_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(209);
/* harmony import */ var _index_mpx_vue_type_style_index_0_id_5750d4a6_scoped_true_mpxStyleOptions_7B_22mid_22_3A_22mab35b83a_22_7D_lang_css_isPage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(282);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(205);



;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _index_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_1__["default"],
  _index_mpx_vue_type_template_id_5750d4a6_scoped_true_isPage__WEBPACK_IMPORTED_MODULE_0__.render,
  _index_mpx_vue_type_template_id_5750d4a6_scoped_true_isPage__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "5750d4a6",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/pages/index.mpx"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 207 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_template_id_5750d4a6_scoped_true_isPage__WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_template_id_5750d4a6_scoped_true_isPage__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_template_id_5750d4a6_scoped_true_isPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(208);


/***/ }),
/* 208 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "staticRenderFns": function() { return /* binding */ staticRenderFns; }
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c("div", {
    staticClass: "mpx-root-view"
  }, [_c("mpx-view", {
    on: {
      tap: _vm.reload
    }
  }, [_vm._v("__UNPLUGIN__1111")]), _vm.a === 1 ? _c("mpx-text", {
    on: {
      tap: _vm.jumpPage
    }
  }, [_vm._v("test24")]) : _vm._e(), _c("div", [_vm._v(_vm._s(_vm.$t("page_title")))]), _vm.a === 1 ? _c("mpx-button", {
    on: {
      tap: _vm.jumpPage
    }
  }, [_vm._v("跳转到swiper")]) : _vm._e(), _c("div", [_vm._v(_vm._s(_vm.$t("message.title")))]), _c("list", {
    attrs: {
      "list-class": ["list"].join(" ")
    }
  }), _c("mpx-switch"), _vm._v("123"), _c("mpx-scroll-view"), _c("mpx-input"), _c("mpx-picker", {
    attrs: {
      value: _vm.index,
      range: _vm.array
    }
  }, [_c("div", {
    staticClass: "picker"
  }, [_vm._v("当前选择：" + _vm._s(_vm.array[_vm.index]))])])], 1);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),
/* 209 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(210);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 210 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

var wxsModules = {};
__webpack_require__.g.currentModuleId = "mab35b83a";
__webpack_require__.g.currentSrcMode = "wx";
__webpack_require__.g.currentResource = "/Users/didi/Documents/Work/Code/mpx/examples/mpx-transform-web/src/pages/index.mpx";
/** script content **/
__webpack_require__(211);
var currentOption = __webpack_require__.g.__mpxOptionsMap["mab35b83a"];
/* harmony default export */ __webpack_exports__["default"] = ((0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__["default"])({
  option: currentOption,
  ctorType: "page",
  firstPage: undefined,
  outputPath: "",
  pageConfig: {
    "path": "/Users/didi/Documents/Work/Code/mpx/examples/mpx-transform-web/src/pages"
  },
  // @ts-ignore
  pagesMap: {},
  // @ts-ignore
  componentsMap: {
    'list': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(213), {}),
    'mpx-view': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(222), {
      "__mpxBuiltIn": true
    }),
    'mpx-text': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(225), {
      "__mpxBuiltIn": true
    }),
    'mpx-button': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(231), {
      "__mpxBuiltIn": true
    }),
    'mpx-switch': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(237), {
      "__mpxBuiltIn": true
    }),
    'mpx-scroll-view': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(243), {
      "__mpxBuiltIn": true
    }),
    'mpx-input': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(267), {
      "__mpxBuiltIn": true
    }),
    'mpx-picker': (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getComponent)(__webpack_require__(273), {
      "__mpxBuiltIn": true
    })
  },
  tabBarMap: {},
  componentGenerics: {},
  genericsInfo: undefined,
  mixin: (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getWxsMixin)(wxsModules),
  hasApp: true
}));

/***/ }),
/* 211 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _packageA_pages_swiper_mpx_resolve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(212);
/* harmony import */ var _packageA_pages_swiper_mpx_resolve__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_packageA_pages_swiper_mpx_resolve__WEBPACK_IMPORTED_MODULE_0__);


console.log('file: index.mpx:21 > swiperPage', (_packageA_pages_swiper_mpx_resolve__WEBPACK_IMPORTED_MODULE_0___default()));
(0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_1__["default"])({
  data: {
    a: 1,
    index: 0,
    array: ['美国', '中国', '巴西', '日本']
  },
  onLoad() {
    console.log('load index1111123');
  },
  onShow() {
    console.log('show index12455555511121312313123132');
    // console.log('test', swiperPage, mpx.i18n.locale)
  },

  methods: {
    reload() {
      window.location.reload();
    },
    jumpPage() {
      _mpxjs_core__WEBPACK_IMPORTED_MODULE_2__["default"].navigateTo({
        url: (_packageA_pages_swiper_mpx_resolve__WEBPACK_IMPORTED_MODULE_0___default())
      });
    }
  }
});

/***/ }),
/* 212 */
/***/ (function(module) {

module.exports = "/packageA/pages/swiper"

/***/ }),
/* 213 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _list_web_didi_mpx_vue_type_template_id_44ce4943_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(214);
/* harmony import */ var _list_web_didi_mpx_vue_type_script_lang_js_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(216);
/* harmony import */ var _list_web_didi_mpx_vue_type_style_index_0_id_44ce4943_lang_stylus_mpxStyleOptions_7B_22mid_22_3A_22m168002cd_22_7D_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(219);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(205);



;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _list_web_didi_mpx_vue_type_script_lang_js_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_1__["default"],
  _list_web_didi_mpx_vue_type_template_id_44ce4943_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__.render,
  _list_web_didi_mpx_vue_type_template_id_44ce4943_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/components/list.web.didi.mpx"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 214 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_template_id_44ce4943_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_template_id_44ce4943_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_template_id_44ce4943_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(215);


/***/ }),
/* 215 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "staticRenderFns": function() { return /* binding */ staticRenderFns; }
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c("div", {
    staticClass: "list"
  }, [_c("div", [_vm._v("web环境加载list组件")]), _vm._l(_vm.listData, function (item) {
    return _c("div", {
      staticClass: "list-item"
    }, [_vm._v(_vm._s(item))]);
  })], 2);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),
/* 216 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_script_lang_js_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(217);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_script_lang_js_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 217 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

var wxsModules = {};
__webpack_require__.g.currentModuleId = "m168002cd";
__webpack_require__.g.currentSrcMode = "wx";
__webpack_require__.g.currentResource = "/Users/didi/Documents/Work/Code/mpx/examples/mpx-transform-web/src/components/list.web.didi.mpx";
/** script content **/
__webpack_require__(218);
var currentOption = __webpack_require__.g.__mpxOptionsMap["m168002cd"];
/* harmony default export */ __webpack_exports__["default"] = ((0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__["default"])({
  option: currentOption,
  ctorType: "component",
  firstPage: undefined,
  outputPath: "components/list03fe4ada/index",
  pageConfig: {},
  // @ts-ignore
  pagesMap: {},
  // @ts-ignore
  componentsMap: {},
  tabBarMap: {},
  componentGenerics: {},
  genericsInfo: undefined,
  mixin: (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getWxsMixin)(wxsModules),
  hasApp: true
}));

/***/ }),
/* 218 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);


(0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_0__["default"])({
  externalClasses: ['list-class'],
  data: {
    listData: ['手机', '电视', '电脑']
  },
  onShow () {
    console.log('list')
  }
})


/***/ }),
/* 219 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_m168002cd_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_style_index_0_id_44ce4943_lang_stylus_mpxStyleOptions_7B_22mid_22_3A_22m168002cd_22_7D_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(220);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_m168002cd_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_style_index_0_id_44ce4943_lang_stylus_mpxStyleOptions_7B_22mid_22_3A_22m168002cd_22_7D_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_m168002cd_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_style_index_0_id_44ce4943_lang_stylus_mpxStyleOptions_7B_22mid_22_3A_22m168002cd_22_7D_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_m168002cd_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_style_index_0_id_44ce4943_lang_stylus_mpxStyleOptions_7B_22mid_22_3A_22m168002cd_22_7D_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_m168002cd_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_list_web_didi_mpx_vue_type_style_index_0_id_44ce4943_lang_stylus_mpxStyleOptions_7B_22mid_22_3A_22m168002cd_22_7D_infix_web_didi_isComponent_mode_web_outputPath_components_2Flist03fe4ada_2Findex__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 220 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(221);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("605aa225", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.list {\n  background-color: #f00;\n}\n", ""]);

// exports


/***/ }),
/* 222 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(223);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
var render, staticRenderFns
;



/* normalize component */
;
var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _mpx_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-view.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 223 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(224);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 224 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);

  

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-view',
    data () {
      return {
        hover: false
      }
    },
    props: {
      hoverClass: {
        type: String,
        default: 'none'
      },
      hoverStopPropagation: {
        type: Boolean,
        default: false
      },
      hoverStartTime: {
        type: Number,
        default: 50
      },
      hoverStayTime: {
        type: Number,
        default: 400
      }
    },
    render (createElement) {
      let mergeAfter
      if (this.hoverClass && this.hoverClass !== 'none') {
        mergeAfter = {
          listeners: {
            touchstart: this.handleTouchstart,
            touchend: this.handleTouchend
          },
          force: true
        }
      }
      const data = {
        class: ['mpx-view', this.className],
        on: (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__["default"])(this, { mergeAfter })
      }
      return createElement('div', data, this.$slots.default)
    },
    computed: {
      className () {
        if (this.hoverClass && this.hoverClass !== 'none' && this.hover) {
          return this.hoverClass
        }
        return ''
      }
    },
    methods: {
      handleTouchstart (e) {
        if (e.__hoverStopPropagation) {
          return
        }
        e.__hoverStopPropagation = this.hoverStopPropagation
        clearTimeout(this.startTimer)
        this.startTimer = setTimeout(() => {
          this.hover = true
        }, this.hoverStartTime)
      },
      handleTouchend () {
        clearTimeout(this.endTimer)
        this.endTimer = setTimeout(() => {
          this.hover = false
        }, this.hoverStayTime)
      }
    }
  });


/***/ }),
/* 225 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_text_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(226);
/* harmony import */ var _mpx_text_vue_vue_type_style_index_0_id_3e17c6d0_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(228);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
var render, staticRenderFns
;

;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _mpx_text_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-text.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 226 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_text_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(227);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_text_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 227 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);

  

  const encodeMap = {
    ' ': '&nbsp;',
    '<': '&lt;',
    '>': '&gt;',
    '&': '&amp;',
    '"': '&quot;',
    '\'': '&apos;'
  }

  const encodeRe = /[ <>"'&]/g

  function encodeText (text) {
    return text.replace(encodeRe, (match) => {
      return encodeMap[match]
    })
  }

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-text',
    props: {
      selectable: {
        type: Boolean,
        default: false
      },
      space: {
        type: String
      },
      decode: {
        type: Boolean,
        default: false
      }
    },
    render (createElement) {
      let text = ''
      let classNames = ['mpx-text']
      let decode = false
      const slots = this.$slots.default || []
      slots.forEach((item) => {
        if (item.text) {
          // item.text = encodeText(item.text)
          text += item.text
        }
      })
      if (this.selectable) {
        classNames.push('selectable')
      }
      switch (this.space) {
        case 'ensp':
        case 'emsp':
        case 'nbsp':
          decode = true
          text = text.replace(/ /g, `&${this.space};`)
          break
      }
      if (this.decode) {
        decode = true
      }
      const data = {
        class: classNames,
        on: (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__["default"])(this)
      }
      if (decode) {
        data.domProps = {
          innerHTML: text
        }
      }
      return createElement('span', data, slots)
    }
  });


/***/ }),
/* 228 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_text_vue_vue_type_style_index_0_id_3e17c6d0_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(229);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_text_vue_vue_type_style_index_0_id_3e17c6d0_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_text_vue_vue_type_style_index_0_id_3e17c6d0_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_text_vue_vue_type_style_index_0_id_3e17c6d0_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_text_vue_vue_type_style_index_0_id_3e17c6d0_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 229 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(230);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("5b438bba", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.mpx-text {\n  -webkit-user-select: none;\n          user-select: none;\n}\n.mpx-text.selectable {\n  -webkit-user-select: text;\n          user-select: text;\n}\n", ""]);

// exports


/***/ }),
/* 231 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_button_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _mpx_button_vue_vue_type_style_index_0_id_5a51eb5d_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(234);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
var render, staticRenderFns
;

;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _mpx_button_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-button.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 232 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_button_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(233);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_button_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 233 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);

  
  // 获取当前小程序样式版本配置
  const styleVersion = __webpack_require__.g.__style || ''
  const sizeClassMap = {
    'default': '',
    'mini': 'mpx-button-size-mini'
  }
  const typeClassMap = {
    'primary': 'mpx-button-type-primary',
    'warn': 'mpx-button-type-warn'
  }
  const plainClassMap = {
    'false': '',
    'true': 'mpx-button-plain'
  }
  const disabledClassMap = {
    'false': '',
    'true': 'mpx-button-disabled'
  }
  const clickDisabledClassMap = {
    'false': '',
    'true': 'mpx-button-click-disabled'
  }
  const loadingClassMap = {
    'false': '',
    'true': 'mpx-button-loading'
  }
  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-button',
    data () {
      return {
        hover: false
      }
    },
    props: {
      name: String,
      size: {
        type: String,
        default: 'default'
      },
      type: {
        type: String,
        default: 'default'
      },
      plain: Boolean,
      disabled: Boolean,
      loading: Boolean,
      formType: String,
      hoverClass: {
        type: String,
        default: 'button-hover'
      },
      hoverStopPropagation: {
        type: Boolean,
        default: false
      },
      hoverStartTime: {
        type: Number,
        default: 20
      },
      hoverStayTime: {
        type: Number,
        default: 70
      }
    },
    computed: {
      className () {
        if (this.hoverClass && this.hoverClass !== 'none' && this.hover) {
          return this.hoverClass
        }
        return ''
      },
      classNameList () {
        let classArr = []
        if (this.hoverClass && this.hoverClass !== 'none' && this.hover) {
          classArr.push(this.hoverClass)
        }
        if (styleVersion === 'v2') {
          classArr.push(`${sizeClassMap[this.size]}${styleVersion}`)
          classArr.push(`${typeClassMap[this.type]}${styleVersion}`)
          classArr.push(`mpx-button-version${styleVersion}`)
        } else {
          classArr.push(sizeClassMap[this.size])
          classArr.push(typeClassMap[this.type])
          classArr.push(`mpx-button-version`)
        }
        classArr.push(plainClassMap[this.plain])
        classArr.push(disabledClassMap['' + !!this.disabled])
        // 禁用click
        classArr.push(clickDisabledClassMap['' + !!this.disabled])
        classArr.push(loadingClassMap['' + !!this.loading])
        return classArr
      }
    },
    mounted () {
      if (this.formType) {
        this.$on('tap', () => {
          if (this.form && this.form[this.formType]) {
            this.form[this.formType]()
          }
        })
      }
    },
    render (createElement) {
      let mergeAfter
      if (this.hoverClass && this.hoverClass !== 'none') {
        mergeAfter = {
          listeners: {
            touchstart: this.handleTouchstart,
            touchend: this.handleTouchend
          },
          force: true
        }
      }
      const domProps = {
        name: this.name,
        disabled: this.disabled,
        loading: this.loading,
        plain: this.plain,
        type: this.type
      }
      const data = {
        class: ['mpx-button', ...this.classNameList],
        domProps,
        on: (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__["default"])(this, {
          mergeAfter,
          // 由于当前机制下tap事件只有存在tap监听才会触发，为了确保该组件能够触发tap，传递一个包含tap的defaultListeners用于模拟存在tap监听
          defaultListeners: ['tap']
        })
      }
      return createElement('div', data, this.$slots.default)
    },
    methods: {
      handleTouchstart (e) {
        if (e.__hoverStopPropagation) {
          return
        }
        e.__hoverStopPropagation = this.hoverStopPropagation
        clearTimeout(this.startTimer)
        this.startTimer = setTimeout(() => {
          this.hover = true
        }, this.hoverStartTime)
      },
      handleTouchend () {
        clearTimeout(this.endTimer)
        this.endTimer = setTimeout(() => {
          this.hover = false
        }, this.hoverStayTime)
      }
    }
  });


/***/ }),
/* 234 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_button_vue_vue_type_style_index_0_id_5a51eb5d_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(235);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_button_vue_vue_type_style_index_0_id_5a51eb5d_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_button_vue_vue_type_style_index_0_id_5a51eb5d_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_button_vue_vue_type_style_index_0_id_5a51eb5d_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_button_vue_vue_type_style_index_0_id_5a51eb5d_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 235 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(236);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("893e3572", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.mpx-button-versionv2 {\n  width: 184px;\n  line-height: 1.41176471;\n  font-weight: 700;\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.mpx-button-version {\n  width: 100%;\n  line-height: 2.55555556;\n  cursor: pointer;\n}\n.mpx-button-version:after {\n  border: 1px solid rgba(0,0,0,0.2);\n}\n.mpx-button {\n  padding-left: 14px;\n  padding-right: 14px;\n  border: none;\n  outline: none;\n  position: relative;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  box-sizing: border-box;\n  font-size: 18px;\n  text-align: center;\n  text-decoration: none;\n  border-radius: 5px;\n  -webkit-tap-highlight-color: transparent;\n  overflow: hidden;\n  color: #000;\n  background-color: #f8f8f8;\n/* 默认版本 size=mini style */\n/* v2 size=mini style */\n/* 默认版本 type=primary style */\n/* v2 type=primary style */\n/* 默认版本 type=warn style */\n/* v2 type=warn style */\n}\n.mpx-button:after {\n  content: \" \";\n  width: 200%;\n  height: 200%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  -webkit-transform: scale(0.5);\n  transform: scale(0.5);\n  -webkit-transform-origin: 0 0;\n  transform-origin: 0 0;\n  box-sizing: border-box;\n  border-radius: 10px;\n}\n.mpx-button.button-hover {\n  background-color: #dedede;\n}\n.mpx-button.mpx-button-size-mini {\n  display: inline-block;\n  line-height: 2.3;\n  font-size: 13px;\n  padding: 0 1.34em;\n  width: auto;\n}\n.mpx-button.mpx-button-size-miniv2 {\n  width: auto;\n  padding: 0 0.75em;\n  line-height: 2;\n  font-size: 16px;\n  display: inline-block;\n}\n.mpx-button.mpx-button-plain {\n  color: #353535;\n  border: 1px solid #353535;\n  background-color: transparent;\n}\n.mpx-button.mpx-button-plain.mpx-button-plain.button-hover {\n  background-color: rgba(0,0,0,0);\n  color: #828282;\n  border: 1px solid #828282;\n}\n.mpx-button.mpx-button-type-primary {\n  background-color: #1aad19;\n  color: #fff;\n}\n.mpx-button.mpx-button-type-primary.mpx-button-type-primary.mpx-button-plain {\n  color: #1aad19;\n  border-color: #1aad19;\n  background-color: #fff;\n}\n.mpx-button.mpx-button-type-primaryv2 {\n  background-color: #07c160;\n  color: #fff;\n}\n.mpx-button.mpx-button-type-primaryv2.mpx-button-type-primaryv2.button-hover {\n  color: #fff;\n  background-color: #06ad56;\n}\n.mpx-button.mpx-button-type-primaryv2.mpx-button-type-primaryv2.mpx-button-plain {\n  color: #06ae56;\n  border-color: #179c16;\n  background-color: #fff;\n}\n.mpx-button.mpx-button-type-primaryv2.mpx-button-type-primaryv2.button-hover.mpx-button-plain {\n  color: #06ae56;\n  background-color: rgba(0,0,0,0.1);\n}\n.mpx-button.mpx-button-type-warn {\n  color: #fff;\n  background-color: #e64340;\n}\n.mpx-button.mpx-button-type-warn.mpx-button-type-warn.mpx-button-plain {\n  color: #e64340;\n  background-color: transparent;\n  border: 1px solid #e64340;\n}\n.mpx-button.mpx-button-type-warnv2 {\n  color: #fa5151;\n  background-color: #f2f2f2;\n}\n.mpx-button.mpx-button-type-warnv2.mpx-button-type-warnv2.button-hover {\n  background-color: #d9d9d9;\n}\n.mpx-button.mpx-button-type-warnv2.mpx-button-type-warnv2.mpx-button-plain {\n  color: #fa5151;\n  background-color: #fff;\n  border: 1px solid #e64340;\n}\n.mpx-button.mpx-button-type-warnv2.mpx-button-type-warnv2.button-hover.mpx-button-plain {\n  color: #f58c8d;\n  border: 1px solid #f58a8b;\n  background-color: #fff;\n}\n.mpx-button.mpx-button-disabled {\n  color: rgba(0,0,0,0.18) !important;\n  background-color: #fafafa !important;\n  border: 1px solid rgba(0,0,0,0.2) !important;\n}\n.mpx-button.mpx-button-click-disabled {\n  pointer-events: none;\n}\n.mpx-button.mpx-button-loading.mpx-button-type-warn {\n  color: rgba(255,255,255,0.6);\n  background-color: #ce3c39;\n}\n.mpx-button.mpx-button-loading.mpx-button-type-warnv2 {\n  background-color: #d9d9d9;\n  color: #fa5151;\n}\n.mpx-button.mpx-button-loading.mpx-button-type-primary {\n  color: rgba(255,255,255,0.6);\n  background-color: #179b16;\n}\n.mpx-button.mpx-button-loading:before {\n  content: \" \";\n  display: inline-block;\n  width: 18px;\n  height: 18px;\n  vertical-align: middle;\n  -webkit-animation: mpxButton 1s steps(12, end) infinite;\n  animation: mpxButton 1s steps(12, end) infinite;\n  background: transparent url(\"data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iciIgd2lkdGg9JzEyMHB4JyBoZWlnaHQ9JzEyMHB4JyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICAgIDxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiBmaWxsPSJub25lIiBjbGFzcz0iYmsiPjwvcmVjdD4KICAgIDxyZWN0IHg9JzQ2LjUnIHk9JzQwJyB3aWR0aD0nNycgaGVpZ2h0PScyMCcgcng9JzUnIHJ5PSc1JyBmaWxsPScjRTlFOUU5JwogICAgICAgICAgdHJhbnNmb3JtPSdyb3RhdGUoMCA1MCA1MCkgdHJhbnNsYXRlKDAgLTMwKSc+CiAgICA8L3JlY3Q+CiAgICA8cmVjdCB4PSc0Ni41JyB5PSc0MCcgd2lkdGg9JzcnIGhlaWdodD0nMjAnIHJ4PSc1JyByeT0nNScgZmlsbD0nIzk4OTY5NycKICAgICAgICAgIHRyYW5zZm9ybT0ncm90YXRlKDMwIDUwIDUwKSB0cmFuc2xhdGUoMCAtMzApJz4KICAgICAgICAgICAgICAgICByZXBlYXRDb3VudD0naW5kZWZpbml0ZScvPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyM5Qjk5OUEnCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSg2MCA1MCA1MCkgdHJhbnNsYXRlKDAgLTMwKSc+CiAgICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9J2luZGVmaW5pdGUnLz4KICAgIDwvcmVjdD4KICAgIDxyZWN0IHg9JzQ2LjUnIHk9JzQwJyB3aWR0aD0nNycgaGVpZ2h0PScyMCcgcng9JzUnIHJ5PSc1JyBmaWxsPScjQTNBMUEyJwogICAgICAgICAgdHJhbnNmb3JtPSdyb3RhdGUoOTAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNBQkE5QUEnCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgxMjAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNCMkIyQjInCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgxNTAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNCQUI4QjknCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgxODAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNDMkMwQzEnCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgyMTAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNDQkNCQ0InCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgyNDAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNEMkQyRDInCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgyNzAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNEQURBREEnCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgzMDAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0PgogICAgPHJlY3QgeD0nNDYuNScgeT0nNDAnIHdpZHRoPSc3JyBoZWlnaHQ9JzIwJyByeD0nNScgcnk9JzUnIGZpbGw9JyNFMkUyRTInCiAgICAgICAgICB0cmFuc2Zvcm09J3JvdGF0ZSgzMzAgNTAgNTApIHRyYW5zbGF0ZSgwIC0zMCknPgogICAgPC9yZWN0Pgo8L3N2Zz4=\") no-repeat;\n  background-size: 100%;\n  margin: -0.2em 0.34em 0 0;\n}\n@-moz-keyframes mpxButton {\n0% {\n    transform: rotate3d(0, 0, 1, 0deg);\n}\n100% {\n    transform: rotate3d(0, 0, 1, 360deg);\n}\n}\n@-webkit-keyframes mpxButton {\n0% {\n    transform: rotate3d(0, 0, 1, 0deg);\n}\n100% {\n    transform: rotate3d(0, 0, 1, 360deg);\n}\n}\n@-o-keyframes mpxButton {\n0% {\n    transform: rotate3d(0, 0, 1, 0deg);\n}\n100% {\n    transform: rotate3d(0, 0, 1, 360deg);\n}\n}\n@keyframes mpxButton {\n0% {\n    transform: rotate3d(0, 0, 1, 0deg);\n}\n100% {\n    transform: rotate3d(0, 0, 1, 360deg);\n}\n}\n", ""]);

// exports


/***/ }),
/* 237 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_switch_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(238);
/* harmony import */ var _mpx_switch_vue_vue_type_style_index_0_id_303faa5f_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
var render, staticRenderFns
;

;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _mpx_switch_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-switch.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 238 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_switch_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(239);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_switch_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 239 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);

  

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-switch',
    props: {
      name: String,
      type: {
        type: String,
        default: 'switch'
      },
      checked: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      color: {
        type: String,
        default: '#04BE02'
      }
    },
    watch: {
      checked (newVal) {
        this.switchChecked = newVal
      }
    },
    data () {
      return {
        switchChecked: this.checked
      }
    },
    render (createElement) {
      let children = []
      if (this.type === 'switch') {
        const switchElem = createElement('div', {
          class: ['mpx-switch-label', this.switchChecked ? 'checked-switch-label' : 'uncheck-switch-label'],
          style: this.switchChecked ? {
            borderColor: this.color,
            background: this.color
          } : {}
        })
        children.push(switchElem)
      } else {
        const style = __webpack_require__.g.__style === 'v2' ? 'v2' : 'v1'
        const checkbox = createElement('div', {
          class: ['mpx-switch-checkbox', this.switchChecked && 'mpx-switch-checkbox-checked-' + style, this.disabled && 'switch-disabled']
        })

        children.push(checkbox)
      }
      children.push(...(this.$slots.default || []))
      const data = {
        class: [this.type === 'switch' ? 'mpx-switch-wrap' : 'mpx-checkbox-wrap'],
        ref: 'switch',
        on: {
          click: (e) => {
            if (this.disabled) {
              return
            }
            this.switchChecked = !this.switchChecked
            this.notifyChange()
          }
        }
      }
      return createElement('div', data, children)
    },
    methods: {
      getValue () {
        return this.switchChecked
      },
      setValue (value) {
        this.switchChecked = value
      },
      notifyChange (value) {
        if (value !== undefined) {
          this.setValue(value)
        } else {
          value = this.getValue()
        }
        this.$emit('change', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.getCustomEvent)('change', { value }, this.$refs.switch))
      }
    }
  });


/***/ }),
/* 240 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_switch_vue_vue_type_style_index_0_id_303faa5f_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(241);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_switch_vue_vue_type_style_index_0_id_303faa5f_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_switch_vue_vue_type_style_index_0_id_303faa5f_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_switch_vue_vue_type_style_index_0_id_303faa5f_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_switch_vue_vue_type_style_index_0_id_303faa5f_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 241 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(242);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("5bffd144", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.mpx-checkbox-wrap {\n  display: inline-flex;\n  position: relative;\n}\n.mpx-switch-wrap {\n  display: inline-flex;\n  width: 52px;\n  height: 32px;\n  position: relative;\n}\n.mpx-switch-wrap .mpx-switch-label {\n  width: 52px;\n  height: 32px;\n  border-radius: 16px;\n  border: 1px solid #dfdfdf;\n}\n.mpx-switch-wrap .mpx-switch-label.checked-switch-label:before {\n  transform: scale(0);\n}\n.mpx-switch-wrap .mpx-switch-label.checked-switch-label:after {\n  transform: translateX(18px);\n}\n.mpx-switch-wrap .mpx-switch-label:before {\n  content: \" \";\n  position: absolute;\n  width: 50px;\n  height: 30px;\n  border-radius: 15px;\n  background-color: #fdfdfd;\n  transition: transform 0.3s;\n}\n.mpx-switch-wrap .mpx-switch-label:after {\n  width: 32px;\n  height: 32px;\n  position: absolute;\n  left: 1px;\n  top: 1px;\n  box-shadow: 0 1px 3px rgba(0,0,0,0.4);\n  background: #fff;\n  display: inline-block;\n  content: \"\";\n  border-radius: 100%;\n  transition: transform 0.3s, -webkit-transform 0.3s;\n}\n.mpx-switch-checkbox {\n  -webkit-appearance: none;\n          appearance: none;\n  outline: 0;\n  text-indent: 0;\n  border: 1px solid #d1d1d1;\n  background-color: #fff;\n  border-radius: 3px;\n  width: 22px;\n  height: 22px;\n  position: relative;\n}\n.mpx-switch-checkbox.switch-disabled {\n  background: #e1e1e1;\n  color: #adadad;\n}\n.mpx-switch-checkbox-checked-v1 {\n  color: #09bb07;\n}\n.mpx-switch-checkbox-checked-v1:before {\n  font: normal normal normal 14px/1 \"weui\";\n  content: \"\\EA08\";\n  font-size: 22px;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -48%) scale(0.73);\n  -webkit-transform: translate(-50%, -48%) scale(0.73);\n}\n.mpx-switch-checkbox-checked-v2:before {\n  color: #09bb07;\n  display: inline-block;\n  width: 22px;\n  height: 22px;\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -48%) scale(0.73);\n  -webkit-transform: translate(-50%, -48%) scale(0.73);\n  mask-position: 50% 50%;\n  -webkit-mask-position: 50% 50%;\n  -webkit-mask-repeat: no-repeat;\n  mask-repeat: no-repeat;\n  -webkit-mask-size: 100%;\n  mask-size: 100%;\n  background-color: currentColor;\n  mask-image: url(\"data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M8.657%2018.435L3%2012.778l1.414-1.414%204.95%204.95L20.678%205l1.414%201.414-12.02%2012.021a1%201%200%2001-1.415%200z%22%20fill-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E\");\n  -webkit-mask-image: url(\"data:image/svg+xml,%3Csvg%20width%3D%2224%22%20height%3D%2224%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M8.657%2018.435L3%2012.778l1.414-1.414%204.95%204.95L20.678%205l1.414%201.414-12.02%2012.021a1%201%200%2001-1.415%200z%22%20fill-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E\");\n}\n", ""]);

// exports


/***/ }),
/* 243 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_scroll_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(244);
/* harmony import */ var _mpx_scroll_view_vue_vue_type_style_index_0_id_74aaaf0a_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(264);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
var render, staticRenderFns
;

;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _mpx_scroll_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-scroll-view.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 244 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_scroll_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(245);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_scroll_view_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 245 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(201);
/* harmony import */ var _better_scroll_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(246);
/* harmony import */ var _better_scroll_pull_down__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(247);
/* harmony import */ var _better_scroll_observe_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(248);
/* harmony import */ var lodash_es_throttle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(249);

  
  
  
  
  
  

  _better_scroll_core__WEBPACK_IMPORTED_MODULE_2__["default"].use(_better_scroll_observe_dom__WEBPACK_IMPORTED_MODULE_4__["default"])
  _better_scroll_core__WEBPACK_IMPORTED_MODULE_2__["default"].use(_better_scroll_pull_down__WEBPACK_IMPORTED_MODULE_3__["default"])

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-scroll-view',
    props: {
      scrollX: Boolean,
      scrollY: Boolean,
      upperThreshold: {
        type: [Number, String],
        default: 50
      },
      lowerThreshold: {
        type: [Number, String],
        default: 50
      },
      scrollTop: {
        type: [Number, String],
        default: 0
      },
      scrollLeft: {
        type: [Number, String],
        default: 0
      },
      scrollOptions: Object,
      updateRefresh: {
        type: Boolean,
        default: true
      },
      scrollIntoView: String,
      scrollWithAnimation: Boolean,
      enableFlex: Boolean,
      enhanced: Boolean,
      refresherEnabled: Boolean,
      refresherTriggered: Boolean,
      refresherThreshold: {
        type: Number,
        default: 45
      },
      refresherDefaultStyle: {
        type: String,
        default: 'black'
      },
      refresherBackground: {
        type: String,
        default: ''
      }
    },
    data () {
      return {
        isLoading: false,
        isAutoPullDown: true
      }
    },
    computed: {
      _scrollTop () {
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.processSize)(this.scrollTop)
      },
      _scrollLeft () {
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.processSize)(this.scrollLeft)
      },
      _lowerThreshold () {
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.processSize)(this.lowerThreshold)
      },
      _upperThreshold () {
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.processSize)(this.upperThreshold)
      },
      _pullDownWrapperStyle () {
        return `background:${this.refresherBackground}`
      },
      _pullDownContentClassName () {
        let className = 'mpx-pull-down-content'
        if (this.refresherDefaultStyle === 'black') {
          className += ' mpx-pull-down-content-black'
        } else if (this.refresherDefaultStyle === 'white') {
          className += ' mpx-pull-down-content-white'
        }
        if (this.isLoading) {
          className += ' active'
        }
        return className
      }
    },
    mounted () {
      this.init()
    },
    activated () {
      if (!this.__mpx_deactivated) {
        return
      }
      this.__mpx_deactivated = false
      if (this.__mpx_deactivated_refresh) {
        this.__mpx_deactivated_refresh = false
        this.refresh()
      }
    },
    deactivated () {
      this.__mpx_deactivated = true
    },
    beforeDestroy () {
      this.destroy()
    },
    updated () {
      if (this.updateRefresh) this.refresh()
    },
    watch: {
      scrollIntoView (val) {
        this.bs && this.bs.scrollToElement('#' + val, this.scrollWithAnimation ? 200 : 0)
      },
      _scrollTop (val) {
        this.bs && this.bs.scrollTo(this.bs.x, -val, this.scrollWithAnimation ? 200 : 0)
      },
      _scrollLeft (val) {
        this.bs && this.bs.scrollTo(-val, this.bs.y, this.scrollWithAnimation ? 200 : 0)
      },
      refresherTriggered: {
        handler (val) {
          if (!val) {
            this.$emit('refresherrestore')
            this.isLoading = false
            this.isAutoPullDown = true
            this.bs && this.bs.finishPullDown()
            this.bs && this.bs.refresh()
          } else {
            if (this.isAutoPullDown) {
              this.isLoading = true
              this.bs.autoPullDownRefresh()
            }
          }
        },
      }
    },
    methods: {
      destroy () {
        if (!this.bs) return
        this.bs.destroy()
        delete this.bs
      },
      init () {
        if (this.bs) return
        this.initLayerComputed()
        const originBsOptions = {
          startX: -this._scrollLeft,
          startY: -this._scrollTop,
          scrollX: this.scrollX,
          scrollY: this.scrollY,
          probeType: 3,
          bounce: false,
          stopPropagation: true,
          bindToWrapper: true,
          eventPassthrough: (this.scrollX && 'vertical') || (this.scrollY && 'horizontal') || ''
        }
        if (this.refresherEnabled) {
          originBsOptions.bounce = true
          originBsOptions.pullDownRefresh = {
            threshold: this.refresherThreshold,
            stop: 56
          }
        }
        const bsOptions = Object.assign({}, originBsOptions, this.scrollOptions)
        this.bs = new _better_scroll_core__WEBPACK_IMPORTED_MODULE_2__["default"](this.$refs.wrapper, bsOptions)
        this.bs.scroller.hooks.on('beforeRefresh', () => {
          this.initLayerComputed()
        })
        this.lastX = -this._scrollLeft
        this.lastY = -this._scrollTop
        this.bs.on('scroll', (0,lodash_es_throttle__WEBPACK_IMPORTED_MODULE_5__["default"])(({ x, y }) => {
          const deltaX = x - this.lastX
          const deltaY = y - this.lastY
          this.$emit('scroll', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.getCustomEvent)('scroll', {
            scrollLeft: -x,
            scrollTop: -y,
            scrollWidth: this.bs.scrollerWidth,
            scrollHeight: this.bs.scrollerHeight,
            deltaX,
            deltaY
          }))
          if (this.bs.minScrollX - x < this._upperThreshold && deltaX > 0) {
            this.dispatchScrollTo('left')
          }
          if (this.bs.minScrollY - y < this._upperThreshold && deltaY > 0) {
            this.dispatchScrollTo('top')
          }
          if (x - this.bs.maxScrollX < this._lowerThreshold && deltaX < 0) {
            this.dispatchScrollTo('right')
          }
          if (y - this.bs.maxScrollY < this._lowerThreshold && deltaY < 0) {
            this.dispatchScrollTo('bottom')
          }
          this.lastX = x
          this.lastY = y
        }, 30, {
          leading: true,
          trailing: false
        }))
        if (this.scrollIntoView) {
          this.bs.scrollToElement('#' + this.scrollIntoView)
        }
        // 若开启自定义下拉刷新 或 开启 scroll-view 增强特性
        if (this.refresherEnabled || this.enhanced) {
          const actionsHandlerHooks = this.bs.scroller.actionsHandler.hooks
          actionsHandlerHooks.on('start', () => {
            if (this.enhanced) {
              this.$emit('dragstart', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.getCustomEvent)('dragstart', {
                scrollLeft: this.bs.x ? this.bs.x * -1 : 0,
                scrollTop: this.bs.y ? this.bs.y * -1 : 0
              }))
            }
            if (this.refresherEnabled) {
              this.isAutoPullDown = false
            }
          })
          actionsHandlerHooks.on('move', () => {
            if (this.enhanced) {
              this.$emit('dragging', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.getCustomEvent)('dragging', {
                scrollLeft: this.bs.x ? this.bs.x * -1 : 0,
                scrollTop: this.bs.y ? this.bs.y * -1 : 0
              }))
            }
            if (this.refresherEnabled) {
              if (this.bs.y > 0 && this.bs.y < this.refresherThreshold && this.bs.movingDirectionY !== 1) {
                this.isAutoPullDown = false
                this.isLoading = false
                this.$emit('refresherpulling')
              }
            }
          })
          actionsHandlerHooks.on('end', () => {
            if (this.enhanced) {
              this.$emit('dragend', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.getCustomEvent)('dragend', {
                scrollLeft: this.bs.x ? this.bs.x * -1 : 0,
                scrollTop: this.bs.y ? this.bs.y * -1 : 0
              }))
            }
          })
          if (this.refresherEnabled) {
            // 下拉结束其他钩子都被bs阻止了，只有touchEnd可以触发
            this.bs.scroller.hooks.on('touchEnd', () => {
              if (this.bs.y > 0 && this.bs.movingDirectionY !== 1) {
                this.isLoading = true
                if (this.bs.y < this.refresherThreshold) {
                  this.isAutoPullDown = true
                  this.$emit('refresherabort')
                }
              }
            })
            this.bs.on('pullingDown', () => {
              this.$emit('refresherrefresh')
            })
          }
        }
      },
      initLayerComputed () {
        const wrapper = this.$refs.wrapper
        const wrapperWidth = wrapper.offsetWidth
        const wrapperHeight = wrapper.offsetHeight
        this.$refs.innerWrapper.style.width = `${wrapperWidth}px`
        this.$refs.innerWrapper.style.height = `${wrapperHeight}px`
        const innerWrapper = this.$refs.innerWrapper
        const childrenArr = Array.from(innerWrapper.children)

        const getMinLength = (min, value) => {
          if (min === undefined) {
            min = value
          } else {
            min = min > value ? value : min
          }
          return min
        }

        const getMaxLength = (max, value) => {
          if (max === undefined) {
            max = value
          } else {
            max = max < value ? value : max
          }
          return max
        }

        let minLeft
        let maxRight
        let minTop
        let maxBottom
        childrenArr.forEach(item => {
          const temp = item.getBoundingClientRect()
          minLeft = getMinLength(minLeft, temp.left)
          minTop = getMinLength(minTop, temp.top)
          maxRight = getMaxLength(maxRight, temp.right)
          maxBottom = getMaxLength(maxBottom, temp.bottom)
        })

        const width = maxRight - minLeft
        const height = maxBottom - minTop
        this.$refs.scrollContent.style.width = `${width}px`
        this.$refs.scrollContent.style.height = `${height}px`
      },
      refresh () {
        if (this.__mpx_deactivated) {
          this.__mpx_deactivated_refresh = true
          return
        }
        if (this.bs) this.bs.refresh()
      },
      dispatchScrollTo: (0,lodash_es_throttle__WEBPACK_IMPORTED_MODULE_5__["default"])(function (direction) {
        let eventName = 'scrolltoupper'
        if (direction === 'bottom' || direction === 'right') eventName = 'scrolltolower'
        this.$emit(eventName, (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.getCustomEvent)(eventName, { direction }))
      }, 200, {
        leading: true,
        trailing: false
      })
    },
    render (createElement) {
      const data = {
        class: 'mpx-scroll-view',
        on: (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__["default"])(this, { ignoredListeners: ['scroll', 'scrolltoupper', 'scrolltolower'] }),
        ref: 'wrapper'
      }

      const innerWrapper = createElement('div', {
        ref: 'innerWrapper'
      }, this.$slots.default)

      const pullDownContent = this.refresherDefaultStyle !== 'none' ? createElement('div', {
          class: this._pullDownContentClassName,
        }, [
          createElement('div', {
            class: 'circle circle-a'
          }),
          createElement('div', {
            class: 'circle circle-b'
          }),
          createElement('div', {
            class: 'circle circle-c'
          }),
        ]
      ) : null

      const pullDownWrapper = this.refresherEnabled ? createElement('div', {
        class: 'mpx-pull-down-wrapper',
        style: this._pullDownWrapperStyle
      }, [pullDownContent]) : null

      const content = createElement('div', {
        class: 'mpx-scroll-view-content',
        ref: 'scrollContent'
      }, [pullDownWrapper, innerWrapper])

      return createElement('div', data, [content])
    }
  });


/***/ }),
/* 246 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Behavior": function() { return /* binding */ Behavior; },
/* harmony export */   "CustomOptions": function() { return /* binding */ CustomOptions; },
/* harmony export */   "createBScroll": function() { return /* binding */ createBScroll; },
/* harmony export */   "default": function() { return /* binding */ BScroll; }
/* harmony export */ });
/*!
 * better-scroll / core
 * (c) 2016-2022 ustbhuangyi
 * Released under the MIT License.
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var propertiesConfig = [
    {
        sourceKey: 'scroller.scrollBehaviorX.currentPos',
        key: 'x'
    },
    {
        sourceKey: 'scroller.scrollBehaviorY.currentPos',
        key: 'y'
    },
    {
        sourceKey: 'scroller.scrollBehaviorX.hasScroll',
        key: 'hasHorizontalScroll'
    },
    {
        sourceKey: 'scroller.scrollBehaviorY.hasScroll',
        key: 'hasVerticalScroll'
    },
    {
        sourceKey: 'scroller.scrollBehaviorX.contentSize',
        key: 'scrollerWidth'
    },
    {
        sourceKey: 'scroller.scrollBehaviorY.contentSize',
        key: 'scrollerHeight'
    },
    {
        sourceKey: 'scroller.scrollBehaviorX.maxScrollPos',
        key: 'maxScrollX'
    },
    {
        sourceKey: 'scroller.scrollBehaviorY.maxScrollPos',
        key: 'maxScrollY'
    },
    {
        sourceKey: 'scroller.scrollBehaviorX.minScrollPos',
        key: 'minScrollX'
    },
    {
        sourceKey: 'scroller.scrollBehaviorY.minScrollPos',
        key: 'minScrollY'
    },
    {
        sourceKey: 'scroller.scrollBehaviorX.movingDirection',
        key: 'movingDirectionX'
    },
    {
        sourceKey: 'scroller.scrollBehaviorY.movingDirection',
        key: 'movingDirectionY'
    },
    {
        sourceKey: 'scroller.scrollBehaviorX.direction',
        key: 'directionX'
    },
    {
        sourceKey: 'scroller.scrollBehaviorY.direction',
        key: 'directionY'
    },
    {
        sourceKey: 'scroller.actions.enabled',
        key: 'enabled'
    },
    {
        sourceKey: 'scroller.animater.pending',
        key: 'pending'
    },
    {
        sourceKey: 'scroller.animater.stop',
        key: 'stop'
    },
    {
        sourceKey: 'scroller.scrollTo',
        key: 'scrollTo'
    },
    {
        sourceKey: 'scroller.scrollBy',
        key: 'scrollBy'
    },
    {
        sourceKey: 'scroller.scrollToElement',
        key: 'scrollToElement'
    },
    {
        sourceKey: 'scroller.resetPosition',
        key: 'resetPosition'
    }
];

function warn(msg) {
    console.error("[BScroll warn]: " + msg);
}

// ssr support
var inBrowser = typeof window !== 'undefined';
var ua = inBrowser && navigator.userAgent.toLowerCase();
var isWeChatDevTools = !!(ua && /wechatdevtools/.test(ua));
var isAndroid = ua && ua.indexOf('android') > 0;
/* istanbul ignore next */
var isIOSBadVersion = (function () {
    if (typeof ua === 'string') {
        var regex = /os (\d\d?_\d(_\d)?)/;
        var matches = regex.exec(ua);
        if (!matches)
            return false;
        var parts = matches[1].split('_').map(function (item) {
            return parseInt(item, 10);
        });
        // ios version >= 13.4 issue 982
        return !!(parts[0] === 13 && parts[1] >= 4);
    }
    return false;
})();
/* istanbul ignore next */
var supportsPassive = false;
/* istanbul ignore next */
if (inBrowser) {
    var EventName = 'test-passive';
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', {
            get: function () {
                supportsPassive = true;
            },
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener(EventName, function () { }, opts);
    }
    catch (e) { }
}

function getNow() {
    return window.performance &&
        window.performance.now &&
        window.performance.timing
        ? window.performance.now() + window.performance.timing.navigationStart
        : +new Date();
}
var extend = function (target, source) {
    for (var key in source) {
        target[key] = source[key];
    }
    return target;
};
function isUndef(v) {
    return v === undefined || v === null;
}
function between(x, min, max) {
    if (x < min) {
        return min;
    }
    if (x > max) {
        return max;
    }
    return x;
}

var elementStyle = (inBrowser &&
    document.createElement('div').style);
var vendor = (function () {
    /* istanbul ignore if  */
    if (!inBrowser) {
        return false;
    }
    var transformNames = [
        {
            key: 'standard',
            value: 'transform',
        },
        {
            key: 'webkit',
            value: 'webkitTransform',
        },
        {
            key: 'Moz',
            value: 'MozTransform',
        },
        {
            key: 'O',
            value: 'OTransform',
        },
        {
            key: 'ms',
            value: 'msTransform',
        },
    ];
    for (var _i = 0, transformNames_1 = transformNames; _i < transformNames_1.length; _i++) {
        var obj = transformNames_1[_i];
        if (elementStyle[obj.value] !== undefined) {
            return obj.key;
        }
    }
    /* istanbul ignore next  */
    return false;
})();
/* istanbul ignore next  */
function prefixStyle(style) {
    if (vendor === false) {
        return style;
    }
    if (vendor === 'standard') {
        if (style === 'transitionEnd') {
            return 'transitionend';
        }
        return style;
    }
    return vendor + style.charAt(0).toUpperCase() + style.substr(1);
}
function getElement(el) {
    return (typeof el === 'string' ? document.querySelector(el) : el);
}
function addEvent(el, type, fn, capture) {
    var useCapture = supportsPassive
        ? {
            passive: false,
            capture: !!capture,
        }
        : !!capture;
    el.addEventListener(type, fn, useCapture);
}
function removeEvent(el, type, fn, capture) {
    el.removeEventListener(type, fn, {
        capture: !!capture,
    });
}
function maybePrevent(e) {
    if (e.cancelable) {
        e.preventDefault();
    }
}
function offset(el) {
    var left = 0;
    var top = 0;
    while (el) {
        left -= el.offsetLeft;
        top -= el.offsetTop;
        el = el.offsetParent;
    }
    return {
        left: left,
        top: top,
    };
}
vendor && vendor !== 'standard' ? '-' + vendor.toLowerCase() + '-' : '';
var transform = prefixStyle('transform');
var transition = prefixStyle('transition');
var hasPerspective = inBrowser && prefixStyle('perspective') in elementStyle;
// fix issue #361
var hasTouch = inBrowser && ('ontouchstart' in window || isWeChatDevTools);
var hasTransition = inBrowser && transition in elementStyle;
var style = {
    transform: transform,
    transition: transition,
    transitionTimingFunction: prefixStyle('transitionTimingFunction'),
    transitionDuration: prefixStyle('transitionDuration'),
    transitionDelay: prefixStyle('transitionDelay'),
    transformOrigin: prefixStyle('transformOrigin'),
    transitionEnd: prefixStyle('transitionEnd'),
    transitionProperty: prefixStyle('transitionProperty'),
};
var eventTypeMap = {
    touchstart: 1,
    touchmove: 1,
    touchend: 1,
    touchcancel: 1,
    mousedown: 2,
    mousemove: 2,
    mouseup: 2,
};
function getRect(el) {
    /* istanbul ignore if  */
    if (el instanceof window.SVGElement) {
        var rect = el.getBoundingClientRect();
        return {
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height,
        };
    }
    else {
        return {
            top: el.offsetTop,
            left: el.offsetLeft,
            width: el.offsetWidth,
            height: el.offsetHeight,
        };
    }
}
function preventDefaultExceptionFn(el, exceptions) {
    for (var i in exceptions) {
        if (exceptions[i].test(el[i])) {
            return true;
        }
    }
    return false;
}
var tagExceptionFn = preventDefaultExceptionFn;
function tap(e, eventName) {
    var ev = document.createEvent('Event');
    ev.initEvent(eventName, true, true);
    ev.pageX = e.pageX;
    ev.pageY = e.pageY;
    e.target.dispatchEvent(ev);
}
function click(e, event) {
    if (event === void 0) { event = 'click'; }
    var eventSource;
    if (e.type === 'mouseup') {
        eventSource = e;
    }
    else if (e.type === 'touchend' || e.type === 'touchcancel') {
        eventSource = e.changedTouches[0];
    }
    var posSrc = {};
    if (eventSource) {
        posSrc.screenX = eventSource.screenX || 0;
        posSrc.screenY = eventSource.screenY || 0;
        posSrc.clientX = eventSource.clientX || 0;
        posSrc.clientY = eventSource.clientY || 0;
    }
    var ev;
    var bubbles = true;
    var cancelable = true;
    var ctrlKey = e.ctrlKey, shiftKey = e.shiftKey, altKey = e.altKey, metaKey = e.metaKey;
    var pressedKeysMap = {
        ctrlKey: ctrlKey,
        shiftKey: shiftKey,
        altKey: altKey,
        metaKey: metaKey,
    };
    if (typeof MouseEvent !== 'undefined') {
        try {
            ev = new MouseEvent(event, extend(__assign({ bubbles: bubbles,
                cancelable: cancelable }, pressedKeysMap), posSrc));
        }
        catch (e) {
            /* istanbul ignore next */
            createEvent();
        }
    }
    else {
        createEvent();
    }
    function createEvent() {
        ev = document.createEvent('Event');
        ev.initEvent(event, bubbles, cancelable);
        extend(ev, posSrc);
    }
    // forwardedTouchEvent set to true in case of the conflict with fastclick
    ev.forwardedTouchEvent = true;
    ev._constructed = true;
    e.target.dispatchEvent(ev);
}
function dblclick(e) {
    click(e, 'dblclick');
}

var ease = {
    // easeOutQuint
    swipe: {
        style: 'cubic-bezier(0.23, 1, 0.32, 1)',
        fn: function (t) {
            return 1 + --t * t * t * t * t;
        }
    },
    // easeOutQuard
    swipeBounce: {
        style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
        fn: function (t) {
            return t * (2 - t);
        }
    },
    // easeOutQuart
    bounce: {
        style: 'cubic-bezier(0.165, 0.84, 0.44, 1)',
        fn: function (t) {
            return 1 - --t * t * t * t;
        }
    }
};

var DEFAULT_INTERVAL = 1000 / 60;
var windowCompat = inBrowser && window;
/* istanbul ignore next */
function noop$1() { }
var requestAnimationFrame = (function () {
    /* istanbul ignore if  */
    if (!inBrowser) {
        return noop$1;
    }
    return (windowCompat.requestAnimationFrame ||
        windowCompat.webkitRequestAnimationFrame ||
        windowCompat.mozRequestAnimationFrame ||
        windowCompat.oRequestAnimationFrame ||
        // if all else fails, use setTimeout
        function (callback) {
            return window.setTimeout(callback, callback.interval || DEFAULT_INTERVAL); // make interval as precise as possible.
        });
})();
var cancelAnimationFrame = (function () {
    /* istanbul ignore if  */
    if (!inBrowser) {
        return noop$1;
    }
    return (windowCompat.cancelAnimationFrame ||
        windowCompat.webkitCancelAnimationFrame ||
        windowCompat.mozCancelAnimationFrame ||
        windowCompat.oCancelAnimationFrame ||
        function (id) {
            window.clearTimeout(id);
        });
})();

/* istanbul ignore next */
var noop = function (val) { };
var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop,
};
var getProperty = function (obj, key) {
    var keys = key.split('.');
    for (var i = 0; i < keys.length - 1; i++) {
        obj = obj[keys[i]];
        if (typeof obj !== 'object' || !obj)
            return;
    }
    var lastKey = keys.pop();
    if (typeof obj[lastKey] === 'function') {
        return function () {
            return obj[lastKey].apply(obj, arguments);
        };
    }
    else {
        return obj[lastKey];
    }
};
var setProperty = function (obj, key, value) {
    var keys = key.split('.');
    var temp;
    for (var i = 0; i < keys.length - 1; i++) {
        temp = keys[i];
        if (!obj[temp])
            obj[temp] = {};
        obj = obj[temp];
    }
    obj[keys.pop()] = value;
};
function propertiesProxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
        return getProperty(this, sourceKey);
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
        setProperty(this, sourceKey, val);
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}

var EventEmitter = /** @class */ (function () {
    function EventEmitter(names) {
        this.events = {};
        this.eventTypes = {};
        this.registerType(names);
    }
    EventEmitter.prototype.on = function (type, fn, context) {
        if (context === void 0) { context = this; }
        this.hasType(type);
        if (!this.events[type]) {
            this.events[type] = [];
        }
        this.events[type].push([fn, context]);
        return this;
    };
    EventEmitter.prototype.once = function (type, fn, context) {
        var _this = this;
        if (context === void 0) { context = this; }
        this.hasType(type);
        var magic = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            _this.off(type, magic);
            var ret = fn.apply(context, args);
            if (ret === true) {
                return ret;
            }
        };
        magic.fn = fn;
        this.on(type, magic);
        return this;
    };
    EventEmitter.prototype.off = function (type, fn) {
        if (!type && !fn) {
            this.events = {};
            return this;
        }
        if (type) {
            this.hasType(type);
            if (!fn) {
                this.events[type] = [];
                return this;
            }
            var events = this.events[type];
            if (!events) {
                return this;
            }
            var count = events.length;
            while (count--) {
                if (events[count][0] === fn ||
                    (events[count][0] && events[count][0].fn === fn)) {
                    events.splice(count, 1);
                }
            }
            return this;
        }
    };
    EventEmitter.prototype.trigger = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.hasType(type);
        var events = this.events[type];
        if (!events) {
            return;
        }
        var len = events.length;
        var eventsCopy = __spreadArrays(events);
        var ret;
        for (var i = 0; i < len; i++) {
            var event_1 = eventsCopy[i];
            var fn = event_1[0], context = event_1[1];
            if (fn) {
                ret = fn.apply(context, args);
                if (ret === true) {
                    return ret;
                }
            }
        }
    };
    EventEmitter.prototype.registerType = function (names) {
        var _this = this;
        names.forEach(function (type) {
            _this.eventTypes[type] = type;
        });
    };
    EventEmitter.prototype.destroy = function () {
        this.events = {};
        this.eventTypes = {};
    };
    EventEmitter.prototype.hasType = function (type) {
        var types = this.eventTypes;
        var isType = types[type] === type;
        if (!isType) {
            warn("EventEmitter has used unknown event type: \"" + type + "\", should be oneof [" +
                ("" + Object.keys(types).map(function (_) { return JSON.stringify(_); })) +
                "]");
        }
    };
    return EventEmitter;
}());
var EventRegister = /** @class */ (function () {
    function EventRegister(wrapper, events) {
        this.wrapper = wrapper;
        this.events = events;
        this.addDOMEvents();
    }
    EventRegister.prototype.destroy = function () {
        this.removeDOMEvents();
        this.events = [];
    };
    EventRegister.prototype.addDOMEvents = function () {
        this.handleDOMEvents(addEvent);
    };
    EventRegister.prototype.removeDOMEvents = function () {
        this.handleDOMEvents(removeEvent);
    };
    EventRegister.prototype.handleDOMEvents = function (eventOperation) {
        var _this = this;
        var wrapper = this.wrapper;
        this.events.forEach(function (event) {
            eventOperation(wrapper, event.name, _this, !!event.capture);
        });
    };
    EventRegister.prototype.handleEvent = function (e) {
        var eventType = e.type;
        this.events.some(function (event) {
            if (event.name === eventType) {
                event.handler(e);
                return true;
            }
            return false;
        });
    };
    return EventRegister;
}());

var CustomOptions = /** @class */ (function () {
    function CustomOptions() {
    }
    return CustomOptions;
}());
var OptionsConstructor = /** @class */ (function (_super) {
    __extends(OptionsConstructor, _super);
    function OptionsConstructor() {
        var _this = _super.call(this) || this;
        _this.startX = 0;
        _this.startY = 0;
        _this.scrollX = false;
        _this.scrollY = true;
        _this.freeScroll = false;
        _this.directionLockThreshold = 0;
        _this.eventPassthrough = "" /* None */;
        _this.click = false;
        _this.dblclick = false;
        _this.tap = '';
        _this.bounce = {
            top: true,
            bottom: true,
            left: true,
            right: true,
        };
        _this.bounceTime = 800;
        _this.momentum = true;
        _this.momentumLimitTime = 300;
        _this.momentumLimitDistance = 15;
        _this.swipeTime = 2500;
        _this.swipeBounceTime = 500;
        _this.deceleration = 0.0015;
        _this.flickLimitTime = 200;
        _this.flickLimitDistance = 100;
        _this.resizePolling = 60;
        _this.probeType = 0 /* Default */;
        _this.stopPropagation = false;
        _this.preventDefault = true;
        _this.preventDefaultException = {
            tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|AUDIO)$/,
        };
        _this.tagException = {
            tagName: /^TEXTAREA$/,
        };
        _this.HWCompositing = true;
        _this.useTransition = true;
        _this.bindToWrapper = false;
        _this.bindToTarget = false;
        _this.disableMouse = hasTouch;
        _this.disableTouch = !hasTouch;
        _this.autoBlur = true;
        _this.autoEndDistance = 5;
        _this.outOfBoundaryDampingFactor = 1 / 3;
        _this.specifiedIndexAsContent = 0;
        _this.quadrant = 1 /* First */;
        return _this;
    }
    OptionsConstructor.prototype.merge = function (options) {
        if (!options)
            return this;
        for (var key in options) {
            if (key === 'bounce') {
                this.bounce = this.resolveBounce(options[key]);
                continue;
            }
            this[key] = options[key];
        }
        return this;
    };
    OptionsConstructor.prototype.process = function () {
        this.translateZ =
            this.HWCompositing && hasPerspective ? ' translateZ(1px)' : '';
        this.useTransition = this.useTransition && hasTransition;
        this.preventDefault = !this.eventPassthrough && this.preventDefault;
        // If you want eventPassthrough I have to lock one of the axes
        this.scrollX =
            this.eventPassthrough === "horizontal" /* Horizontal */
                ? false
                : this.scrollX;
        this.scrollY =
            this.eventPassthrough === "vertical" /* Vertical */ ? false : this.scrollY;
        // With eventPassthrough we also need lockDirection mechanism
        this.freeScroll = this.freeScroll && !this.eventPassthrough;
        // force true when freeScroll is true
        this.scrollX = this.freeScroll ? true : this.scrollX;
        this.scrollY = this.freeScroll ? true : this.scrollY;
        this.directionLockThreshold = this.eventPassthrough
            ? 0
            : this.directionLockThreshold;
        return this;
    };
    OptionsConstructor.prototype.resolveBounce = function (bounceOptions) {
        var DEFAULT_BOUNCE = {
            top: true,
            right: true,
            bottom: true,
            left: true,
        };
        var NEGATED_BOUNCE = {
            top: false,
            right: false,
            bottom: false,
            left: false,
        };
        var ret;
        if (typeof bounceOptions === 'object') {
            ret = extend(DEFAULT_BOUNCE, bounceOptions);
        }
        else {
            ret = bounceOptions ? DEFAULT_BOUNCE : NEGATED_BOUNCE;
        }
        return ret;
    };
    return OptionsConstructor;
}(CustomOptions));

var ActionsHandler = /** @class */ (function () {
    function ActionsHandler(wrapper, options) {
        this.wrapper = wrapper;
        this.options = options;
        this.hooks = new EventEmitter([
            'beforeStart',
            'start',
            'move',
            'end',
            'click',
        ]);
        this.handleDOMEvents();
    }
    ActionsHandler.prototype.handleDOMEvents = function () {
        var _a = this.options, bindToWrapper = _a.bindToWrapper, disableMouse = _a.disableMouse, disableTouch = _a.disableTouch, click = _a.click;
        var wrapper = this.wrapper;
        var target = bindToWrapper ? wrapper : window;
        var wrapperEvents = [];
        var targetEvents = [];
        var shouldRegisterTouch = !disableTouch;
        var shouldRegisterMouse = !disableMouse;
        if (click) {
            wrapperEvents.push({
                name: 'click',
                handler: this.click.bind(this),
                capture: true,
            });
        }
        if (shouldRegisterTouch) {
            wrapperEvents.push({
                name: 'touchstart',
                handler: this.start.bind(this),
            });
            targetEvents.push({
                name: 'touchmove',
                handler: this.move.bind(this),
            }, {
                name: 'touchend',
                handler: this.end.bind(this),
            }, {
                name: 'touchcancel',
                handler: this.end.bind(this),
            });
        }
        if (shouldRegisterMouse) {
            wrapperEvents.push({
                name: 'mousedown',
                handler: this.start.bind(this),
            });
            targetEvents.push({
                name: 'mousemove',
                handler: this.move.bind(this),
            }, {
                name: 'mouseup',
                handler: this.end.bind(this),
            });
        }
        this.wrapperEventRegister = new EventRegister(wrapper, wrapperEvents);
        this.targetEventRegister = new EventRegister(target, targetEvents);
    };
    ActionsHandler.prototype.beforeHandler = function (e, type) {
        var _a = this.options, preventDefault = _a.preventDefault, stopPropagation = _a.stopPropagation, preventDefaultException = _a.preventDefaultException;
        var preventDefaultConditions = {
            start: function () {
                return (preventDefault &&
                    !preventDefaultExceptionFn(e.target, preventDefaultException));
            },
            end: function () {
                return (preventDefault &&
                    !preventDefaultExceptionFn(e.target, preventDefaultException));
            },
            move: function () {
                return preventDefault;
            },
        };
        if (preventDefaultConditions[type]()) {
            e.preventDefault();
        }
        if (stopPropagation) {
            e.stopPropagation();
        }
    };
    ActionsHandler.prototype.setInitiated = function (type) {
        if (type === void 0) { type = 0; }
        this.initiated = type;
    };
    ActionsHandler.prototype.start = function (e) {
        var _eventType = eventTypeMap[e.type];
        if (this.initiated && this.initiated !== _eventType) {
            return;
        }
        this.setInitiated(_eventType);
        // if textarea or other html tags in options.tagException is manipulated
        // do not make bs scroll
        if (tagExceptionFn(e.target, this.options.tagException)) {
            this.setInitiated();
            return;
        }
        // only allow mouse left button
        if (_eventType === 2 /* Mouse */ && e.button !== 0 /* Left */)
            return;
        if (this.hooks.trigger(this.hooks.eventTypes.beforeStart, e)) {
            return;
        }
        this.beforeHandler(e, 'start');
        var point = (e.touches ? e.touches[0] : e);
        this.pointX = point.pageX;
        this.pointY = point.pageY;
        this.hooks.trigger(this.hooks.eventTypes.start, e);
    };
    ActionsHandler.prototype.move = function (e) {
        if (eventTypeMap[e.type] !== this.initiated) {
            return;
        }
        this.beforeHandler(e, 'move');
        var point = (e.touches ? e.touches[0] : e);
        var deltaX = point.pageX - this.pointX;
        var deltaY = point.pageY - this.pointY;
        this.pointX = point.pageX;
        this.pointY = point.pageY;
        if (this.hooks.trigger(this.hooks.eventTypes.move, {
            deltaX: deltaX,
            deltaY: deltaY,
            e: e,
        })) {
            return;
        }
        // auto end when out of viewport
        var scrollLeft = document.documentElement.scrollLeft ||
            window.pageXOffset ||
            document.body.scrollLeft;
        var scrollTop = document.documentElement.scrollTop ||
            window.pageYOffset ||
            document.body.scrollTop;
        var pX = this.pointX - scrollLeft;
        var pY = this.pointY - scrollTop;
        var autoEndDistance = this.options.autoEndDistance;
        if (pX > document.documentElement.clientWidth - autoEndDistance ||
            pY > document.documentElement.clientHeight - autoEndDistance ||
            pX < autoEndDistance ||
            pY < autoEndDistance) {
            this.end(e);
        }
    };
    ActionsHandler.prototype.end = function (e) {
        if (eventTypeMap[e.type] !== this.initiated) {
            return;
        }
        this.setInitiated();
        this.beforeHandler(e, 'end');
        this.hooks.trigger(this.hooks.eventTypes.end, e);
    };
    ActionsHandler.prototype.click = function (e) {
        this.hooks.trigger(this.hooks.eventTypes.click, e);
    };
    ActionsHandler.prototype.setContent = function (content) {
        if (content !== this.wrapper) {
            this.wrapper = content;
            this.rebindDOMEvents();
        }
    };
    ActionsHandler.prototype.rebindDOMEvents = function () {
        this.wrapperEventRegister.destroy();
        this.targetEventRegister.destroy();
        this.handleDOMEvents();
    };
    ActionsHandler.prototype.destroy = function () {
        this.wrapperEventRegister.destroy();
        this.targetEventRegister.destroy();
        this.hooks.destroy();
    };
    return ActionsHandler;
}());

var translaterMetaData = {
    x: ['translateX', 'px'],
    y: ['translateY', 'px'],
};
var Translater = /** @class */ (function () {
    function Translater(content) {
        this.setContent(content);
        this.hooks = new EventEmitter(['beforeTranslate', 'translate']);
    }
    Translater.prototype.getComputedPosition = function () {
        var cssStyle = window.getComputedStyle(this.content, null);
        var matrix = cssStyle[style.transform].split(')')[0].split(', ');
        var x = +(matrix[12] || matrix[4]) || 0;
        var y = +(matrix[13] || matrix[5]) || 0;
        return {
            x: x,
            y: y,
        };
    };
    Translater.prototype.translate = function (point) {
        var transformStyle = [];
        Object.keys(point).forEach(function (key) {
            if (!translaterMetaData[key]) {
                return;
            }
            var transformFnName = translaterMetaData[key][0];
            if (transformFnName) {
                var transformFnArgUnit = translaterMetaData[key][1];
                var transformFnArg = point[key];
                transformStyle.push(transformFnName + "(" + transformFnArg + transformFnArgUnit + ")");
            }
        });
        this.hooks.trigger(this.hooks.eventTypes.beforeTranslate, transformStyle, point);
        this.style[style.transform] = transformStyle.join(' ');
        this.hooks.trigger(this.hooks.eventTypes.translate, point);
    };
    Translater.prototype.setContent = function (content) {
        if (this.content !== content) {
            this.content = content;
            this.style = content.style;
        }
    };
    Translater.prototype.destroy = function () {
        this.hooks.destroy();
    };
    return Translater;
}());

var Base = /** @class */ (function () {
    function Base(content, translater, options) {
        this.translater = translater;
        this.options = options;
        this.timer = 0;
        this.hooks = new EventEmitter([
            'move',
            'end',
            'beforeForceStop',
            'forceStop',
            'callStop',
            'time',
            'timeFunction',
        ]);
        this.setContent(content);
    }
    Base.prototype.translate = function (endPoint) {
        this.translater.translate(endPoint);
    };
    Base.prototype.setPending = function (pending) {
        this.pending = pending;
    };
    Base.prototype.setForceStopped = function (forceStopped) {
        this.forceStopped = forceStopped;
    };
    Base.prototype.setCallStop = function (called) {
        this.callStopWhenPending = called;
    };
    Base.prototype.setContent = function (content) {
        if (this.content !== content) {
            this.content = content;
            this.style = content.style;
            this.stop();
        }
    };
    Base.prototype.clearTimer = function () {
        if (this.timer) {
            cancelAnimationFrame(this.timer);
            this.timer = 0;
        }
    };
    Base.prototype.destroy = function () {
        this.hooks.destroy();
        cancelAnimationFrame(this.timer);
    };
    return Base;
}());

// iOS 13.6 - 14.x, window.getComputedStyle sometimes will get wrong transform value
// when bs use transition mode
// eg: translateY -100px -> -200px, when the last frame which is about to scroll to -200px
// window.getComputedStyle(this.content) will calculate transformY to be -100px(startPoint)
// it is weird
// so we should validate position caculated by 'window.getComputedStyle'
var isValidPostion = function (startPoint, endPoint, currentPos, prePos) {
    var computeDirection = function (endValue, startValue) {
        var delta = endValue - startValue;
        var direction = delta > 0
            ? -1 /* Negative */
            : delta < 0
                ? 1 /* Positive */
                : 0 /* Default */;
        return direction;
    };
    var directionX = computeDirection(endPoint.x, startPoint.x);
    var directionY = computeDirection(endPoint.y, startPoint.y);
    var deltaX = currentPos.x - prePos.x;
    var deltaY = currentPos.y - prePos.y;
    return directionX * deltaX <= 0 && directionY * deltaY <= 0;
};

var Transition = /** @class */ (function (_super) {
    __extends(Transition, _super);
    function Transition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Transition.prototype.startProbe = function (startPoint, endPoint) {
        var _this = this;
        var prePos = startPoint;
        var probe = function () {
            var pos = _this.translater.getComputedPosition();
            if (isValidPostion(startPoint, endPoint, pos, prePos)) {
                _this.hooks.trigger(_this.hooks.eventTypes.move, pos);
            }
            // call bs.stop() should not dispatch end hook again.
            // forceStop hook will do this.
            /* istanbul ignore if  */
            if (!_this.pending) {
                if (_this.callStopWhenPending) {
                    _this.callStopWhenPending = false;
                }
                else {
                    // transition ends should dispatch end hook.
                    _this.hooks.trigger(_this.hooks.eventTypes.end, pos);
                }
            }
            prePos = pos;
            if (_this.pending) {
                _this.timer = requestAnimationFrame(probe);
            }
        };
        // when manually call bs.stop(), then bs.scrollTo()
        // we should reset callStopWhenPending to dispatch end hook
        if (this.callStopWhenPending) {
            this.setCallStop(false);
        }
        cancelAnimationFrame(this.timer);
        probe();
    };
    Transition.prototype.transitionTime = function (time) {
        if (time === void 0) { time = 0; }
        this.style[style.transitionDuration] = time + 'ms';
        this.hooks.trigger(this.hooks.eventTypes.time, time);
    };
    Transition.prototype.transitionTimingFunction = function (easing) {
        this.style[style.transitionTimingFunction] = easing;
        this.hooks.trigger(this.hooks.eventTypes.timeFunction, easing);
    };
    Transition.prototype.transitionProperty = function () {
        this.style[style.transitionProperty] = style.transform;
    };
    Transition.prototype.move = function (startPoint, endPoint, time, easingFn) {
        this.setPending(time > 0);
        this.transitionTimingFunction(easingFn);
        this.transitionProperty();
        this.transitionTime(time);
        this.translate(endPoint);
        var isRealtimeProbeType = this.options.probeType === 3 /* Realtime */;
        if (time && isRealtimeProbeType) {
            this.startProbe(startPoint, endPoint);
        }
        // if we change content's transformY in a tick
        // such as: 0 -> 50px -> 0
        // transitionend will not be triggered
        // so we forceupdate by reflow
        if (!time) {
            this._reflow = this.content.offsetHeight;
            if (isRealtimeProbeType) {
                this.hooks.trigger(this.hooks.eventTypes.move, endPoint);
            }
            this.hooks.trigger(this.hooks.eventTypes.end, endPoint);
        }
    };
    Transition.prototype.doStop = function () {
        var pending = this.pending;
        this.setForceStopped(false);
        this.setCallStop(false);
        // still in transition
        if (pending) {
            this.setPending(false);
            cancelAnimationFrame(this.timer);
            var _a = this.translater.getComputedPosition(), x = _a.x, y = _a.y;
            this.transitionTime();
            this.translate({ x: x, y: y });
            this.setForceStopped(true);
            this.setCallStop(true);
            this.hooks.trigger(this.hooks.eventTypes.forceStop, { x: x, y: y });
        }
        return pending;
    };
    Transition.prototype.stop = function () {
        var stopFromTransition = this.doStop();
        if (stopFromTransition) {
            this.hooks.trigger(this.hooks.eventTypes.callStop);
        }
    };
    return Transition;
}(Base));

var Animation = /** @class */ (function (_super) {
    __extends(Animation, _super);
    function Animation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Animation.prototype.move = function (startPoint, endPoint, time, easingFn) {
        // time is 0
        if (!time) {
            this.translate(endPoint);
            if (this.options.probeType === 3 /* Realtime */) {
                this.hooks.trigger(this.hooks.eventTypes.move, endPoint);
            }
            this.hooks.trigger(this.hooks.eventTypes.end, endPoint);
            return;
        }
        this.animate(startPoint, endPoint, time, easingFn);
    };
    Animation.prototype.animate = function (startPoint, endPoint, duration, easingFn) {
        var _this = this;
        var startTime = getNow();
        var destTime = startTime + duration;
        var isRealtimeProbeType = this.options.probeType === 3 /* Realtime */;
        var step = function () {
            var now = getNow();
            // js animation end
            if (now >= destTime) {
                _this.translate(endPoint);
                if (isRealtimeProbeType) {
                    _this.hooks.trigger(_this.hooks.eventTypes.move, endPoint);
                }
                _this.hooks.trigger(_this.hooks.eventTypes.end, endPoint);
                return;
            }
            now = (now - startTime) / duration;
            var easing = easingFn(now);
            var newPoint = {};
            Object.keys(endPoint).forEach(function (key) {
                var startValue = startPoint[key];
                var endValue = endPoint[key];
                newPoint[key] = (endValue - startValue) * easing + startValue;
            });
            _this.translate(newPoint);
            if (isRealtimeProbeType) {
                _this.hooks.trigger(_this.hooks.eventTypes.move, newPoint);
            }
            if (_this.pending) {
                _this.timer = requestAnimationFrame(step);
            }
            // call bs.stop() should not dispatch end hook again.
            // forceStop hook will do this.
            /* istanbul ignore if  */
            if (!_this.pending) {
                if (_this.callStopWhenPending) {
                    _this.callStopWhenPending = false;
                }
                else {
                    // raf ends should dispatch end hook.
                    _this.hooks.trigger(_this.hooks.eventTypes.end, endPoint);
                }
            }
        };
        this.setPending(true);
        // when manually call bs.stop(), then bs.scrollTo()
        // we should reset callStopWhenPending to dispatch end hook
        if (this.callStopWhenPending) {
            this.setCallStop(false);
        }
        cancelAnimationFrame(this.timer);
        step();
    };
    Animation.prototype.doStop = function () {
        var pending = this.pending;
        this.setForceStopped(false);
        this.setCallStop(false);
        // still in requestFrameAnimation
        if (pending) {
            this.setPending(false);
            cancelAnimationFrame(this.timer);
            var pos = this.translater.getComputedPosition();
            this.setForceStopped(true);
            this.setCallStop(true);
            this.hooks.trigger(this.hooks.eventTypes.forceStop, pos);
        }
        return pending;
    };
    Animation.prototype.stop = function () {
        var stopFromAnimation = this.doStop();
        if (stopFromAnimation) {
            this.hooks.trigger(this.hooks.eventTypes.callStop);
        }
    };
    return Animation;
}(Base));

function createAnimater(element, translater, options) {
    var useTransition = options.useTransition;
    var animaterOptions = {};
    Object.defineProperty(animaterOptions, 'probeType', {
        enumerable: true,
        configurable: false,
        get: function () {
            return options.probeType;
        },
    });
    if (useTransition) {
        return new Transition(element, translater, animaterOptions);
    }
    else {
        return new Animation(element, translater, animaterOptions);
    }
}

var Behavior = /** @class */ (function () {
    function Behavior(wrapper, content, options) {
        this.wrapper = wrapper;
        this.options = options;
        this.hooks = new EventEmitter([
            'beforeComputeBoundary',
            'computeBoundary',
            'momentum',
            'end',
            'ignoreHasScroll'
        ]);
        this.refresh(content);
    }
    Behavior.prototype.start = function () {
        this.dist = 0;
        this.setMovingDirection(0 /* Default */);
        this.setDirection(0 /* Default */);
    };
    Behavior.prototype.move = function (delta) {
        delta = this.hasScroll ? delta : 0;
        this.setMovingDirection(delta);
        return this.performDampingAlgorithm(delta, this.options.outOfBoundaryDampingFactor);
    };
    Behavior.prototype.setMovingDirection = function (delta) {
        this.movingDirection =
            delta > 0
                ? -1 /* Negative */
                : delta < 0
                    ? 1 /* Positive */
                    : 0 /* Default */;
    };
    Behavior.prototype.setDirection = function (delta) {
        this.direction =
            delta > 0
                ? -1 /* Negative */
                : delta < 0
                    ? 1 /* Positive */
                    : 0 /* Default */;
    };
    Behavior.prototype.performDampingAlgorithm = function (delta, dampingFactor) {
        var newPos = this.currentPos + delta;
        // Slow down or stop if outside of the boundaries
        if (newPos > this.minScrollPos || newPos < this.maxScrollPos) {
            if ((newPos > this.minScrollPos && this.options.bounces[0]) ||
                (newPos < this.maxScrollPos && this.options.bounces[1])) {
                newPos = this.currentPos + delta * dampingFactor;
            }
            else {
                newPos =
                    newPos > this.minScrollPos ? this.minScrollPos : this.maxScrollPos;
            }
        }
        return newPos;
    };
    Behavior.prototype.end = function (duration) {
        var momentumInfo = {
            duration: 0
        };
        var absDist = Math.abs(this.currentPos - this.startPos);
        // start momentum animation if needed
        if (this.options.momentum &&
            duration < this.options.momentumLimitTime &&
            absDist > this.options.momentumLimitDistance) {
            var wrapperSize = (this.direction === -1 /* Negative */ && this.options.bounces[0]) ||
                (this.direction === 1 /* Positive */ && this.options.bounces[1])
                ? this.wrapperSize
                : 0;
            momentumInfo = this.hasScroll
                ? this.momentum(this.currentPos, this.startPos, duration, this.maxScrollPos, this.minScrollPos, wrapperSize, this.options)
                : { destination: this.currentPos, duration: 0 };
        }
        else {
            this.hooks.trigger(this.hooks.eventTypes.end, momentumInfo);
        }
        return momentumInfo;
    };
    Behavior.prototype.momentum = function (current, start, time, lowerMargin, upperMargin, wrapperSize, options) {
        if (options === void 0) { options = this.options; }
        var distance = current - start;
        var speed = Math.abs(distance) / time;
        var deceleration = options.deceleration, swipeBounceTime = options.swipeBounceTime, swipeTime = options.swipeTime;
        var duration = Math.min(swipeTime, (speed * 2) / deceleration);
        var momentumData = {
            destination: current + ((speed * speed) / deceleration) * (distance < 0 ? -1 : 1),
            duration: duration,
            rate: 15
        };
        this.hooks.trigger(this.hooks.eventTypes.momentum, momentumData, distance);
        if (momentumData.destination < lowerMargin) {
            momentumData.destination = wrapperSize
                ? Math.max(lowerMargin - wrapperSize / 4, lowerMargin - (wrapperSize / momentumData.rate) * speed)
                : lowerMargin;
            momentumData.duration = swipeBounceTime;
        }
        else if (momentumData.destination > upperMargin) {
            momentumData.destination = wrapperSize
                ? Math.min(upperMargin + wrapperSize / 4, upperMargin + (wrapperSize / momentumData.rate) * speed)
                : upperMargin;
            momentumData.duration = swipeBounceTime;
        }
        momentumData.destination = Math.round(momentumData.destination);
        return momentumData;
    };
    Behavior.prototype.updateDirection = function () {
        var absDist = this.currentPos - this.absStartPos;
        this.setDirection(absDist);
    };
    Behavior.prototype.refresh = function (content) {
        var _a = this.options.rect, size = _a.size, position = _a.position;
        var isWrapperStatic = window.getComputedStyle(this.wrapper, null).position === 'static';
        // Force reflow
        var wrapperRect = getRect(this.wrapper);
        // use client is more fair than offset
        this.wrapperSize = this.wrapper[size === 'width' ? 'clientWidth' : 'clientHeight'];
        this.setContent(content);
        var contentRect = getRect(this.content);
        this.contentSize = contentRect[size];
        this.relativeOffset = contentRect[position];
        /* istanbul ignore if  */
        if (isWrapperStatic) {
            this.relativeOffset -= wrapperRect[position];
        }
        this.computeBoundary();
        this.setDirection(0 /* Default */);
    };
    Behavior.prototype.setContent = function (content) {
        if (content !== this.content) {
            this.content = content;
            this.resetState();
        }
    };
    Behavior.prototype.resetState = function () {
        this.currentPos = 0;
        this.startPos = 0;
        this.dist = 0;
        this.setDirection(0 /* Default */);
        this.setMovingDirection(0 /* Default */);
        this.resetStartPos();
    };
    Behavior.prototype.computeBoundary = function () {
        this.hooks.trigger(this.hooks.eventTypes.beforeComputeBoundary);
        var boundary = {
            minScrollPos: 0,
            maxScrollPos: this.wrapperSize - this.contentSize
        };
        if (boundary.maxScrollPos < 0) {
            boundary.maxScrollPos -= this.relativeOffset;
            if (this.options.specifiedIndexAsContent === 0) {
                boundary.minScrollPos = -this.relativeOffset;
            }
        }
        this.hooks.trigger(this.hooks.eventTypes.computeBoundary, boundary);
        this.minScrollPos = boundary.minScrollPos;
        this.maxScrollPos = boundary.maxScrollPos;
        this.hasScroll =
            this.options.scrollable && this.maxScrollPos < this.minScrollPos;
        if (!this.hasScroll && this.minScrollPos < this.maxScrollPos) {
            this.maxScrollPos = this.minScrollPos;
            this.contentSize = this.wrapperSize;
        }
    };
    Behavior.prototype.updatePosition = function (pos) {
        this.currentPos = pos;
    };
    Behavior.prototype.getCurrentPos = function () {
        return this.currentPos;
    };
    Behavior.prototype.checkInBoundary = function () {
        var position = this.adjustPosition(this.currentPos);
        var inBoundary = position === this.getCurrentPos();
        return {
            position: position,
            inBoundary: inBoundary
        };
    };
    // adjust position when out of boundary
    Behavior.prototype.adjustPosition = function (pos) {
        if (!this.hasScroll &&
            !this.hooks.trigger(this.hooks.eventTypes.ignoreHasScroll)) {
            pos = this.minScrollPos;
        }
        else if (pos > this.minScrollPos) {
            pos = this.minScrollPos;
        }
        else if (pos < this.maxScrollPos) {
            pos = this.maxScrollPos;
        }
        return pos;
    };
    Behavior.prototype.updateStartPos = function () {
        this.startPos = this.currentPos;
    };
    Behavior.prototype.updateAbsStartPos = function () {
        this.absStartPos = this.currentPos;
    };
    Behavior.prototype.resetStartPos = function () {
        this.updateStartPos();
        this.updateAbsStartPos();
    };
    Behavior.prototype.getAbsDist = function (delta) {
        this.dist += delta;
        return Math.abs(this.dist);
    };
    Behavior.prototype.destroy = function () {
        this.hooks.destroy();
    };
    return Behavior;
}());

var _a, _b, _c, _d;
var PassthroughHandlers = (_a = {},
    _a["yes" /* Yes */] = function (e) {
        return true;
    },
    _a["no" /* No */] = function (e) {
        maybePrevent(e);
        return false;
    },
    _a);
var DirectionMap = (_b = {},
    _b["horizontal" /* Horizontal */] = (_c = {},
        _c["yes" /* Yes */] = "horizontal" /* Horizontal */,
        _c["no" /* No */] = "vertical" /* Vertical */,
        _c),
    _b["vertical" /* Vertical */] = (_d = {},
        _d["yes" /* Yes */] = "vertical" /* Vertical */,
        _d["no" /* No */] = "horizontal" /* Horizontal */,
        _d),
    _b);
var DirectionLockAction = /** @class */ (function () {
    function DirectionLockAction(directionLockThreshold, freeScroll, eventPassthrough) {
        this.directionLockThreshold = directionLockThreshold;
        this.freeScroll = freeScroll;
        this.eventPassthrough = eventPassthrough;
        this.reset();
    }
    DirectionLockAction.prototype.reset = function () {
        this.directionLocked = "" /* Default */;
    };
    DirectionLockAction.prototype.checkMovingDirection = function (absDistX, absDistY, e) {
        this.computeDirectionLock(absDistX, absDistY);
        return this.handleEventPassthrough(e);
    };
    DirectionLockAction.prototype.adjustDelta = function (deltaX, deltaY) {
        if (this.directionLocked === "horizontal" /* Horizontal */) {
            deltaY = 0;
        }
        else if (this.directionLocked === "vertical" /* Vertical */) {
            deltaX = 0;
        }
        return {
            deltaX: deltaX,
            deltaY: deltaY,
        };
    };
    DirectionLockAction.prototype.computeDirectionLock = function (absDistX, absDistY) {
        // If you are scrolling in one direction, lock it
        if (this.directionLocked === "" /* Default */ && !this.freeScroll) {
            if (absDistX > absDistY + this.directionLockThreshold) {
                this.directionLocked = "horizontal" /* Horizontal */; // lock horizontally
            }
            else if (absDistY >= absDistX + this.directionLockThreshold) {
                this.directionLocked = "vertical" /* Vertical */; // lock vertically
            }
            else {
                this.directionLocked = "none" /* None */; // no lock
            }
        }
    };
    DirectionLockAction.prototype.handleEventPassthrough = function (e) {
        var handleMap = DirectionMap[this.directionLocked];
        if (handleMap) {
            if (this.eventPassthrough === handleMap["yes" /* Yes */]) {
                return PassthroughHandlers["yes" /* Yes */](e);
            }
            else if (this.eventPassthrough === handleMap["no" /* No */]) {
                return PassthroughHandlers["no" /* No */](e);
            }
        }
        return false;
    };
    return DirectionLockAction;
}());

var applyQuadrantTransformation = function (deltaX, deltaY, quadrant) {
    if (quadrant === 2 /* Second */) {
        return [deltaY, -deltaX];
    }
    else if (quadrant === 3 /* Third */) {
        return [-deltaX, -deltaY];
    }
    else if (quadrant === 4 /* Forth */) {
        return [-deltaY, deltaX];
    }
    else {
        return [deltaX, deltaY];
    }
};
var ScrollerActions = /** @class */ (function () {
    function ScrollerActions(scrollBehaviorX, scrollBehaviorY, actionsHandler, animater, options) {
        this.hooks = new EventEmitter([
            'start',
            'beforeMove',
            'scrollStart',
            'scroll',
            'beforeEnd',
            'end',
            'scrollEnd',
            'contentNotMoved',
            'detectMovingDirection',
            'coordinateTransformation',
        ]);
        this.scrollBehaviorX = scrollBehaviorX;
        this.scrollBehaviorY = scrollBehaviorY;
        this.actionsHandler = actionsHandler;
        this.animater = animater;
        this.options = options;
        this.directionLockAction = new DirectionLockAction(options.directionLockThreshold, options.freeScroll, options.eventPassthrough);
        this.enabled = true;
        this.bindActionsHandler();
    }
    ScrollerActions.prototype.bindActionsHandler = function () {
        var _this = this;
        // [mouse|touch]start event
        this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.start, function (e) {
            if (!_this.enabled)
                return true;
            return _this.handleStart(e);
        });
        // [mouse|touch]move event
        this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.move, function (_a) {
            var deltaX = _a.deltaX, deltaY = _a.deltaY, e = _a.e;
            if (!_this.enabled)
                return true;
            var _b = applyQuadrantTransformation(deltaX, deltaY, _this.options.quadrant), transformateDeltaX = _b[0], transformateDeltaY = _b[1];
            var transformateDeltaData = {
                deltaX: transformateDeltaX,
                deltaY: transformateDeltaY,
            };
            _this.hooks.trigger(_this.hooks.eventTypes.coordinateTransformation, transformateDeltaData);
            return _this.handleMove(transformateDeltaData.deltaX, transformateDeltaData.deltaY, e);
        });
        // [mouse|touch]end event
        this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.end, function (e) {
            if (!_this.enabled)
                return true;
            return _this.handleEnd(e);
        });
        // click
        this.actionsHandler.hooks.on(this.actionsHandler.hooks.eventTypes.click, function (e) {
            // handle native click event
            if (_this.enabled && !e._constructed) {
                _this.handleClick(e);
            }
        });
    };
    ScrollerActions.prototype.handleStart = function (e) {
        var timestamp = getNow();
        this.fingerMoved = false;
        this.contentMoved = false;
        this.startTime = timestamp;
        this.directionLockAction.reset();
        this.scrollBehaviorX.start();
        this.scrollBehaviorY.start();
        // force stopping last transition or animation
        this.animater.doStop();
        this.scrollBehaviorX.resetStartPos();
        this.scrollBehaviorY.resetStartPos();
        this.hooks.trigger(this.hooks.eventTypes.start, e);
    };
    ScrollerActions.prototype.handleMove = function (deltaX, deltaY, e) {
        if (this.hooks.trigger(this.hooks.eventTypes.beforeMove, e)) {
            return;
        }
        var absDistX = this.scrollBehaviorX.getAbsDist(deltaX);
        var absDistY = this.scrollBehaviorY.getAbsDist(deltaY);
        var timestamp = getNow();
        // We need to move at least momentumLimitDistance pixels
        // for the scrolling to initiate
        if (this.checkMomentum(absDistX, absDistY, timestamp)) {
            return true;
        }
        if (this.directionLockAction.checkMovingDirection(absDistX, absDistY, e)) {
            this.actionsHandler.setInitiated();
            return true;
        }
        var delta = this.directionLockAction.adjustDelta(deltaX, deltaY);
        var prevX = this.scrollBehaviorX.getCurrentPos();
        var newX = this.scrollBehaviorX.move(delta.deltaX);
        var prevY = this.scrollBehaviorY.getCurrentPos();
        var newY = this.scrollBehaviorY.move(delta.deltaY);
        if (this.hooks.trigger(this.hooks.eventTypes.detectMovingDirection)) {
            return;
        }
        if (!this.fingerMoved) {
            this.fingerMoved = true;
        }
        var positionChanged = newX !== prevX || newY !== prevY;
        if (!this.contentMoved && !positionChanged) {
            this.hooks.trigger(this.hooks.eventTypes.contentNotMoved);
        }
        if (!this.contentMoved && positionChanged) {
            this.contentMoved = true;
            this.hooks.trigger(this.hooks.eventTypes.scrollStart);
        }
        if (this.contentMoved && positionChanged) {
            this.animater.translate({
                x: newX,
                y: newY,
            });
            this.dispatchScroll(timestamp);
        }
    };
    ScrollerActions.prototype.dispatchScroll = function (timestamp) {
        // dispatch scroll in interval time
        if (timestamp - this.startTime > this.options.momentumLimitTime) {
            // refresh time and starting position to initiate a momentum
            this.startTime = timestamp;
            this.scrollBehaviorX.updateStartPos();
            this.scrollBehaviorY.updateStartPos();
            if (this.options.probeType === 1 /* Throttle */) {
                this.hooks.trigger(this.hooks.eventTypes.scroll, this.getCurrentPos());
            }
        }
        // dispatch scroll all the time
        if (this.options.probeType > 1 /* Throttle */) {
            this.hooks.trigger(this.hooks.eventTypes.scroll, this.getCurrentPos());
        }
    };
    ScrollerActions.prototype.checkMomentum = function (absDistX, absDistY, timestamp) {
        return (timestamp - this.endTime > this.options.momentumLimitTime &&
            absDistY < this.options.momentumLimitDistance &&
            absDistX < this.options.momentumLimitDistance);
    };
    ScrollerActions.prototype.handleEnd = function (e) {
        if (this.hooks.trigger(this.hooks.eventTypes.beforeEnd, e)) {
            return;
        }
        var currentPos = this.getCurrentPos();
        this.scrollBehaviorX.updateDirection();
        this.scrollBehaviorY.updateDirection();
        if (this.hooks.trigger(this.hooks.eventTypes.end, e, currentPos)) {
            return true;
        }
        currentPos = this.ensureIntegerPos(currentPos);
        this.animater.translate(currentPos);
        this.endTime = getNow();
        var duration = this.endTime - this.startTime;
        this.hooks.trigger(this.hooks.eventTypes.scrollEnd, currentPos, duration);
    };
    ScrollerActions.prototype.ensureIntegerPos = function (currentPos) {
        this.ensuringInteger = true;
        var x = currentPos.x, y = currentPos.y;
        var _a = this.scrollBehaviorX, minScrollPosX = _a.minScrollPos, maxScrollPosX = _a.maxScrollPos;
        var _b = this.scrollBehaviorY, minScrollPosY = _b.minScrollPos, maxScrollPosY = _b.maxScrollPos;
        x = x > 0 ? Math.ceil(x) : Math.floor(x);
        y = y > 0 ? Math.ceil(y) : Math.floor(y);
        x = between(x, maxScrollPosX, minScrollPosX);
        y = between(y, maxScrollPosY, minScrollPosY);
        return { x: x, y: y };
    };
    ScrollerActions.prototype.handleClick = function (e) {
        if (!preventDefaultExceptionFn(e.target, this.options.preventDefaultException)) {
            maybePrevent(e);
            e.stopPropagation();
        }
    };
    ScrollerActions.prototype.getCurrentPos = function () {
        return {
            x: this.scrollBehaviorX.getCurrentPos(),
            y: this.scrollBehaviorY.getCurrentPos(),
        };
    };
    ScrollerActions.prototype.refresh = function () {
        this.endTime = 0;
    };
    ScrollerActions.prototype.destroy = function () {
        this.hooks.destroy();
    };
    return ScrollerActions;
}());

function createActionsHandlerOptions(bsOptions) {
    var options = [
        'click',
        'bindToWrapper',
        'disableMouse',
        'disableTouch',
        'preventDefault',
        'stopPropagation',
        'tagException',
        'preventDefaultException',
        'autoEndDistance',
    ].reduce(function (prev, cur) {
        prev[cur] = bsOptions[cur];
        return prev;
    }, {});
    return options;
}
function createBehaviorOptions(bsOptions, extraProp, bounces, rect) {
    var options = [
        'momentum',
        'momentumLimitTime',
        'momentumLimitDistance',
        'deceleration',
        'swipeBounceTime',
        'swipeTime',
        'outOfBoundaryDampingFactor',
        'specifiedIndexAsContent',
    ].reduce(function (prev, cur) {
        prev[cur] = bsOptions[cur];
        return prev;
    }, {});
    // add extra property
    options.scrollable = !!bsOptions[extraProp];
    options.bounces = bounces;
    options.rect = rect;
    return options;
}

function bubbling(source, target, events) {
    events.forEach(function (event) {
        var sourceEvent;
        var targetEvent;
        if (typeof event === 'string') {
            sourceEvent = targetEvent = event;
        }
        else {
            sourceEvent = event.source;
            targetEvent = event.target;
        }
        source.on(sourceEvent, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return target.trigger.apply(target, __spreadArrays([targetEvent], args));
        });
    });
}

function isSamePoint(startPoint, endPoint) {
    // keys of startPoint and endPoint should be equal
    var keys = Object.keys(startPoint);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (startPoint[key] !== endPoint[key])
            return false;
    }
    return true;
}

var MIN_SCROLL_DISTANCE = 1;
var Scroller = /** @class */ (function () {
    function Scroller(wrapper, content, options) {
        this.wrapper = wrapper;
        this.content = content;
        this.resizeTimeout = 0;
        this.hooks = new EventEmitter([
            'beforeStart',
            'beforeMove',
            'beforeScrollStart',
            'scrollStart',
            'scroll',
            'beforeEnd',
            'scrollEnd',
            'resize',
            'touchEnd',
            'end',
            'flick',
            'scrollCancel',
            'momentum',
            'scrollTo',
            'minDistanceScroll',
            'scrollToElement',
            'beforeRefresh',
        ]);
        this.options = options;
        var _a = this.options.bounce, left = _a.left, right = _a.right, top = _a.top, bottom = _a.bottom;
        // direction X
        this.scrollBehaviorX = new Behavior(wrapper, content, createBehaviorOptions(options, 'scrollX', [left, right], {
            size: 'width',
            position: 'left',
        }));
        // direction Y
        this.scrollBehaviorY = new Behavior(wrapper, content, createBehaviorOptions(options, 'scrollY', [top, bottom], {
            size: 'height',
            position: 'top',
        }));
        this.translater = new Translater(this.content);
        this.animater = createAnimater(this.content, this.translater, this.options);
        this.actionsHandler = new ActionsHandler(this.options.bindToTarget ? this.content : wrapper, createActionsHandlerOptions(this.options));
        this.actions = new ScrollerActions(this.scrollBehaviorX, this.scrollBehaviorY, this.actionsHandler, this.animater, this.options);
        var resizeHandler = this.resize.bind(this);
        this.resizeRegister = new EventRegister(window, [
            {
                name: 'orientationchange',
                handler: resizeHandler,
            },
            {
                name: 'resize',
                handler: resizeHandler,
            },
        ]);
        this.registerTransitionEnd();
        this.init();
    }
    Scroller.prototype.init = function () {
        var _this = this;
        this.bindTranslater();
        this.bindAnimater();
        this.bindActions();
        // enable pointer events when scrolling ends
        this.hooks.on(this.hooks.eventTypes.scrollEnd, function () {
            _this.togglePointerEvents(true);
        });
    };
    Scroller.prototype.registerTransitionEnd = function () {
        this.transitionEndRegister = new EventRegister(this.content, [
            {
                name: style.transitionEnd,
                handler: this.transitionEnd.bind(this),
            },
        ]);
    };
    Scroller.prototype.bindTranslater = function () {
        var _this = this;
        var hooks = this.translater.hooks;
        hooks.on(hooks.eventTypes.beforeTranslate, function (transformStyle) {
            if (_this.options.translateZ) {
                transformStyle.push(_this.options.translateZ);
            }
        });
        // disable pointer events when scrolling
        hooks.on(hooks.eventTypes.translate, function (pos) {
            var prevPos = _this.getCurrentPos();
            _this.updatePositions(pos);
            // scrollEnd will dispatch when scroll is force stopping in touchstart handler
            // so in touchend handler, don't toggle pointer-events
            if (_this.actions.ensuringInteger === true) {
                _this.actions.ensuringInteger = false;
                return;
            }
            // a valid translate
            if (pos.x !== prevPos.x || pos.y !== prevPos.y) {
                _this.togglePointerEvents(false);
            }
        });
    };
    Scroller.prototype.bindAnimater = function () {
        var _this = this;
        // reset position
        this.animater.hooks.on(this.animater.hooks.eventTypes.end, function (pos) {
            if (!_this.resetPosition(_this.options.bounceTime)) {
                _this.animater.setPending(false);
                _this.hooks.trigger(_this.hooks.eventTypes.scrollEnd, pos);
            }
        });
        bubbling(this.animater.hooks, this.hooks, [
            {
                source: this.animater.hooks.eventTypes.move,
                target: this.hooks.eventTypes.scroll,
            },
            {
                source: this.animater.hooks.eventTypes.forceStop,
                target: this.hooks.eventTypes.scrollEnd,
            },
        ]);
    };
    Scroller.prototype.bindActions = function () {
        var _this = this;
        var actions = this.actions;
        bubbling(actions.hooks, this.hooks, [
            {
                source: actions.hooks.eventTypes.start,
                target: this.hooks.eventTypes.beforeStart,
            },
            {
                source: actions.hooks.eventTypes.start,
                target: this.hooks.eventTypes.beforeScrollStart,
            },
            {
                source: actions.hooks.eventTypes.beforeMove,
                target: this.hooks.eventTypes.beforeMove,
            },
            {
                source: actions.hooks.eventTypes.scrollStart,
                target: this.hooks.eventTypes.scrollStart,
            },
            {
                source: actions.hooks.eventTypes.scroll,
                target: this.hooks.eventTypes.scroll,
            },
            {
                source: actions.hooks.eventTypes.beforeEnd,
                target: this.hooks.eventTypes.beforeEnd,
            },
        ]);
        actions.hooks.on(actions.hooks.eventTypes.end, function (e, pos) {
            _this.hooks.trigger(_this.hooks.eventTypes.touchEnd, pos);
            if (_this.hooks.trigger(_this.hooks.eventTypes.end, pos)) {
                return true;
            }
            // check if it is a click operation
            if (!actions.fingerMoved) {
                _this.hooks.trigger(_this.hooks.eventTypes.scrollCancel);
                if (_this.checkClick(e)) {
                    return true;
                }
            }
            // reset if we are outside of the boundaries
            if (_this.resetPosition(_this.options.bounceTime, ease.bounce)) {
                _this.animater.setForceStopped(false);
                return true;
            }
        });
        actions.hooks.on(actions.hooks.eventTypes.scrollEnd, function (pos, duration) {
            var deltaX = Math.abs(pos.x - _this.scrollBehaviorX.startPos);
            var deltaY = Math.abs(pos.y - _this.scrollBehaviorY.startPos);
            if (_this.checkFlick(duration, deltaX, deltaY)) {
                _this.animater.setForceStopped(false);
                _this.hooks.trigger(_this.hooks.eventTypes.flick);
                return;
            }
            if (_this.momentum(pos, duration)) {
                _this.animater.setForceStopped(false);
                return;
            }
            if (actions.contentMoved) {
                _this.hooks.trigger(_this.hooks.eventTypes.scrollEnd, pos);
            }
            if (_this.animater.forceStopped) {
                _this.animater.setForceStopped(false);
            }
        });
    };
    Scroller.prototype.checkFlick = function (duration, deltaX, deltaY) {
        var flickMinMovingDistance = 1; // distinguish flick from click
        if (this.hooks.events.flick.length > 1 &&
            duration < this.options.flickLimitTime &&
            deltaX < this.options.flickLimitDistance &&
            deltaY < this.options.flickLimitDistance &&
            (deltaY > flickMinMovingDistance || deltaX > flickMinMovingDistance)) {
            return true;
        }
    };
    Scroller.prototype.momentum = function (pos, duration) {
        var meta = {
            time: 0,
            easing: ease.swiper,
            newX: pos.x,
            newY: pos.y,
        };
        // start momentum animation if needed
        var momentumX = this.scrollBehaviorX.end(duration);
        var momentumY = this.scrollBehaviorY.end(duration);
        meta.newX = isUndef(momentumX.destination)
            ? meta.newX
            : momentumX.destination;
        meta.newY = isUndef(momentumY.destination)
            ? meta.newY
            : momentumY.destination;
        meta.time = Math.max(momentumX.duration, momentumY.duration);
        this.hooks.trigger(this.hooks.eventTypes.momentum, meta, this);
        // when x or y changed, do momentum animation now!
        if (meta.newX !== pos.x || meta.newY !== pos.y) {
            // change easing function when scroller goes out of the boundaries
            if (meta.newX > this.scrollBehaviorX.minScrollPos ||
                meta.newX < this.scrollBehaviorX.maxScrollPos ||
                meta.newY > this.scrollBehaviorY.minScrollPos ||
                meta.newY < this.scrollBehaviorY.maxScrollPos) {
                meta.easing = ease.swipeBounce;
            }
            this.scrollTo(meta.newX, meta.newY, meta.time, meta.easing);
            return true;
        }
    };
    Scroller.prototype.checkClick = function (e) {
        var cancelable = {
            preventClick: this.animater.forceStopped,
        };
        // we scrolled less than momentumLimitDistance pixels
        if (this.hooks.trigger(this.hooks.eventTypes.checkClick)) {
            this.animater.setForceStopped(false);
            return true;
        }
        if (!cancelable.preventClick) {
            var _dblclick = this.options.dblclick;
            var dblclickTrigged = false;
            if (_dblclick && this.lastClickTime) {
                var _a = _dblclick.delay, delay = _a === void 0 ? 300 : _a;
                if (getNow() - this.lastClickTime < delay) {
                    dblclickTrigged = true;
                    dblclick(e);
                }
            }
            if (this.options.tap) {
                tap(e, this.options.tap);
            }
            if (this.options.click &&
                !preventDefaultExceptionFn(e.target, this.options.preventDefaultException)) {
                click(e);
            }
            this.lastClickTime = dblclickTrigged ? null : getNow();
            return true;
        }
        return false;
    };
    Scroller.prototype.resize = function () {
        var _this = this;
        if (!this.actions.enabled) {
            return;
        }
        // fix a scroll problem under Android condition
        /* istanbul ignore if  */
        if (isAndroid) {
            this.wrapper.scrollTop = 0;
        }
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = window.setTimeout(function () {
            _this.hooks.trigger(_this.hooks.eventTypes.resize);
        }, this.options.resizePolling);
    };
    /* istanbul ignore next */
    Scroller.prototype.transitionEnd = function (e) {
        if (e.target !== this.content || !this.animater.pending) {
            return;
        }
        var animater = this.animater;
        animater.transitionTime();
        if (!this.resetPosition(this.options.bounceTime, ease.bounce)) {
            this.animater.setPending(false);
            if (this.options.probeType !== 3 /* Realtime */) {
                this.hooks.trigger(this.hooks.eventTypes.scrollEnd, this.getCurrentPos());
            }
        }
    };
    Scroller.prototype.togglePointerEvents = function (enabled) {
        if (enabled === void 0) { enabled = true; }
        var el = this.content.children.length
            ? this.content.children
            : [this.content];
        var pointerEvents = enabled ? 'auto' : 'none';
        for (var i = 0; i < el.length; i++) {
            var node = el[i];
            // ignore BetterScroll instance's wrapper DOM
            /* istanbul ignore if  */
            if (node.isBScrollContainer) {
                continue;
            }
            node.style.pointerEvents = pointerEvents;
        }
    };
    Scroller.prototype.refresh = function (content) {
        var contentChanged = this.setContent(content);
        this.hooks.trigger(this.hooks.eventTypes.beforeRefresh);
        this.scrollBehaviorX.refresh(content);
        this.scrollBehaviorY.refresh(content);
        if (contentChanged) {
            this.translater.setContent(content);
            this.animater.setContent(content);
            this.transitionEndRegister.destroy();
            this.registerTransitionEnd();
            if (this.options.bindToTarget) {
                this.actionsHandler.setContent(content);
            }
        }
        this.actions.refresh();
        this.wrapperOffset = offset(this.wrapper);
    };
    Scroller.prototype.setContent = function (content) {
        var contentChanged = content !== this.content;
        if (contentChanged) {
            this.content = content;
        }
        return contentChanged;
    };
    Scroller.prototype.scrollBy = function (deltaX, deltaY, time, easing) {
        if (time === void 0) { time = 0; }
        var _a = this.getCurrentPos(), x = _a.x, y = _a.y;
        easing = !easing ? ease.bounce : easing;
        deltaX += x;
        deltaY += y;
        this.scrollTo(deltaX, deltaY, time, easing);
    };
    Scroller.prototype.scrollTo = function (x, y, time, easing, extraTransform) {
        if (time === void 0) { time = 0; }
        if (easing === void 0) { easing = ease.bounce; }
        if (extraTransform === void 0) { extraTransform = {
            start: {},
            end: {},
        }; }
        var easingFn = this.options.useTransition ? easing.style : easing.fn;
        var currentPos = this.getCurrentPos();
        var startPoint = __assign({ x: currentPos.x, y: currentPos.y }, extraTransform.start);
        var endPoint = __assign({ x: x,
            y: y }, extraTransform.end);
        this.hooks.trigger(this.hooks.eventTypes.scrollTo, endPoint);
        // it is an useless move
        if (isSamePoint(startPoint, endPoint))
            return;
        var deltaX = Math.abs(endPoint.x - startPoint.x);
        var deltaY = Math.abs(endPoint.y - startPoint.y);
        // considering of browser compatibility for decimal transform value
        // force translating immediately
        if (deltaX < MIN_SCROLL_DISTANCE && deltaY < MIN_SCROLL_DISTANCE) {
            time = 0;
            this.hooks.trigger(this.hooks.eventTypes.minDistanceScroll);
        }
        this.animater.move(startPoint, endPoint, time, easingFn);
    };
    Scroller.prototype.scrollToElement = function (el, time, offsetX, offsetY, easing) {
        var targetEle = getElement(el);
        var pos = offset(targetEle);
        var getOffset = function (offset, size, wrapperSize) {
            if (typeof offset === 'number') {
                return offset;
            }
            // if offsetX/Y are true we center the element to the screen
            return offset ? Math.round(size / 2 - wrapperSize / 2) : 0;
        };
        offsetX = getOffset(offsetX, targetEle.offsetWidth, this.wrapper.offsetWidth);
        offsetY = getOffset(offsetY, targetEle.offsetHeight, this.wrapper.offsetHeight);
        var getPos = function (pos, wrapperPos, offset, scrollBehavior) {
            pos -= wrapperPos;
            pos = scrollBehavior.adjustPosition(pos - offset);
            return pos;
        };
        pos.left = getPos(pos.left, this.wrapperOffset.left, offsetX, this.scrollBehaviorX);
        pos.top = getPos(pos.top, this.wrapperOffset.top, offsetY, this.scrollBehaviorY);
        if (this.hooks.trigger(this.hooks.eventTypes.scrollToElement, targetEle, pos)) {
            return;
        }
        this.scrollTo(pos.left, pos.top, time, easing);
    };
    Scroller.prototype.resetPosition = function (time, easing) {
        if (time === void 0) { time = 0; }
        if (easing === void 0) { easing = ease.bounce; }
        var _a = this.scrollBehaviorX.checkInBoundary(), x = _a.position, xInBoundary = _a.inBoundary;
        var _b = this.scrollBehaviorY.checkInBoundary(), y = _b.position, yInBoundary = _b.inBoundary;
        if (xInBoundary && yInBoundary) {
            return false;
        }
        /* istanbul ignore if  */
        if (isIOSBadVersion) {
            // fix ios 13.4 bouncing
            // see it in issues 982
            this.reflow();
        }
        // out of boundary
        this.scrollTo(x, y, time, easing);
        return true;
    };
    /* istanbul ignore next */
    Scroller.prototype.reflow = function () {
        this._reflow = this.content.offsetHeight;
    };
    Scroller.prototype.updatePositions = function (pos) {
        this.scrollBehaviorX.updatePosition(pos.x);
        this.scrollBehaviorY.updatePosition(pos.y);
    };
    Scroller.prototype.getCurrentPos = function () {
        return this.actions.getCurrentPos();
    };
    Scroller.prototype.enable = function () {
        this.actions.enabled = true;
    };
    Scroller.prototype.disable = function () {
        cancelAnimationFrame(this.animater.timer);
        this.actions.enabled = false;
    };
    Scroller.prototype.destroy = function () {
        var _this = this;
        var keys = [
            'resizeRegister',
            'transitionEndRegister',
            'actionsHandler',
            'actions',
            'hooks',
            'animater',
            'translater',
            'scrollBehaviorX',
            'scrollBehaviorY',
        ];
        keys.forEach(function (key) { return _this[key].destroy(); });
    };
    return Scroller;
}());

var BScrollConstructor = /** @class */ (function (_super) {
    __extends(BScrollConstructor, _super);
    function BScrollConstructor(el, options) {
        var _this = _super.call(this, [
            'refresh',
            'contentChanged',
            'enable',
            'disable',
            'beforeScrollStart',
            'scrollStart',
            'scroll',
            'scrollEnd',
            'scrollCancel',
            'touchEnd',
            'flick',
            'destroy'
        ]) || this;
        var wrapper = getElement(el);
        if (!wrapper) {
            warn('Can not resolve the wrapper DOM.');
            return _this;
        }
        _this.plugins = {};
        _this.options = new OptionsConstructor().merge(options).process();
        if (!_this.setContent(wrapper).valid) {
            return _this;
        }
        _this.hooks = new EventEmitter([
            'refresh',
            'enable',
            'disable',
            'destroy',
            'beforeInitialScrollTo',
            'contentChanged'
        ]);
        _this.init(wrapper);
        return _this;
    }
    BScrollConstructor.use = function (ctor) {
        var name = ctor.pluginName;
        var installed = BScrollConstructor.plugins.some(function (plugin) { return ctor === plugin.ctor; });
        if (installed)
            return BScrollConstructor;
        if (isUndef(name)) {
            warn("Plugin Class must specify plugin's name in static property by 'pluginName' field.");
            return BScrollConstructor;
        }
        BScrollConstructor.pluginsMap[name] = true;
        BScrollConstructor.plugins.push({
            name: name,
            applyOrder: ctor.applyOrder,
            ctor: ctor
        });
        return BScrollConstructor;
    };
    BScrollConstructor.prototype.setContent = function (wrapper) {
        var contentChanged = false;
        var valid = true;
        var content = wrapper.children[this.options.specifiedIndexAsContent];
        if (!content) {
            warn('The wrapper need at least one child element to be content element to scroll.');
            valid = false;
        }
        else {
            contentChanged = this.content !== content;
            if (contentChanged) {
                this.content = content;
            }
        }
        return {
            valid: valid,
            contentChanged: contentChanged
        };
    };
    BScrollConstructor.prototype.init = function (wrapper) {
        var _this = this;
        this.wrapper = wrapper;
        // mark wrapper to recognize bs instance by DOM attribute
        wrapper.isBScrollContainer = true;
        this.scroller = new Scroller(wrapper, this.content, this.options);
        this.scroller.hooks.on(this.scroller.hooks.eventTypes.resize, function () {
            _this.refresh();
        });
        this.eventBubbling();
        this.handleAutoBlur();
        this.enable();
        this.proxy(propertiesConfig);
        this.applyPlugins();
        // maybe boundary has changed, should refresh
        this.refreshWithoutReset(this.content);
        var _a = this.options, startX = _a.startX, startY = _a.startY;
        var position = {
            x: startX,
            y: startY
        };
        // maybe plugins want to control scroll position
        if (this.hooks.trigger(this.hooks.eventTypes.beforeInitialScrollTo, position)) {
            return;
        }
        this.scroller.scrollTo(position.x, position.y);
    };
    BScrollConstructor.prototype.applyPlugins = function () {
        var _this = this;
        var options = this.options;
        BScrollConstructor.plugins
            .sort(function (a, b) {
            var _a;
            var applyOrderMap = (_a = {},
                _a["pre" /* Pre */] = -1,
                _a["post" /* Post */] = 1,
                _a);
            var aOrder = a.applyOrder ? applyOrderMap[a.applyOrder] : 0;
            var bOrder = b.applyOrder ? applyOrderMap[b.applyOrder] : 0;
            return aOrder - bOrder;
        })
            .forEach(function (item) {
            var ctor = item.ctor;
            if (options[item.name] && typeof ctor === 'function') {
                _this.plugins[item.name] = new ctor(_this);
            }
        });
    };
    BScrollConstructor.prototype.handleAutoBlur = function () {
        /* istanbul ignore if  */
        if (this.options.autoBlur) {
            this.on(this.eventTypes.beforeScrollStart, function () {
                var activeElement = document.activeElement;
                if (activeElement &&
                    (activeElement.tagName === 'INPUT' ||
                        activeElement.tagName === 'TEXTAREA')) {
                    activeElement.blur();
                }
            });
        }
    };
    BScrollConstructor.prototype.eventBubbling = function () {
        bubbling(this.scroller.hooks, this, [
            this.eventTypes.beforeScrollStart,
            this.eventTypes.scrollStart,
            this.eventTypes.scroll,
            this.eventTypes.scrollEnd,
            this.eventTypes.scrollCancel,
            this.eventTypes.touchEnd,
            this.eventTypes.flick
        ]);
    };
    BScrollConstructor.prototype.refreshWithoutReset = function (content) {
        this.scroller.refresh(content);
        this.hooks.trigger(this.hooks.eventTypes.refresh, content);
        this.trigger(this.eventTypes.refresh, content);
    };
    BScrollConstructor.prototype.proxy = function (propertiesConfig) {
        var _this = this;
        propertiesConfig.forEach(function (_a) {
            var key = _a.key, sourceKey = _a.sourceKey;
            propertiesProxy(_this, sourceKey, key);
        });
    };
    BScrollConstructor.prototype.refresh = function () {
        var _a = this.setContent(this.wrapper), contentChanged = _a.contentChanged, valid = _a.valid;
        if (valid) {
            var content = this.content;
            this.refreshWithoutReset(content);
            if (contentChanged) {
                this.hooks.trigger(this.hooks.eventTypes.contentChanged, content);
                this.trigger(this.eventTypes.contentChanged, content);
            }
            this.scroller.resetPosition();
        }
    };
    BScrollConstructor.prototype.enable = function () {
        this.scroller.enable();
        this.hooks.trigger(this.hooks.eventTypes.enable);
        this.trigger(this.eventTypes.enable);
    };
    BScrollConstructor.prototype.disable = function () {
        this.scroller.disable();
        this.hooks.trigger(this.hooks.eventTypes.disable);
        this.trigger(this.eventTypes.disable);
    };
    BScrollConstructor.prototype.destroy = function () {
        this.hooks.trigger(this.hooks.eventTypes.destroy);
        this.trigger(this.eventTypes.destroy);
        this.scroller.destroy();
    };
    BScrollConstructor.prototype.eventRegister = function (names) {
        this.registerType(names);
    };
    BScrollConstructor.plugins = [];
    BScrollConstructor.pluginsMap = {};
    return BScrollConstructor;
}(EventEmitter));
function createBScroll(el, options) {
    var bs = new BScrollConstructor(el, options);
    return bs;
}
createBScroll.use = BScrollConstructor.use;
createBScroll.plugins = BScrollConstructor.plugins;
createBScroll.pluginsMap = BScrollConstructor.pluginsMap;
var BScroll = createBScroll;




/***/ }),
/* 247 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ PullDown; }
/* harmony export */ });
/*!
 * better-scroll / pull-down
 * (c) 2016-2022 ustbhuangyi
 * Released under the MIT License.
 */
// ssr support
var inBrowser = typeof window !== 'undefined';
var ua = inBrowser && navigator.userAgent.toLowerCase();
!!(ua && /wechatdevtools/.test(ua));
ua && ua.indexOf('android') > 0;
/* istanbul ignore next */
((function () {
    if (typeof ua === 'string') {
        var regex = /os (\d\d?_\d(_\d)?)/;
        var matches = regex.exec(ua);
        if (!matches)
            return false;
        var parts = matches[1].split('_').map(function (item) {
            return parseInt(item, 10);
        });
        // ios version >= 13.4 issue 982
        return !!(parts[0] === 13 && parts[1] >= 4);
    }
    return false;
}))();
/* istanbul ignore next */
var supportsPassive = false;
/* istanbul ignore next */
if (inBrowser) {
    var EventName = 'test-passive';
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', {
            get: function () {
                supportsPassive = true;
            },
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener(EventName, function () { }, opts);
    }
    catch (e) { }
}

var extend = function (target, source) {
    for (var key in source) {
        target[key] = source[key];
    }
    return target;
};

var elementStyle = (inBrowser &&
    document.createElement('div').style);
var vendor = (function () {
    /* istanbul ignore if  */
    if (!inBrowser) {
        return false;
    }
    var transformNames = [
        {
            key: 'standard',
            value: 'transform',
        },
        {
            key: 'webkit',
            value: 'webkitTransform',
        },
        {
            key: 'Moz',
            value: 'MozTransform',
        },
        {
            key: 'O',
            value: 'OTransform',
        },
        {
            key: 'ms',
            value: 'msTransform',
        },
    ];
    for (var _i = 0, transformNames_1 = transformNames; _i < transformNames_1.length; _i++) {
        var obj = transformNames_1[_i];
        if (elementStyle[obj.value] !== undefined) {
            return obj.key;
        }
    }
    /* istanbul ignore next  */
    return false;
})();
/* istanbul ignore next  */
function prefixStyle(style) {
    if (vendor === false) {
        return style;
    }
    if (vendor === 'standard') {
        if (style === 'transitionEnd') {
            return 'transitionend';
        }
        return style;
    }
    return vendor + style.charAt(0).toUpperCase() + style.substr(1);
}
vendor && vendor !== 'standard' ? '-' + vendor.toLowerCase() + '-' : '';
var transform = prefixStyle('transform');
var transition = prefixStyle('transition');
inBrowser && prefixStyle('perspective') in elementStyle;
({
    transform: transform,
    transition: transition,
    transitionTimingFunction: prefixStyle('transitionTimingFunction'),
    transitionDuration: prefixStyle('transitionDuration'),
    transitionDelay: prefixStyle('transitionDelay'),
    transformOrigin: prefixStyle('transformOrigin'),
    transitionEnd: prefixStyle('transitionEnd'),
    transitionProperty: prefixStyle('transitionProperty'),
});

var ease = {
    // easeOutQuint
    swipe: {
        style: 'cubic-bezier(0.23, 1, 0.32, 1)',
        fn: function (t) {
            return 1 + --t * t * t * t * t;
        }
    },
    // easeOutQuard
    swipeBounce: {
        style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
        fn: function (t) {
            return t * (2 - t);
        }
    },
    // easeOutQuart
    bounce: {
        style: 'cubic-bezier(0.165, 0.84, 0.44, 1)',
        fn: function (t) {
            return 1 - --t * t * t * t;
        }
    }
};

var sourcePrefix = 'plugins.pullDownRefresh';
var propertiesMap = [
    {
        key: 'finishPullDown',
        name: 'finishPullDown'
    },
    {
        key: 'openPullDown',
        name: 'openPullDown'
    },
    {
        key: 'closePullDown',
        name: 'closePullDown'
    },
    {
        key: 'autoPullDownRefresh',
        name: 'autoPullDownRefresh'
    }
];
var propertiesConfig = propertiesMap.map(function (item) {
    return {
        key: item.key,
        sourceKey: sourcePrefix + "." + item.name
    };
});

var PULLING_DOWN_EVENT = 'pullingDown';
var ENTER_THRESHOLD_EVENT = 'enterThreshold';
var LEAVE_THRESHOLD_EVENT = 'leaveThreshold';
var PullDown = /** @class */ (function () {
    function PullDown(scroll) {
        this.scroll = scroll;
        this.pulling = 0 /* DEFAULT */;
        this.thresholdBoundary = 0 /* DEFAULT */;
        this.init();
    }
    PullDown.prototype.setPulling = function (status) {
        this.pulling = status;
    };
    PullDown.prototype.setThresholdBoundary = function (boundary) {
        this.thresholdBoundary = boundary;
    };
    PullDown.prototype.init = function () {
        this.handleBScroll();
        this.handleOptions(this.scroll.options.pullDownRefresh);
        this.handleHooks();
        this.watch();
    };
    PullDown.prototype.handleBScroll = function () {
        this.scroll.registerType([
            PULLING_DOWN_EVENT,
            ENTER_THRESHOLD_EVENT,
            LEAVE_THRESHOLD_EVENT,
        ]);
        this.scroll.proxy(propertiesConfig);
    };
    PullDown.prototype.handleOptions = function (userOptions) {
        if (userOptions === void 0) { userOptions = {}; }
        userOptions = (userOptions === true ? {} : userOptions);
        var defaultOptions = {
            threshold: 90,
            stop: 40,
        };
        this.options = extend(defaultOptions, userOptions);
        this.scroll.options.probeType = 3 /* Realtime */;
    };
    PullDown.prototype.handleHooks = function () {
        var _this = this;
        this.hooksFn = [];
        var scroller = this.scroll.scroller;
        var scrollBehaviorY = scroller.scrollBehaviorY;
        this.currentMinScrollY = this.cachedOriginanMinScrollY =
            scrollBehaviorY.minScrollPos;
        this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.contentChanged, function () {
            _this.finishPullDown();
        });
        this.registerHooks(scrollBehaviorY.hooks, scrollBehaviorY.hooks.eventTypes.computeBoundary, function (boundary) {
            // content is smaller than wrapper
            if (boundary.maxScrollPos > 0) {
                // allow scrolling when content is not full of wrapper
                boundary.maxScrollPos = -1;
            }
            boundary.minScrollPos = _this.currentMinScrollY;
        });
        // integrate with mousewheel
        if (this.hasMouseWheelPlugin()) {
            this.registerHooks(this.scroll, this.scroll.eventTypes.alterOptions, function (mouseWheelOptions) {
                var SANE_DISCRETE_TIME = 300;
                var SANE_EASE_TIME = 350;
                mouseWheelOptions.discreteTime = SANE_DISCRETE_TIME;
                // easeTime > discreteTime ensure goInto checkPullDown function
                mouseWheelOptions.easeTime = SANE_EASE_TIME;
            });
            this.registerHooks(this.scroll, this.scroll.eventTypes.mousewheelEnd, function () {
                // mouseWheel need trigger checkPullDown manually
                scroller.hooks.trigger(scroller.hooks.eventTypes.end);
            });
        }
    };
    PullDown.prototype.registerHooks = function (hooks, name, handler) {
        hooks.on(name, handler, this);
        this.hooksFn.push([hooks, name, handler]);
    };
    PullDown.prototype.hasMouseWheelPlugin = function () {
        return !!this.scroll.eventTypes.alterOptions;
    };
    PullDown.prototype.watch = function () {
        var scroller = this.scroll.scroller;
        this.watching = true;
        this.registerHooks(scroller.hooks, scroller.hooks.eventTypes.end, this.checkPullDown);
        this.registerHooks(this.scroll, this.scroll.eventTypes.scrollStart, this.resetStateBeforeScrollStart);
        this.registerHooks(this.scroll, this.scroll.eventTypes.scroll, this.checkLocationOfThresholdBoundary);
        if (this.hasMouseWheelPlugin()) {
            this.registerHooks(this.scroll, this.scroll.eventTypes.mousewheelStart, this.resetStateBeforeScrollStart);
        }
    };
    PullDown.prototype.resetStateBeforeScrollStart = function () {
        // current fetching pulldownRefresh has ended
        if (!this.isFetchingStatus()) {
            this.setPulling(1 /* MOVING */);
            this.setThresholdBoundary(0 /* DEFAULT */);
        }
    };
    PullDown.prototype.checkLocationOfThresholdBoundary = function () {
        // pulldownRefresh is in the phase of Moving
        if (this.pulling === 1 /* MOVING */) {
            var scroll_1 = this.scroll;
            // enter threshold boundary
            var enteredThresholdBoundary = this.thresholdBoundary !== 1 /* INSIDE */ &&
                this.locateInsideThresholdBoundary();
            // leave threshold boundary
            var leftThresholdBoundary = this.thresholdBoundary !== 2 /* OUTSIDE */ &&
                !this.locateInsideThresholdBoundary();
            if (enteredThresholdBoundary) {
                this.setThresholdBoundary(1 /* INSIDE */);
                scroll_1.trigger(ENTER_THRESHOLD_EVENT);
            }
            if (leftThresholdBoundary) {
                this.setThresholdBoundary(2 /* OUTSIDE */);
                scroll_1.trigger(LEAVE_THRESHOLD_EVENT);
            }
        }
    };
    PullDown.prototype.locateInsideThresholdBoundary = function () {
        return this.scroll.y <= this.options.threshold;
    };
    PullDown.prototype.unwatch = function () {
        var scroll = this.scroll;
        var scroller = scroll.scroller;
        this.watching = false;
        scroller.hooks.off(scroller.hooks.eventTypes.end, this.checkPullDown);
        scroll.off(scroll.eventTypes.scrollStart, this.resetStateBeforeScrollStart);
        scroll.off(scroll.eventTypes.scroll, this.checkLocationOfThresholdBoundary);
        if (this.hasMouseWheelPlugin()) {
            scroll.off(scroll.eventTypes.mousewheelStart, this.resetStateBeforeScrollStart);
        }
    };
    PullDown.prototype.checkPullDown = function () {
        var _a = this.options, threshold = _a.threshold, stop = _a.stop;
        // check if a real pull down action
        if (this.scroll.y < threshold) {
            return false;
        }
        if (this.pulling === 1 /* MOVING */) {
            this.modifyBehaviorYBoundary(stop);
            this.setPulling(2 /* FETCHING */);
            this.scroll.trigger(PULLING_DOWN_EVENT);
        }
        this.scroll.scrollTo(this.scroll.x, stop, this.scroll.options.bounceTime, ease.bounce);
        return this.isFetchingStatus();
    };
    PullDown.prototype.isFetchingStatus = function () {
        return this.pulling === 2 /* FETCHING */;
    };
    PullDown.prototype.modifyBehaviorYBoundary = function (stopDistance) {
        var scrollBehaviorY = this.scroll.scroller.scrollBehaviorY;
        // manually modify minScrollPos for a hang animation
        // to prevent from resetPosition
        this.cachedOriginanMinScrollY = scrollBehaviorY.minScrollPos;
        this.currentMinScrollY = stopDistance;
        scrollBehaviorY.computeBoundary();
    };
    PullDown.prototype.finishPullDown = function () {
        if (this.isFetchingStatus()) {
            var scrollBehaviorY = this.scroll.scroller.scrollBehaviorY;
            // restore minScrollY since the hang animation has ended
            this.currentMinScrollY = this.cachedOriginanMinScrollY;
            scrollBehaviorY.computeBoundary();
            this.setPulling(0 /* DEFAULT */);
            this.scroll.resetPosition(this.scroll.options.bounceTime, ease.bounce);
        }
    };
    // allow 'true' type is compat for beta version implements
    PullDown.prototype.openPullDown = function (config) {
        if (config === void 0) { config = {}; }
        this.handleOptions(config);
        if (!this.watching) {
            this.watch();
        }
    };
    PullDown.prototype.closePullDown = function () {
        this.unwatch();
    };
    PullDown.prototype.autoPullDownRefresh = function () {
        var _a = this.options, threshold = _a.threshold, stop = _a.stop;
        if (this.isFetchingStatus() || !this.watching) {
            return;
        }
        this.modifyBehaviorYBoundary(stop);
        this.scroll.trigger(this.scroll.eventTypes.scrollStart);
        this.scroll.scrollTo(this.scroll.x, threshold);
        this.setPulling(2 /* FETCHING */);
        this.scroll.trigger(PULLING_DOWN_EVENT);
        this.scroll.scrollTo(this.scroll.x, stop, this.scroll.options.bounceTime, ease.bounce);
    };
    PullDown.pluginName = 'pullDownRefresh';
    return PullDown;
}());




/***/ }),
/* 248 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ObserveDOM; }
/* harmony export */ });
/*!
 * better-scroll / observe-dom
 * (c) 2016-2022 ustbhuangyi
 * Released under the MIT License.
 */
// ssr support
var inBrowser = typeof window !== 'undefined';
var ua = inBrowser && navigator.userAgent.toLowerCase();
!!(ua && /wechatdevtools/.test(ua));
ua && ua.indexOf('android') > 0;
/* istanbul ignore next */
((function () {
    if (typeof ua === 'string') {
        var regex = /os (\d\d?_\d(_\d)?)/;
        var matches = regex.exec(ua);
        if (!matches)
            return false;
        var parts = matches[1].split('_').map(function (item) {
            return parseInt(item, 10);
        });
        // ios version >= 13.4 issue 982
        return !!(parts[0] === 13 && parts[1] >= 4);
    }
    return false;
}))();
/* istanbul ignore next */
var supportsPassive = false;
/* istanbul ignore next */
if (inBrowser) {
    var EventName = 'test-passive';
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', {
            get: function () {
                supportsPassive = true;
            },
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener(EventName, function () { }, opts);
    }
    catch (e) { }
}

var elementStyle = (inBrowser &&
    document.createElement('div').style);
var vendor = (function () {
    /* istanbul ignore if  */
    if (!inBrowser) {
        return false;
    }
    var transformNames = [
        {
            key: 'standard',
            value: 'transform',
        },
        {
            key: 'webkit',
            value: 'webkitTransform',
        },
        {
            key: 'Moz',
            value: 'MozTransform',
        },
        {
            key: 'O',
            value: 'OTransform',
        },
        {
            key: 'ms',
            value: 'msTransform',
        },
    ];
    for (var _i = 0, transformNames_1 = transformNames; _i < transformNames_1.length; _i++) {
        var obj = transformNames_1[_i];
        if (elementStyle[obj.value] !== undefined) {
            return obj.key;
        }
    }
    /* istanbul ignore next  */
    return false;
})();
/* istanbul ignore next  */
function prefixStyle(style) {
    if (vendor === false) {
        return style;
    }
    if (vendor === 'standard') {
        if (style === 'transitionEnd') {
            return 'transitionend';
        }
        return style;
    }
    return vendor + style.charAt(0).toUpperCase() + style.substr(1);
}
vendor && vendor !== 'standard' ? '-' + vendor.toLowerCase() + '-' : '';
var transform = prefixStyle('transform');
var transition = prefixStyle('transition');
inBrowser && prefixStyle('perspective') in elementStyle;
({
    transform: transform,
    transition: transition,
    transitionTimingFunction: prefixStyle('transitionTimingFunction'),
    transitionDuration: prefixStyle('transitionDuration'),
    transitionDelay: prefixStyle('transitionDelay'),
    transformOrigin: prefixStyle('transformOrigin'),
    transitionEnd: prefixStyle('transitionEnd'),
    transitionProperty: prefixStyle('transitionProperty'),
});
function getRect(el) {
    /* istanbul ignore if  */
    if (el instanceof window.SVGElement) {
        var rect = el.getBoundingClientRect();
        return {
            top: rect.top,
            left: rect.left,
            width: rect.width,
            height: rect.height,
        };
    }
    else {
        return {
            top: el.offsetTop,
            left: el.offsetLeft,
            width: el.offsetWidth,
            height: el.offsetHeight,
        };
    }
}

var ObserveDOM = /** @class */ (function () {
    function ObserveDOM(scroll) {
        this.scroll = scroll;
        this.stopObserver = false;
        this.init();
    }
    ObserveDOM.prototype.init = function () {
        this.handleMutationObserver();
        this.handleHooks();
    };
    ObserveDOM.prototype.handleMutationObserver = function () {
        var _this = this;
        if (typeof MutationObserver !== 'undefined') {
            var timer_1 = 0;
            this.observer = new MutationObserver(function (mutations) {
                _this.mutationObserverHandler(mutations, timer_1);
            });
            this.startObserve(this.observer);
        }
        else {
            this.checkDOMUpdate();
        }
    };
    ObserveDOM.prototype.handleHooks = function () {
        var _this = this;
        this.hooksFn = [];
        this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.contentChanged, function () {
            _this.stopObserve();
            // launch a new mutationObserver
            _this.handleMutationObserver();
        });
        this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.enable, function () {
            if (_this.stopObserver) {
                _this.handleMutationObserver();
            }
        });
        this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.disable, function () {
            _this.stopObserve();
        });
        this.registerHooks(this.scroll.hooks, this.scroll.hooks.eventTypes.destroy, function () {
            _this.destroy();
        });
    };
    ObserveDOM.prototype.mutationObserverHandler = function (mutations, timer) {
        var _this = this;
        if (this.shouldNotRefresh()) {
            return;
        }
        var immediateRefresh = false;
        var deferredRefresh = false;
        for (var i = 0; i < mutations.length; i++) {
            var mutation = mutations[i];
            if (mutation.type !== 'attributes') {
                immediateRefresh = true;
                break;
            }
            else {
                if (mutation.target !== this.scroll.scroller.content) {
                    deferredRefresh = true;
                    break;
                }
            }
        }
        if (immediateRefresh) {
            this.scroll.refresh();
        }
        else if (deferredRefresh) {
            // attributes changes too often
            clearTimeout(timer);
            timer = window.setTimeout(function () {
                if (!_this.shouldNotRefresh()) {
                    _this.scroll.refresh();
                }
            }, 60);
        }
    };
    ObserveDOM.prototype.startObserve = function (observer) {
        var config = {
            attributes: true,
            childList: true,
            subtree: true,
        };
        observer.observe(this.scroll.scroller.content, config);
    };
    ObserveDOM.prototype.shouldNotRefresh = function () {
        var scroller = this.scroll.scroller;
        var scrollBehaviorX = scroller.scrollBehaviorX, scrollBehaviorY = scroller.scrollBehaviorY;
        var outsideBoundaries = scrollBehaviorX.currentPos > scrollBehaviorX.minScrollPos ||
            scrollBehaviorX.currentPos < scrollBehaviorX.maxScrollPos ||
            scrollBehaviorY.currentPos > scrollBehaviorY.minScrollPos ||
            scrollBehaviorY.currentPos < scrollBehaviorY.maxScrollPos;
        return scroller.animater.pending || outsideBoundaries;
    };
    ObserveDOM.prototype.checkDOMUpdate = function () {
        var _this = this;
        var content = this.scroll.scroller.content;
        var contentRect = getRect(content);
        var oldWidth = contentRect.width;
        var oldHeight = contentRect.height;
        var check = function () {
            if (_this.stopObserver) {
                return;
            }
            contentRect = getRect(content);
            var newWidth = contentRect.width;
            var newHeight = contentRect.height;
            if (oldWidth !== newWidth || oldHeight !== newHeight) {
                _this.scroll.refresh();
            }
            oldWidth = newWidth;
            oldHeight = newHeight;
            next();
        };
        var next = function () {
            setTimeout(function () {
                check();
            }, 1000);
        };
        next();
    };
    ObserveDOM.prototype.registerHooks = function (hooks, name, handler) {
        hooks.on(name, handler, this);
        this.hooksFn.push([hooks, name, handler]);
    };
    ObserveDOM.prototype.stopObserve = function () {
        this.stopObserver = true;
        if (this.observer) {
            this.observer.disconnect();
        }
    };
    ObserveDOM.prototype.destroy = function () {
        this.stopObserve();
        this.hooksFn.forEach(function (item) {
            var hooks = item[0];
            var hooksName = item[1];
            var handlerFn = item[2];
            hooks.off(hooksName, handlerFn);
        });
        this.hooksFn.length = 0;
    };
    ObserveDOM.pluginName = 'observeDOM';
    return ObserveDOM;
}());




/***/ }),
/* 249 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _debounce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(251);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(250);



/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return (0,_debounce_js__WEBPACK_IMPORTED_MODULE_1__["default"])(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/* harmony default export */ __webpack_exports__["default"] = (throttle);


/***/ }),
/* 250 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ __webpack_exports__["default"] = (isObject);


/***/ }),
/* 251 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(250);
/* harmony import */ var _now_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(263);
/* harmony import */ var _toNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(252);




/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = (0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(wait) || 0;
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax((0,_toNumber_js__WEBPACK_IMPORTED_MODULE_0__["default"])(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge((0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])());
  }

  function debounced() {
    var time = (0,_now_js__WEBPACK_IMPORTED_MODULE_2__["default"])(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ __webpack_exports__["default"] = (debounce);


/***/ }),
/* 252 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _baseTrim_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(261);
/* harmony import */ var _isObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(250);
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(253);




/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if ((0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return NAN;
  }
  if ((0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = (0,_isObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = (0,_baseTrim_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/* harmony default export */ __webpack_exports__["default"] = (toNumber);


/***/ }),
/* 253 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(255);
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(254);



/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    ((0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == symbolTag);
}

/* harmony default export */ __webpack_exports__["default"] = (isSymbol);


/***/ }),
/* 254 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ __webpack_exports__["default"] = (isObjectLike);


/***/ }),
/* 255 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(256);
/* harmony import */ var _getRawTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(259);
/* harmony import */ var _objectToString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(260);




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? (0,_getRawTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value)
    : (0,_objectToString_js__WEBPACK_IMPORTED_MODULE_2__["default"])(value);
}

/* harmony default export */ __webpack_exports__["default"] = (baseGetTag);


/***/ }),
/* 256 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(257);


/** Built-in value references. */
var Symbol = _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Symbol;

/* harmony default export */ __webpack_exports__["default"] = (Symbol);


/***/ }),
/* 257 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(258);


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__["default"] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["default"] = (root);


/***/ }),
/* 258 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["default"] = (freeGlobal);


/***/ }),
/* 259 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(256);


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? _Symbol_js__WEBPACK_IMPORTED_MODULE_0__["default"].toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (getRawTag);


/***/ }),
/* 260 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/* harmony default export */ __webpack_exports__["default"] = (objectToString);


/***/ }),
/* 261 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(262);


/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, (0,_trimmedEndIndex_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string) + 1).replace(reTrimStart, '')
    : string;
}

/* harmony default export */ __webpack_exports__["default"] = (baseTrim);


/***/ }),
/* 262 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/* harmony default export */ __webpack_exports__["default"] = (trimmedEndIndex);


/***/ }),
/* 263 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(257);


/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root_js__WEBPACK_IMPORTED_MODULE_0__["default"].Date.now();
};

/* harmony default export */ __webpack_exports__["default"] = (now);


/***/ }),
/* 264 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_scroll_view_vue_vue_type_style_index_0_id_74aaaf0a_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(265);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_scroll_view_vue_vue_type_style_index_0_id_74aaaf0a_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_scroll_view_vue_vue_type_style_index_0_id_74aaaf0a_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_scroll_view_vue_vue_type_style_index_0_id_74aaaf0a_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_scroll_view_vue_vue_type_style_index_0_id_74aaaf0a_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 265 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(266);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("0cfbb422", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.mpx-scroll-view {\n  overflow: hidden;\n  position: relative;\n}\n.mpx-scroll-view .mpx-pull-down-wrapper {\n  position: absolute;\n  width: 100%;\n  height: 250px;\n  box-sizing: border-box;\n  transform: translateY(-100%) translateZ(0);\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content {\n  position: absolute;\n  bottom: 20px;\n  left: 50%;\n  transform: translateX(-50%);\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-black .circle {\n  display: inline-block;\n  margin-right: 5px;\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n  background: rgba(0,0,0,0.3);\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-black.active .circle-a {\n  animation: blackLoading 1s 0s infinite;\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-black.active .circle-b {\n  animation: blackLoading 1s 0.3s infinite;\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-black.active .circle-c {\n  animation: blackLoading 1s 0.6s infinite;\n}\n@-moz-keyframes blackLoading {\n0% {\n    background: rgba(0,0,0,0.8);\n}\n100% {\n    background: rgba(0,0,0,0.3);\n}\n}\n@-webkit-keyframes blackLoading {\n0% {\n    background: rgba(0,0,0,0.8);\n}\n100% {\n    background: rgba(0,0,0,0.3);\n}\n}\n@-o-keyframes blackLoading {\n0% {\n    background: rgba(0,0,0,0.8);\n}\n100% {\n    background: rgba(0,0,0,0.3);\n}\n}\n@keyframes blackLoading {\n0% {\n    background: rgba(0,0,0,0.8);\n}\n100% {\n    background: rgba(0,0,0,0.3);\n}\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-white .circle {\n  display: inline-block;\n  margin-right: 5px;\n  width: 8px;\n  height: 8px;\n  border-radius: 50%;\n  background: rgba(255,255,255,0.3);\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-white.active .circle-a {\n  animation: whiteLoading 1s 0s infinite;\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-white.active .circle-b {\n  animation: whiteLoading 1s 0.3s infinite;\n}\n.mpx-scroll-view .mpx-pull-down-wrapper .mpx-pull-down-content-white.active .circle-c {\n  animation: whiteLoading 1s 0.6s infinite;\n}\n@-moz-keyframes whiteLoading {\n0% {\n    background: rgba(255,255,255,0.7);\n}\n100% {\n    background: rgba(255,255,255,0.3);\n}\n}\n@-webkit-keyframes whiteLoading {\n0% {\n    background: rgba(255,255,255,0.7);\n}\n100% {\n    background: rgba(255,255,255,0.3);\n}\n}\n@-o-keyframes whiteLoading {\n0% {\n    background: rgba(255,255,255,0.7);\n}\n100% {\n    background: rgba(255,255,255,0.3);\n}\n}\n@keyframes whiteLoading {\n0% {\n    background: rgba(255,255,255,0.7);\n}\n100% {\n    background: rgba(255,255,255,0.3);\n}\n}\n", ""]);

// exports


/***/ }),
/* 267 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_input_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(268);
/* harmony import */ var _mpx_input_vue_vue_type_style_index_0_id_38740722_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(270);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
var render, staticRenderFns
;

;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _mpx_input_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-input.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 268 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_input_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(269);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_input_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 269 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);

  

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-input',
    props: {
      name: String,
      value: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'text'
      },
      password: Boolean,
      placeholder: String,
      disabled: Boolean,
      maxlength: {
        type: Number,
        default: 140
      },
      autoFocus: Boolean,
      focus: Boolean,
      cursor: {
        type: Number,
        default: -1
      },
      selectionStart: {
        type: Number,
        default: -1
      },
      selectionEnd: {
        type: Number,
        default: -1
      }
    },
    watch: {
      cursor: {
        handler (val) {
          if (val !== -1) this.setSelectionRange(val, val)
        },
        immediate: true
      },
      selectionStart: {
        handler (val) {
          if (val !== -1) this.setSelectionRange(val)
        },
        immediate: true
      },
      selectionEnd: {
        handler (val) {
          if (val !== -1) this.setSelectionRange(undefined, val)
        },
        immediate: true
      }
    },
    render (createElement) {
      const mergeBefore = {
        input (e) {
          (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.extendEvent)(e, {
            detail: {
              value: e.target.value
            }
          })
        },
        focus (e) {
          (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.extendEvent)(e, {
            detail: {
              value: e.target.value
            }
          })
        },
        blur (e) {
          (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.extendEvent)(e, {
            detail: {
              value: e.target.value
            }
          })
        }
      }
      const domProps = {
        name: this.name,
        value: this.value,
        type: this.password ? 'password' : this.type,
        placeholder: this.placeholder,
        disabled: this.disabled,
        autofocus: this.focus || this.autoFocus
      }

      if (this.maxlength !== -1) {
        domProps.maxLength = this.maxlength
      }

      const data = {
        class: 'mpx-input',
        on: (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__["default"])(this, { mergeBefore }),
        domProps,
        ref: 'input'
      }
      return createElement('input', data, this.$slots.default)
    },
    methods: {
      getValue () {
        return this.$refs.input.value
      },
      setValue (value) {
        this.$refs.input.value = value
      },
      notifyChange (value) {
        if (value !== undefined) {
          this.setValue(value)
        } else {
          value = this.getValue()
        }
        // 通过原生input派发事件
        this.$emit('input', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_0__.getCustomEvent)('input', { value }, this.$refs.input))
      },
      setSelectionRange (start, end) {
        if (!this.__selectionRange) this.__selectionRange = {
          start: -1,
          end: -1,
          setting: false
        }
        if (start !== undefined) this.__selectionRange.start = start
        if (end !== undefined) this.__selectionRange.end = end
        if (!this.__selectionRange.setting) {
          this.__selectionRange.setting = true
          this.$nextTick(() => {
            this.__selectionRange.setting = false
            if (this.__selectionRange.start !== -1 && this.__selectionRange.end !== -1) {
              this.$refs.input.setSelectionRange(this.__selectionRange.start, this.__selectionRange.end)
            }
          })
        }
      }
    }
  });


/***/ }),
/* 270 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_input_vue_vue_type_style_index_0_id_38740722_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(271);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_input_vue_vue_type_style_index_0_id_38740722_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_input_vue_vue_type_style_index_0_id_38740722_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_input_vue_vue_type_style_index_0_id_38740722_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_input_vue_vue_type_style_index_0_id_38740722_lang_stylus_isComponent__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 271 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(272);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("37ff6cb8", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.mpx-input {\n  cursor: auto;\n  width: 100%;\n  padding: 0;\n  border: 0;\n  font: inherit;\n  display: block;\n  height: 1.4rem;\n  text-overflow: clip;\n  overflow: hidden;\n  white-space: nowrap;\n  font-family: UICTFontTextStyleBody;\n  min-height: 1.4rem;\n}\n", ""]);

// exports


/***/ }),
/* 273 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_picker_vue_vue_type_template_id_1f86828e_scoped_true_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(274);
/* harmony import */ var _mpx_picker_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(276);
/* harmony import */ var _mpx_picker_vue_vue_type_style_index_0_id_1f86828e_scoped_true_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(279);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(205);



;


/* normalize component */

var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__["default"])(
  _mpx_picker_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_1__["default"],
  _mpx_picker_vue_vue_type_template_id_1f86828e_scoped_true_isComponent__WEBPACK_IMPORTED_MODULE_0__.render,
  _mpx_picker_vue_vue_type_template_id_1f86828e_scoped_true_isComponent__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "1f86828e",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-picker.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 274 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_template_id_1f86828e_scoped_true_isComponent__WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_template_id_1f86828e_scoped_true_isComponent__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_template_id_1f86828e_scoped_true_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(275);


/***/ }),
/* 275 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "staticRenderFns": function() { return /* binding */ staticRenderFns; }
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c
  return _c(
    "div",
    { staticClass: "mpx-picker-container" },
    [
      _c("div", { on: { click: _vm.show } }, [_vm._t("default")], 2),
      _vm._v(" "),
      _c("transition", { attrs: { name: "mpx-picker-fade" } }, [
        _c(
          "div",
          {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: _vm.isShow,
                expression: "isShow",
              },
            ],
            staticClass: "mpx-picker",
            on: {
              touchmove: function ($event) {
                $event.preventDefault()
              },
              click: _vm._cancel,
            },
          },
          [
            _c("transition", { attrs: { name: "mpx-picker-move" } }, [
              _c(
                "div",
                {
                  directives: [
                    {
                      name: "show",
                      rawName: "v-show",
                      value: _vm.isShow,
                      expression: "isShow",
                    },
                  ],
                  staticClass: "mpx-picker-panel",
                  on: {
                    click: function ($event) {
                      $event.stopPropagation()
                    },
                  },
                },
                [
                  _c(
                    "div",
                    { staticClass: "mpx-picker-choose border-bottom-1px" },
                    [
                      _c(
                        "span",
                        { staticClass: "cancel", on: { click: _vm._cancel } },
                        [_vm._v("取消")]
                      ),
                      _vm._v(" "),
                      _c(
                        "span",
                        { staticClass: "confirm", on: { click: _vm._confirm } },
                        [_vm._v("确定")]
                      ),
                    ]
                  ),
                  _vm._v(" "),
                  _c("div", { staticClass: "mpx-picker-content" }, [
                    _c("div", { staticClass: "mask-top border-bottom-1px" }),
                    _vm._v(" "),
                    _c("div", { staticClass: "mask-bottom border-top-1px" }),
                    _vm._v(" "),
                    _c(
                      "div",
                      { ref: "wheelWrapper", staticClass: "wheel-wrapper" },
                      _vm._l(_vm.pickerData, function (data, index) {
                        return _c("div", { key: index, staticClass: "wheel" }, [
                          _c(
                            "ul",
                            { staticClass: "wheel-scroll" },
                            _vm._l(data, function (item) {
                              return _c(
                                "li",
                                { key: item, staticClass: "wheel-item" },
                                [_vm._v(_vm._s(item) + "\n                  ")]
                              )
                            }),
                            0
                          ),
                        ])
                      }),
                      0
                    ),
                  ]),
                ]
              ),
            ]),
          ],
          1
        ),
      ]),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 276 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(277);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 277 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _better_scroll_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(246);
/* harmony import */ var _better_scroll_wheel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(201);
/* harmony import */ var _getInnerListeners__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(200);

  
  
  
  

  const startYear = 1900
  const modeOptions = {
    time: [23, 59],
    date: [200, 11, 30]
  }

  _better_scroll_core__WEBPACK_IMPORTED_MODULE_0__["default"].use(_better_scroll_wheel__WEBPACK_IMPORTED_MODULE_1__["default"])

  function getPickerData (range, rangeKey) {
    if (range) {
      return range.map((item) => {
        if (rangeKey && (0,_util__WEBPACK_IMPORTED_MODULE_2__.type)(item) === 'Object') {
          return item[rangeKey]
        }
        return item
      })
    }
    return range
  }

  function getTimePickerData () {
    let list = []
    for (let i = 0; i < 60; i++) {
      let temp = i < 10 ? `0${i}` : i
      list.push(temp)
    }
    return [list.slice(0, 24), list]
  }

  function getDatePickerData (fields) {
    let years = []
    let months = []
    let days = []

    for (let i = 0; i <= 200; i++) {
      years.push(`${startYear + i}年`)
    }
    if (fields === 'year') {
      return [years]
    }

    for (let i = 1; i <= 12; i++) {
      let temp = i < 10 ? `0${i}` : i
      months.push(`${temp}月`)
    }
    if (fields === 'month') {
      return [years, months]
    }

    for (let i = 1; i <= 31; i++) {
      let temp = i < 10 ? `0${i}` : i
      days.push(`${temp}日`)
    }
    return [years, months, days]
  }

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-picker',
    props: {
      mode: {
        type: String,
        default: 'selector'
      },
      disabled: Boolean,
      range: {
        type: Array,
        default () {
          return []
        }
      },
      rangeKey: String,
      value: {
        type: [Number, String, Array],
        default () {
          switch (this.mode) {
            case 'selector':
              return 0
            case 'multiSelector':
              return []
            case 'time':
              return ''
            case 'date':
              return ''
            default:
              return ''
          }
        }
      },
      start: {
        type: String,
        default: '1970-01-01'
      },
      end: {
        type: String,
        default: '2100-01-01'
      },
      fields: {
        type: String,
        default: 'day'
      }
    },
    data () {
      return {
        isShow: false,
        startIndex: [0, 0, 0],
        endIndex: [0, 0, 0],
        itemHeight: 0
      }
    },
    computed: {
      pickerData () {
        switch (this.mode) {
          case 'selector':
            return [getPickerData(this.range, this.rangeKey)]
          case 'multiSelector':
            return this.range.map((item) => {
              return getPickerData(item, this.rangeKey)
            })
          case 'time':
            return getTimePickerData()
          case 'date':
            return getDatePickerData(this.fields)
          default:
            return []
        }
      }
    },
    watch: {
      pickerData () {
        this.refresh()
      },
      value: {
        handler () {
          let valueTemp = []
          switch (this.mode) {
            case 'selector':
              this.selectedIndex = [this.value]
              break
            case 'multiSelector':
              this.selectedIndex = []
              for (let i = 0; i < this.range.length; i++) {
                this.selectedIndex[i] = this.value[i] || 0
              }
              break
            case 'time':
              this.selectedIndex = []
              if (!this.value)  {
                valueTemp = [new Date().getHours(), new Date().getMinutes()]
              } else {
                valueTemp = this.value && this.value.split(':')
              }
              for (let i = 0; i < valueTemp.length; i++) {
                this.selectedIndex[i] = valueTemp[i] || 0
              }
              break
            case 'date':
              this.selectedIndex = []
              if (!this.value)  {
                valueTemp = [new Date().getFullYear(), new Date().getMonth() + 1, new Date().getDate()]
              } else {
                valueTemp = this.value && this.value.split('-')
              }
              let result = Object.keys(this.pickerData[0]).filter(item => startYear + Number(item) === Number(valueTemp[0]))
              this.selectedIndex[0] = Number(result[0])
              for (let i = 1; i < valueTemp.length; i++) {
                this.selectedIndex[i] = valueTemp[i] - 1
              }
              break
            default:
              this.selectedIndex = [0]
          }
          this.refresh()
        },
        immediate: true
      }
    },
    mounted () {
      this.wheels = []
      this.refresh()
      this.initRangeIndex()
    },
    beforeDestroy () {
      this.wheels.forEach((wheel) => {
        wheel.destroy()
      })
      this.wheels = []
    },
    methods: {
      _confirm () {
        if (this._isMoving()) {
          return
        }
        this.hide()
        let value = ''
        let valueTemp = []
        switch (this.mode) {
          case 'selector':
            value = this.selectedIndex[0]
            break
          case 'multiSelector':
            value = this.selectedIndex.slice()
            break
          case 'time':
            for (let i = 0; i < this.selectedIndex.length; i++) {
              valueTemp[i] = this.selectedIndex[i] < 10 ? `0${Number(this.selectedIndex[i])}` : `${this.selectedIndex[i]}`
            }
            value = `${valueTemp[0]}:${valueTemp[1]}`
            break
          case 'date':
            let year = this.pickerData[0][this.selectedIndex[0]].replace('年', '')
            if (this.fields === 'year') {
              value = `${year}`
              break
            }

            let month = this.selectedIndex[1] < 9 ? `0${this.selectedIndex[1] + 1}` : this.selectedIndex[1] + 1
            if (this.fields === 'month') {
              value = `${year}-${month}`
              break
            }

            let day = this.selectedIndex[2] < 9 ? `0${this.selectedIndex[2] + 1}` : this.selectedIndex[2] + 1
            value = `${year}-${month}-${day}`
            break
          default:
            value = this.selectedIndex[0]
        }
        this.$emit('change', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_3__.getCustomEvent)('change', {value}))
      },
      _cancel () {
        this.hide()
        this.$emit('cancel', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_3__.getCustomEvent)('cancel'))
      },
      _isMoving () {
        return this.wheels.some((wheel) => {
          return wheel.pending
        })
      },
      show () {
        this.isShow = true
        if (this.needRefresh) {
          this.needRefresh = false
          this.refresh()
        }
      },
      hide () {
        this.isShow = false
      },
      refresh () {
        if (this.isShow) {
          if (this.refreshing) return
          this.refreshing = true
          this.$nextTick(() => {
            let i = 0
            const wheelWrapper = this.$refs.wheelWrapper
            for (; i < this.pickerData.length; i++) {
              this.selectedIndex[i] = +this.selectedIndex[i] || 0
              if (this.selectedIndex[i] >= this.pickerData[i].length) {
                this.selectedIndex[i] = 0
              }
              if (this.wheels[i]) {
                this.wheels[i].refresh()
                if (this.wheels[i].getSelectedIndex() !== this.selectedIndex[i]) {
                  this.wheels[i].wheelTo(this.selectedIndex[i])
                }
              } else {
                this.wheels[i] = new _better_scroll_core__WEBPACK_IMPORTED_MODULE_0__["default"](wheelWrapper.children[i], {
                  wheel: {
                    selectedIndex: this.selectedIndex[i],
                    wheelWrapperClass: 'wheel-scroll',
                    wheelItemClass: 'wheel-item'
                  },
                  probeType: 3
                })
                if (this.mode === 'time' || this.mode === 'date') {
                  this.wheels[i].on('scrollStart', function (i) {
                    this.handleScrollStart()
                  }.bind(this, i))
                }
                this.wheels[i].on('scrollEnd', function (i) {
                  if (this.refreshing) return
                  const currentIndex = this.wheels[i].getSelectedIndex()
                  if (this.selectedIndex[i] !== currentIndex) {
                    this.selectedIndex[i] = currentIndex
                    if (this.mode === 'multiSelector') {
                      this.$emit('columnchange', (0,_getInnerListeners__WEBPACK_IMPORTED_MODULE_3__.getCustomEvent)('columnchange', {
                        column: i,
                        value: currentIndex
                      }))
                    }
                  }
                  if (this.mode === 'time' || this.mode === 'date') {
                    this.handleScrollEnd()
                  }
                }.bind(this, i))
              }
            }
            if (this.mode === 'time' || this.mode === 'date') {
              this.initWheelPosition()
            }
            for (; i < this.wheels.length; i++) {
              if (this.wheels[i]) {
                this.wheels[i].destroy()
              }
            }
            this.wheels.length = this.pickerData.length
            this.selectedIndex.length = this.pickerData.length
            this.refreshing = false
          })
        } else {
          this.needRefresh = true
        }
      },
      initRangeIndex () {
        if (this.mode !== 'time' && this.mode !== 'date') {
          return
        }

        this.itemHeight = window.getComputedStyle(document.getElementsByClassName('wheel-item')[0]).height.replace(/px/g, '')
        if (this.mode === 'time') {
          this.startIndex = [this.getIndex('start', 0, ':'), this.getIndex('start', 1, ':')]
          this.endIndex = [this.getIndex('end', 0, ':'), this.getIndex('end', 1, ':')]
        }
        if (this.mode === 'date') {
          this.startIndex = [this.getIndex('start', 0, '-') - startYear, this.getIndex('start', 1, '-') - 1, this.getIndex('start', 2, '-') - 1]
          this.endIndex = [this.getIndex('end', 0, '-') - startYear, this.getIndex('end', 1, '-') - 1, this.getIndex('end', 2, '-') - 1]
        }
      },
      getIndex (type, i, delimiter) {
        return this[type] && Number(this[type].split(delimiter)[i])
      },
      handleScrollStart () {
        // 重置可滚动距离
        for (let i = 0; i < this.wheels.length; i++) {
          this.wheels[i].minScrollY = 0
          this.wheels[i].maxScrollY = -(modeOptions[this.mode][i] * this.itemHeight)
        }
        //开始滚动 判断最多可滚动距离
        if (this.start) {
          this.wheels[0].minScrollY = -(this.startIndex[0] * this.itemHeight)

          for (let i = 0; i < this.wheels.length; i++) {
            if (!(this.wheels[i + 1] && this.wheels[i].getSelectedIndex() === this.startIndex[i])) {
              break
            }
            this.wheels[i + 1].minScrollY = -(this.startIndex[i + 1] * this.itemHeight)
            this.wheels[i + 1].maxScrollY = -(modeOptions[this.mode][i + 1] * this.itemHeight)
          }
        }
        if (this.end) {
          this.wheels[0].maxScrollY = -(this.endIndex[0] * this.itemHeight)

          for (let i = 0; i < this.wheels.length; i++) {
            if (!(this.wheels[i + 1] && this.wheels[i].getSelectedIndex() === this.endIndex[i])) {
              break
            }
            this.wheels[i + 1].minScrollY = 0
            this.wheels[i + 1].maxScrollY = -(this.endIndex[i + 1] * this.itemHeight)
          }
        }
      },
      handleScrollEnd () {
        const solarMonths = [1, 3, 5, 7, 8, 10, 12]
        if (this.start) {
          for (let i = 0; i < this.wheels.length; i++) {
            if (!(this.wheels[i].getSelectedIndex() === this.startIndex[i]) || !(this.wheels[i + 1])) {
              break
            }
            if (this.wheels[i + 1].getSelectedIndex() < this.startIndex[i + 1]) {
              this.wheels[i + 1].minScrollY = 0
              this.wheels[i + 1].maxScrollY = -(modeOptions[this.mode][i+1] * this.itemHeight)
              this.wheels[i + 1].wheelTo([this.startIndex[i + 1]])
            }
          }
        }
        if (this.end) {
          for (let i = 0; i < this.wheels.length; i++) {
            if (!(this.wheels[i].getSelectedIndex() === this.endIndex[i]) || !(this.wheels[i + 1])) {
              break
            }
            if (this.wheels[i + 1].getSelectedIndex() > this.endIndex[i + 1]) {
              this.wheels[i + 1].minScrollY = 0
              this.wheels[i + 1].maxScrollY = -(modeOptions[this.mode][i+1] * this.itemHeight)
              this.wheels[i + 1].wheelTo([this.endIndex[i + 1]])
            }
          }
        }
        // 单独处理小月30天，2月28天或29天情况
        if (this.mode === 'date' && this.fields === 'day' && !solarMonths.includes(this.wheels[1].getSelectedIndex() + 1)) {
          const currentYear = this.wheels[0].getSelectedIndex() + startYear
          const isFebruary = this.wheels[1].getSelectedIndex() === 1
          const isLeapYear = (currentYear % 4 === 0 && (currentYear % 100 !== 0)) || (currentYear % 400 === 0)
          const day = isFebruary && (isLeapYear ? 28 : 27) || 29
          this.wheels[2].getSelectedIndex() > day && this.wheels[2].wheelTo([0])
        }

      },
      initWheelPosition () {
        if (this.start) {
          if (this.wheels[0].getSelectedIndex() < this.startIndex[0]) {
            for (let i = 0; i < this.wheels.length; i++) {
              this.wheels[i].wheelTo([this.startIndex[i]])
              this.selectedIndex[i] = this.startIndex[i] || 0
            }
          } else {
            for (let i = 0; i < this.wheels.length; i++) {
              if (this.wheels[i].getSelectedIndex() !== this.startIndex[i]) {
                break
              }
              if (this.wheels[i+1] && this.wheels[i+1].getSelectedIndex() < this.startIndex[i+1]) {
                for (let j = i+1; j < this.wheels.length; j++) {
                  this.wheels[j].wheelTo([this.startIndex[j]])
                  this.selectedIndex[j] = this.startIndex[j] || 0
                }
              }
            }
          }
        }
        if (this.end) {
          if (this.wheels[0].getSelectedIndex() > this.endIndex[0]) {
            for (let i = 0; i < this.wheels.length; i++) {
              this.wheels[i].wheelTo([this.endIndex[i]])
              this.selectedIndex[i] = this.endIndex[i] || 0
            }
          } else {
            for (let i = 0; i < this.wheels.length; i++) {
              if (this.wheels[i].getSelectedIndex() !== this.endIndex[i]) {
                break
              }
              if (this.wheels[i+1] && this.wheels[i+1].getSelectedIndex() > this.endIndex[i+1]) {
                for (let j = i+1; j < this.wheels.length; j++) {
                  this.wheels[j].wheelTo([this.endIndex[j]])
                  this.selectedIndex[j] = this.endIndex[j] || 0
                }
              }
            }
          }
        }
      }
    }
  });


/***/ }),
/* 278 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ Wheel; }
/* harmony export */ });
/*!
 * better-scroll / wheel
 * (c) 2016-2022 ustbhuangyi
 * Released under the MIT License.
 */
// ssr support
var inBrowser = typeof window !== 'undefined';
var ua = inBrowser && navigator.userAgent.toLowerCase();
!!(ua && /wechatdevtools/.test(ua));
ua && ua.indexOf('android') > 0;
/* istanbul ignore next */
((function () {
    if (typeof ua === 'string') {
        var regex = /os (\d\d?_\d(_\d)?)/;
        var matches = regex.exec(ua);
        if (!matches)
            return false;
        var parts = matches[1].split('_').map(function (item) {
            return parseInt(item, 10);
        });
        // ios version >= 13.4 issue 982
        return !!(parts[0] === 13 && parts[1] >= 4);
    }
    return false;
}))();
/* istanbul ignore next */
var supportsPassive = false;
/* istanbul ignore next */
if (inBrowser) {
    var EventName = 'test-passive';
    try {
        var opts = {};
        Object.defineProperty(opts, 'passive', {
            get: function () {
                supportsPassive = true;
            },
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener(EventName, function () { }, opts);
    }
    catch (e) { }
}

var extend = function (target, source) {
    for (var key in source) {
        target[key] = source[key];
    }
    return target;
};

var elementStyle = (inBrowser &&
    document.createElement('div').style);
var vendor = (function () {
    /* istanbul ignore if  */
    if (!inBrowser) {
        return false;
    }
    var transformNames = [
        {
            key: 'standard',
            value: 'transform',
        },
        {
            key: 'webkit',
            value: 'webkitTransform',
        },
        {
            key: 'Moz',
            value: 'MozTransform',
        },
        {
            key: 'O',
            value: 'OTransform',
        },
        {
            key: 'ms',
            value: 'msTransform',
        },
    ];
    for (var _i = 0, transformNames_1 = transformNames; _i < transformNames_1.length; _i++) {
        var obj = transformNames_1[_i];
        if (elementStyle[obj.value] !== undefined) {
            return obj.key;
        }
    }
    /* istanbul ignore next  */
    return false;
})();
/* istanbul ignore next  */
function prefixStyle(style) {
    if (vendor === false) {
        return style;
    }
    if (vendor === 'standard') {
        if (style === 'transitionEnd') {
            return 'transitionend';
        }
        return style;
    }
    return vendor + style.charAt(0).toUpperCase() + style.substr(1);
}
vendor && vendor !== 'standard' ? '-' + vendor.toLowerCase() + '-' : '';
var transform = prefixStyle('transform');
var transition = prefixStyle('transition');
inBrowser && prefixStyle('perspective') in elementStyle;
var style = {
    transform: transform,
    transition: transition,
    transitionTimingFunction: prefixStyle('transitionTimingFunction'),
    transitionDuration: prefixStyle('transitionDuration'),
    transitionDelay: prefixStyle('transitionDelay'),
    transformOrigin: prefixStyle('transformOrigin'),
    transitionEnd: prefixStyle('transitionEnd'),
    transitionProperty: prefixStyle('transitionProperty'),
};
function hasClass(el, className) {
    var reg = new RegExp('(^|\\s)' + className + '(\\s|$)');
    return reg.test(el.className);
}
function HTMLCollectionToArray(el) {
    return Array.prototype.slice.call(el, 0);
}

var ease = {
    // easeOutQuint
    swipe: {
        style: 'cubic-bezier(0.23, 1, 0.32, 1)',
        fn: function (t) {
            return 1 + --t * t * t * t * t;
        }
    },
    // easeOutQuard
    swipeBounce: {
        style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
        fn: function (t) {
            return t * (2 - t);
        }
    },
    // easeOutQuart
    bounce: {
        style: 'cubic-bezier(0.165, 0.84, 0.44, 1)',
        fn: function (t) {
            return 1 - --t * t * t * t;
        }
    }
};

var sourcePrefix = 'plugins.wheel';
var propertiesMap = [
    {
        key: 'wheelTo',
        name: 'wheelTo',
    },
    {
        key: 'getSelectedIndex',
        name: 'getSelectedIndex',
    },
    {
        key: 'restorePosition',
        name: 'restorePosition',
    },
];
var propertiesConfig = propertiesMap.map(function (item) {
    return {
        key: item.key,
        sourceKey: sourcePrefix + "." + item.name,
    };
});

var WHEEL_INDEX_CHANGED_EVENT_NAME = 'wheelIndexChanged';
var CONSTANTS = {
    rate: 4
};
var Wheel = /** @class */ (function () {
    function Wheel(scroll) {
        this.scroll = scroll;
        this.init();
    }
    Wheel.prototype.init = function () {
        this.handleBScroll();
        this.handleOptions();
        this.handleHooks();
        // init boundary for Wheel
        this.refreshBoundary();
        this.setSelectedIndex(this.options.selectedIndex);
    };
    Wheel.prototype.handleBScroll = function () {
        this.scroll.proxy(propertiesConfig);
        this.scroll.registerType([WHEEL_INDEX_CHANGED_EVENT_NAME]);
    };
    Wheel.prototype.handleOptions = function () {
        var userOptions = (this.scroll.options.wheel === true
            ? {}
            : this.scroll.options.wheel);
        var defaultOptions = {
            wheelWrapperClass: 'wheel-scroll',
            wheelItemClass: 'wheel-item',
            rotate: 25,
            adjustTime: 400,
            selectedIndex: 0,
            wheelDisabledItemClass: 'wheel-disabled-item'
        };
        this.options = extend(defaultOptions, userOptions);
    };
    Wheel.prototype.handleHooks = function () {
        var _this = this;
        var scroll = this.scroll;
        var scroller = this.scroll.scroller;
        var actionsHandler = scroller.actionsHandler, scrollBehaviorX = scroller.scrollBehaviorX, scrollBehaviorY = scroller.scrollBehaviorY, animater = scroller.animater;
        var prevContent = scroller.content;
        // BScroll
        scroll.on(scroll.eventTypes.scrollEnd, function (position) {
            var index = _this.findNearestValidWheel(position.y).index;
            if (scroller.animater.forceStopped && !_this.isAdjustingPosition) {
                _this.target = _this.items[index];
                // since stopped from an animation.
                // prevent user's scrollEnd callback triggered twice
                return true;
            }
            else {
                _this.setSelectedIndex(index);
                if (_this.isAdjustingPosition) {
                    _this.isAdjustingPosition = false;
                }
            }
        });
        // BScroll.hooks
        this.scroll.hooks.on(this.scroll.hooks.eventTypes.refresh, function (content) {
            if (content !== prevContent) {
                prevContent = content;
                _this.setSelectedIndex(_this.options.selectedIndex, true);
            }
            // rotate all wheel-items
            // because position may not change
            _this.rotateX(_this.scroll.y);
            // check we are stop at a disable item or not
            _this.wheelTo(_this.selectedIndex, 0);
        });
        this.scroll.hooks.on(this.scroll.hooks.eventTypes.beforeInitialScrollTo, function (position) {
            // selectedIndex has higher priority than bs.options.startY
            position.x = 0;
            position.y = -(_this.selectedIndex * _this.itemHeight);
        });
        // Scroller
        scroller.hooks.on(scroller.hooks.eventTypes.checkClick, function () {
            var index = HTMLCollectionToArray(_this.items).indexOf(_this.target);
            if (index === -1)
                return true;
            _this.wheelTo(index, _this.options.adjustTime, ease.swipe);
            return true;
        });
        scroller.hooks.on(scroller.hooks.eventTypes.scrollTo, function (endPoint) {
            endPoint.y = _this.findNearestValidWheel(endPoint.y).y;
        });
        // when content is scrolling
        // click wheel-item DOM repeatedly and crazily will cause scrollEnd not triggered
        // so reset forceStopped
        scroller.hooks.on(scroller.hooks.eventTypes.minDistanceScroll, function () {
            var animater = scroller.animater;
            if (animater.forceStopped === true) {
                animater.forceStopped = false;
            }
        });
        scroller.hooks.on(scroller.hooks.eventTypes.scrollToElement, function (el, pos) {
            if (!hasClass(el, _this.options.wheelItemClass)) {
                return true;
            }
            else {
                pos.top = _this.findNearestValidWheel(pos.top).y;
            }
        });
        // ActionsHandler
        actionsHandler.hooks.on(actionsHandler.hooks.eventTypes.beforeStart, function (e) {
            _this.target = e.target;
        });
        // ScrollBehaviorX
        // Wheel has no x direction now
        scrollBehaviorX.hooks.on(scrollBehaviorX.hooks.eventTypes.computeBoundary, function (boundary) {
            boundary.maxScrollPos = 0;
            boundary.minScrollPos = 0;
        });
        // ScrollBehaviorY
        scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.computeBoundary, function (boundary) {
            _this.items = _this.scroll.scroller.content.children;
            _this.checkWheelAllDisabled();
            _this.itemHeight =
                _this.items.length > 0
                    ? scrollBehaviorY.contentSize / _this.items.length
                    : 0;
            boundary.maxScrollPos = -_this.itemHeight * (_this.items.length - 1);
            boundary.minScrollPos = 0;
        });
        scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.momentum, function (momentumInfo) {
            momentumInfo.rate = CONSTANTS.rate;
            momentumInfo.destination = _this.findNearestValidWheel(momentumInfo.destination).y;
        });
        scrollBehaviorY.hooks.on(scrollBehaviorY.hooks.eventTypes.end, function (momentumInfo) {
            var validWheel = _this.findNearestValidWheel(scrollBehaviorY.currentPos);
            momentumInfo.destination = validWheel.y;
            momentumInfo.duration = _this.options.adjustTime;
        });
        // Animater
        animater.hooks.on(animater.hooks.eventTypes.time, function (time) {
            _this.transitionDuration(time);
        });
        animater.hooks.on(animater.hooks.eventTypes.timeFunction, function (easing) {
            _this.timeFunction(easing);
        });
        // bs.stop() to make wheel stop at a correct position when pending
        animater.hooks.on(animater.hooks.eventTypes.callStop, function () {
            var index = _this.findNearestValidWheel(_this.scroll.y).index;
            _this.isAdjustingPosition = true;
            _this.wheelTo(index, 0);
        });
        // Translater
        animater.translater.hooks.on(animater.translater.hooks.eventTypes.translate, function (endPoint) {
            _this.rotateX(endPoint.y);
        });
    };
    Wheel.prototype.refreshBoundary = function () {
        var _a = this.scroll.scroller, scrollBehaviorX = _a.scrollBehaviorX, scrollBehaviorY = _a.scrollBehaviorY, content = _a.content;
        scrollBehaviorX.refresh(content);
        scrollBehaviorY.refresh(content);
    };
    Wheel.prototype.setSelectedIndex = function (index, contentChanged) {
        if (contentChanged === void 0) { contentChanged = false; }
        var prevSelectedIndex = this.selectedIndex;
        this.selectedIndex = index;
        // if content DOM changed, should not trigger event
        if (prevSelectedIndex !== index && !contentChanged) {
            this.scroll.trigger(WHEEL_INDEX_CHANGED_EVENT_NAME, index);
        }
    };
    Wheel.prototype.getSelectedIndex = function () {
        return this.selectedIndex;
    };
    Wheel.prototype.wheelTo = function (index, time, ease) {
        if (index === void 0) { index = 0; }
        if (time === void 0) { time = 0; }
        var y = -index * this.itemHeight;
        this.scroll.scrollTo(0, y, time, ease);
    };
    Wheel.prototype.restorePosition = function () {
        // bs is scrolling
        var isPending = this.scroll.pending;
        if (isPending) {
            var selectedIndex = this.getSelectedIndex();
            this.scroll.scroller.animater.clearTimer();
            this.wheelTo(selectedIndex, 0);
        }
    };
    Wheel.prototype.transitionDuration = function (time) {
        for (var i = 0; i < this.items.length; i++) {
            this.items[i].style[style.transitionDuration] =
                time + 'ms';
        }
    };
    Wheel.prototype.timeFunction = function (easing) {
        for (var i = 0; i < this.items.length; i++) {
            this.items[i].style[style.transitionTimingFunction] = easing;
        }
    };
    Wheel.prototype.rotateX = function (y) {
        var _a = this.options.rotate, rotate = _a === void 0 ? 25 : _a;
        for (var i = 0; i < this.items.length; i++) {
            var deg = rotate * (y / this.itemHeight + i);
            // Too small value is invalid in some phones, issue 1026
            var SafeDeg = deg.toFixed(3);
            this.items[i].style[style.transform] = "rotateX(" + SafeDeg + "deg)";
        }
    };
    Wheel.prototype.findNearestValidWheel = function (y) {
        y = y > 0 ? 0 : y < this.scroll.maxScrollY ? this.scroll.maxScrollY : y;
        var currentIndex = Math.abs(Math.round(-y / this.itemHeight));
        var cacheIndex = currentIndex;
        var items = this.items;
        var wheelDisabledItemClassName = this.options
            .wheelDisabledItemClass;
        // implement web native select element
        // first, check whether there is a enable item whose index is smaller than currentIndex
        // then, check whether there is a enable item whose index is bigger than currentIndex
        // otherwise, there are all disabled items, just keep currentIndex unchange
        while (currentIndex >= 0) {
            if (!hasClass(items[currentIndex], wheelDisabledItemClassName)) {
                break;
            }
            currentIndex--;
        }
        if (currentIndex < 0) {
            currentIndex = cacheIndex;
            while (currentIndex <= items.length - 1) {
                if (!hasClass(items[currentIndex], wheelDisabledItemClassName)) {
                    break;
                }
                currentIndex++;
            }
        }
        // keep it unchange when all the items are disabled
        if (currentIndex === items.length) {
            currentIndex = cacheIndex;
        }
        // when all the items are disabled, selectedIndex should always be -1
        return {
            index: this.wheelItemsAllDisabled ? -1 : currentIndex,
            y: -currentIndex * this.itemHeight
        };
    };
    Wheel.prototype.checkWheelAllDisabled = function () {
        var wheelDisabledItemClassName = this.options.wheelDisabledItemClass;
        var items = this.items;
        this.wheelItemsAllDisabled = true;
        for (var i = 0; i < items.length; i++) {
            if (!hasClass(items[i], wheelDisabledItemClassName)) {
                this.wheelItemsAllDisabled = false;
                break;
            }
        }
    };
    Wheel.pluginName = 'wheel';
    return Wheel;
}());




/***/ }),
/* 279 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_style_index_0_id_1f86828e_scoped_true_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(280);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_style_index_0_id_1f86828e_scoped_true_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_style_index_0_id_1f86828e_scoped_true_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_style_index_0_id_1f86828e_scoped_true_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_loaders_dist_style_loader_js_node_modules_pnpm_stylus_loader_3_0_2_stylus_0_54_8_node_modules_stylus_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_picker_vue_vue_type_style_index_0_id_1f86828e_scoped_true_lang_stylus_rel_stylesheet_2Fstylus_isComponent__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 280 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(281);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("3116ec9e", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.border-top-1px[data-v-1f86828e] {\n  position: relative;\n}\n.border-top-1px[data-v-1f86828e]:before {\n  content: \"\";\n  pointer-events: none;\n  display: block;\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform-origin: 0 0;\n  border-top: 1px solid #ebebeb;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n}\n@media (-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2) {\n.border-top-1px[data-v-1f86828e]:before {\n    width: 200%;\n    height: 200%;\n    transform: scale(0.5) translateZ(0);\n}\n}\n@media (-webkit-min-device-pixel-ratio: 3), (min-device-pixel-ratio: 3) {\n.border-top-1px[data-v-1f86828e]:before {\n    width: 300%;\n    height: 300%;\n    transform: scale(0.333333333333333) translateZ(0);\n}\n}\n.border-bottom-1px[data-v-1f86828e] {\n  position: relative;\n}\n.border-bottom-1px[data-v-1f86828e]:before {\n  content: \"\";\n  pointer-events: none;\n  display: block;\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform-origin: 0 0;\n  border-bottom: 1px solid #ebebeb;\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n}\n@media (-webkit-min-device-pixel-ratio: 2), (min-device-pixel-ratio: 2) {\n.border-bottom-1px[data-v-1f86828e]:before {\n    width: 200%;\n    height: 200%;\n    transform: scale(0.5) translateZ(0);\n}\n}\n@media (-webkit-min-device-pixel-ratio: 3), (min-device-pixel-ratio: 3) {\n.border-bottom-1px[data-v-1f86828e]:before {\n    width: 300%;\n    height: 300%;\n    transform: scale(0.333333333333333) translateZ(0);\n}\n}\n.mpx-picker[data-v-1f86828e] {\n  position: fixed;\n  left: 0;\n  top: 0;\n  z-index: 100;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  text-align: center;\n  font-size: 14px;\n  background-color: rgba(37,38,45,0.4);\n}\n.mpx-picker.mpx-picker-fade-enter[data-v-1f86828e],\n.mpx-picker.mpx-picker-fade-leave-active[data-v-1f86828e] {\n  opacity: 0;\n}\n.mpx-picker.mpx-picker-fade-enter-active[data-v-1f86828e],\n.mpx-picker.mpx-picker-fade-leave-active[data-v-1f86828e] {\n  transition: all 0.3s ease-in-out;\n}\n.mpx-picker .mpx-picker-panel[data-v-1f86828e] {\n  position: absolute;\n  z-index: 600;\n  bottom: 0;\n  width: 100%;\n  height: 273px;\n  background: #fff;\n}\n.mpx-picker .mpx-picker-panel.mpx-picker-move-enter[data-v-1f86828e],\n.mpx-picker .mpx-picker-panel.mpx-picker-move-leave-active[data-v-1f86828e] {\n  transform: translate3d(0, 273px, 0);\n}\n.mpx-picker .mpx-picker-panel.mpx-picker-move-enter-active[data-v-1f86828e],\n.mpx-picker .mpx-picker-panel.mpx-picker-move-leave-active[data-v-1f86828e] {\n  transition: all 0.3s ease-in-out;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-choose[data-v-1f86828e] {\n  position: relative;\n  height: 60px;\n  color: #999;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-choose .mpx-picker-title[data-v-1f86828e] {\n  margin: 0;\n  line-height: 60px;\n  font-weight: normal;\n  text-align: center;\n  font-size: 18px;\n  color: #333;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-choose .confirm[data-v-1f86828e],\n.mpx-picker .mpx-picker-panel .mpx-picker-choose .cancel[data-v-1f86828e] {\n  position: absolute;\n  top: 6px;\n  padding: 16px;\n  font-size: 14px;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-choose .confirm[data-v-1f86828e] {\n  right: 0;\n  color: #007bff;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-choose .confirm[data-v-1f86828e]:active {\n  color: #5aaaff;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-choose .cancel[data-v-1f86828e] {\n  left: 0;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-choose .cancel[data-v-1f86828e]:active {\n  color: #c2c2c2;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-content[data-v-1f86828e] {\n  position: relative;\n  top: 20px;\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-content .mask-top[data-v-1f86828e],\n.mpx-picker .mpx-picker-panel .mpx-picker-content .mask-bottom[data-v-1f86828e] {\n  z-index: 10;\n  width: 100%;\n  height: 68px;\n  pointer-events: none;\n  transform: translateZ(0);\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-content .mask-top[data-v-1f86828e] {\n  position: absolute;\n  top: 0;\n  background: linear-gradient(to top, rgba(255,255,255,0.4), rgba(255,255,255,0.8));\n}\n.mpx-picker .mpx-picker-panel .mpx-picker-content .mask-bottom[data-v-1f86828e] {\n  position: absolute;\n  bottom: 0;\n  background: linear-gradient(to bottom, rgba(255,255,255,0.4), rgba(255,255,255,0.8));\n}\n.mpx-picker .mpx-picker-panel .wheel-wrapper[data-v-1f86828e] {\n  display: flex;\n  padding: 0 16px;\n}\n.mpx-picker .mpx-picker-panel .wheel-wrapper .wheel[data-v-1f86828e] {\n  -ms-flex: 1 1 1e-9px;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  flex: 1;\n  -webkit-flex-basis: 1e-9px;\n  flex-basis: 1e-9px;\n  width: 1%;\n  height: 173px;\n  overflow: hidden;\n  font-size: 18px;\n}\n.mpx-picker .mpx-picker-panel .wheel-wrapper .wheel .wheel-scroll[data-v-1f86828e] {\n  padding: 0;\n  margin-top: 68px;\n  line-height: 36px;\n  list-style: none;\n}\n.mpx-picker .mpx-picker-panel .wheel-wrapper .wheel .wheel-scroll .wheel-item[data-v-1f86828e] {\n  list-style: none;\n  height: 36px;\n  overflow: hidden;\n  white-space: nowrap;\n  color: #333;\n}\n", ""]);

// exports


/***/ }),
/* 282 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mab35b83a_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_style_index_0_id_5750d4a6_scoped_true_mpxStyleOptions_7B_22mid_22_3A_22mab35b83a_22_7D_lang_css_isPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(283);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mab35b83a_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_style_index_0_id_5750d4a6_scoped_true_mpxStyleOptions_7B_22mid_22_3A_22mab35b83a_22_7D_lang_css_isPage__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mab35b83a_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_style_index_0_id_5750d4a6_scoped_true_mpxStyleOptions_7B_22mid_22_3A_22mab35b83a_22_7D_lang_css_isPage__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mab35b83a_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_style_index_0_id_5750d4a6_scoped_true_mpxStyleOptions_7B_22mid_22_3A_22mab35b83a_22_7D_lang_css_isPage__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mab35b83a_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_index_mpx_vue_type_style_index_0_id_5750d4a6_scoped_true_mpxStyleOptions_7B_22mid_22_3A_22mab35b83a_22_7D_lang_css_isPage__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 283 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(284);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("3e1d6b68", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n.list[data-v-5750d4a6] {\n  background: blue;\n  height: 26.666666vw;\n}\n", ""]);

// exports


/***/ }),
/* 285 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_tab_bar_container_vue_vue_type_template_id_8b71f498___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(286);
/* harmony import */ var _mpx_tab_bar_container_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(288);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);





/* normalize component */
;
var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _mpx_tab_bar_container_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],
  _mpx_tab_bar_container_vue_vue_type_template_id_8b71f498___WEBPACK_IMPORTED_MODULE_0__.render,
  _mpx_tab_bar_container_vue_vue_type_template_id_8b71f498___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-tab-bar-container.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 286 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_container_vue_vue_type_template_id_8b71f498___WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_container_vue_vue_type_template_id_8b71f498___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_container_vue_vue_type_template_id_8b71f498___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);


/***/ }),
/* 287 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "staticRenderFns": function() { return /* binding */ staticRenderFns; }
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c
  return _c(
    "div",
    [
      _c(_vm.currentTabBarComponent, {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.showTabbar,
            expression: "showTabbar",
          },
        ],
        ref: "tabBar",
        tag: "component",
        attrs: { currentIndex: _vm.currentIndex },
        on: { change: _vm.itemChange },
      }),
      _vm._v(" "),
      _c(
        "keep-alive",
        [_c(_vm.currentComponent, { ref: "tabBarPage", tag: "component" })],
        1
      ),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 288 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_container_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(289);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_tab_bar_container_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 289 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'mpx-tab-bar-container',
  data() {
    return {
      currentIndex: 0 // 当前被选中的tabbar
    }
  },
  computed: {
    components() {
      const components = {
        'mpx-tab-bar': __webpack_require__.g.__tabBarPagesMap['mpx-tab-bar']
      }
      __webpack_require__.g.__tabBar.list.forEach(({ pagePath }) => {
        const name = pagePath.replace(/\//g, '-')
        const page = __webpack_require__.g.__tabBarPagesMap[pagePath]
        if (page) {
          components[name] = page
        } else {
          console.warn(
            `[Mpx runtime warn]: TabBar page path ${pagePath} is not exist in local page map, please check!`
          )
        }
      })
      return components
    },
    showTabbar() {
      return __webpack_require__.g.__tabBar.isShow
    },
    currentComponent() {
      const index = this.currentIndex
      const tabItem = __webpack_require__.g.__tabBar.list[index]
      return this.components[tabItem.pagePath.replace(/\//g, '-')]
    },
    currentTabBarComponent() {
      return this.components['mpx-tab-bar']
    }
  },
  watch: {
    $route: {
      handler(to) {
        this.setCurrentIndex(to.path)
      },
      immediate: true
    }
  },
  methods: {
    itemChange(item, index) {
      const mpx = __webpack_require__.g.__mpx
      if (mpx && mpx.switchTab) {
        const pagePath = '/' + __webpack_require__.g.__tabBar.list[index].pagePath
        mpx.switchTab({
          url: pagePath
        })
      } else {
        this.currentIndex = index
      }
      this.$refs.tabBarPage &&
        this.$refs.tabBarPage.onTabItemTap &&
        this.$refs.tabBarPage.onTabItemTap(item)
    },
    setCurrentIndex(path) {
      __webpack_require__.g.__tabBar.list.forEach((item, index) => {
        const pagePath = '/' + item.pagePath
        if (pagePath === path) {
          this.currentIndex = index
        }
      })
    }
  }
});


/***/ }),
/* 290 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _other_mpx_vue_type_template_id_93e9cb2a_isPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(291);
/* harmony import */ var _other_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(293);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);





/* normalize component */
;
var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__["default"])(
  _other_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_1__["default"],
  _other_mpx_vue_type_template_id_93e9cb2a_isPage__WEBPACK_IMPORTED_MODULE_0__.render,
  _other_mpx_vue_type_template_id_93e9cb2a_isPage__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/packages/pages/other.mpx"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 291 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_other_mpx_vue_type_template_id_93e9cb2a_isPage__WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_other_mpx_vue_type_template_id_93e9cb2a_isPage__WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_other_mpx_vue_type_template_id_93e9cb2a_isPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(292);


/***/ }),
/* 292 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "staticRenderFns": function() { return /* binding */ staticRenderFns; }
/* harmony export */ });
var render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c("div", [_vm._v("other.mpx")]);
};
var staticRenderFns = [];
render._withStripped = true;


/***/ }),
/* 293 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_other_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(294);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_babel_loader_8_3_0_qoaxtqicpzj5p3ubthw53xafqm_node_modules_babel_loader_lib_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_other_mpx_vue_type_script_lang_js_isPage__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 294 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

var wxsModules = {};
__webpack_require__.g.currentModuleId = "mba49ae16";
__webpack_require__.g.currentSrcMode = "wx";
__webpack_require__.g.currentResource = "/Users/didi/Documents/Work/Code/mpx/examples/mpx-transform-web/src/packages/pages/other.mpx";
/** script content **/
__webpack_require__(295);
var currentOption = __webpack_require__.g.__mpxOptionsMap["mba49ae16"];
/* harmony default export */ __webpack_exports__["default"] = ((0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__["default"])({
  option: currentOption,
  ctorType: "page",
  firstPage: undefined,
  outputPath: "",
  pageConfig: {
    "path": "/Users/didi/Documents/Work/Code/mpx/examples/mpx-transform-web/src/packages/pages"
  },
  // @ts-ignore
  pagesMap: {},
  // @ts-ignore
  componentsMap: {},
  tabBarMap: {},
  componentGenerics: {},
  genericsInfo: undefined,
  mixin: (0,_mpxjs_web_plugin_src_runtime_optionProcessor__WEBPACK_IMPORTED_MODULE_0__.getWxsMixin)(wxsModules),
  hasApp: true
}));

/***/ }),
/* 295 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpxjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);

(0,_mpxjs_core__WEBPACK_IMPORTED_MODULE_0__["default"])({});

/***/ }),
/* 296 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mpx_keep_alive_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(297);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
var render, staticRenderFns
;



/* normalize component */
;
var component = (0,_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__["default"])(
  _mpx_keep_alive_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "packages/web-plugin/src/runtime/components/web/mpx-keep-alive.vue"
/* harmony default export */ __webpack_exports__["default"] = (component.exports);

/***/ }),
/* 297 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_keep_alive_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(298);
 /* harmony default export */ __webpack_exports__["default"] = (_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_vue_loader_options_mpx_keep_alive_vue_vue_type_script_lang_js_isComponent__WEBPACK_IMPORTED_MODULE_0__["default"]); 

/***/ }),
/* 298 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);

  

  function isDef (v) {
    return v !== undefined && v !== null
  }

  function remove (arr, item) {
    if (arr.length) {
      const index = arr.indexOf(item)
      if (index > -1) {
        return arr.splice(index, 1)
      }
    }
  }

  function isAsyncPlaceholder (node) {
    return node.isComment && node.asyncFactory
  }

  function getFirstComponentChild (children) {
    if (Array.isArray(children)) {
      for (let i = 0; i < children.length; i++) {
        const c = children[i]
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c
        }
      }
    }
  }

  function getVnodeKey (vnode) {
    if (vnode && vnode.componentOptions) {
      return vnode.componentOptions.Ctor.cid + (vnode.componentOptions.tag ? ('::' + (vnode.componentOptions.tag)) : '')
    }
  }

  /* harmony default export */ __webpack_exports__["default"] = ({
    name: 'mpx-keep-alive',
    abstract: true,
    render: function render () {
      const slot = this.$slots.default
      const vnode = getFirstComponentChild(slot)
      if (!_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser) {
        return vnode || (slot && slot[0])
      }
      const vnodeKey = getVnodeKey(vnode)
      const router = __webpack_require__.g.__mpxRouter
      if (vnodeKey && router && vnode.data.routerView) {
        if (router.needCache) {
          router.needCache.vnode = vnode
          router.needCache.vnodeKey = vnodeKey
          router.needCache = null
        }

        router.needRemove.forEach((removeItem) => {
          if (
            removeItem.vnode &&
            removeItem.vnode.componentInstance &&
            !removeItem.vnode.componentInstance._isDestroyed &&
            router.stack.every((item) => {
              return !(item.vnode && item.vnode.componentInstance === removeItem.vnode.componentInstance)
            })
          ) {
            removeItem.vnode.componentInstance.$destroy()
          }
        })
        router.needRemove.length = 0

        const stack = router.stack
        if (stack.length) {
          // 只要历史栈缓存中存在对应的页面存活实例，就进行复用
          for (let i = stack.length; i > 0; i--) {
            const current = stack[i - 1]
            if (current.vnode && current.vnodeKey === vnodeKey && current.vnode.componentInstance) {
              vnode.componentInstance = current.vnode.componentInstance
              // 避免组件实例复用但是vnode.key不一致带来的bad case
              vnode.key = current.vnode.key
              break
            }
          }
        }

        if (router.__mpxAction) {
          if (router.__mpxAction.type === 'reLaunch') {
            // reLaunch时修改新vnode的key, 确保任何情况下都新创建组件实例
            vnode.key = (vnode.key || '') + router.__mpxAction.reLaunchCount
          }
          router.__mpxAction = null
        }
        vnode.data.keepAlive = true
      }

      router.__mpxActiveVnode = vnode
      return vnode || (slot && slot[0])
    }
  });


/***/ }),
/* 299 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mpx_app_scope_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_style_index_0_id_5ef46707_mpxStyleOptions_7B_22mid_22_3A_22mpx_app_scope_22_7D_lang_css_isApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(300);
/* harmony import */ var _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mpx_app_scope_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_style_index_0_id_5ef46707_mpxStyleOptions_7B_22mid_22_3A_22mpx_app_scope_22_7D_lang_css_isApp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mpx_app_scope_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_style_index_0_id_5ef46707_mpxStyleOptions_7B_22mid_22_3A_22mpx_app_scope_22_7D_lang_css_isApp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mpx_app_scope_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_style_index_0_id_5ef46707_mpxStyleOptions_7B_22mid_22_3A_22mpx_app_scope_22_7D_lang_css_isApp__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _node_modules_pnpm_vue_style_loader_4_1_3_node_modules_vue_style_loader_index_js_node_modules_pnpm_css_loader_0_28_11_node_modules_css_loader_index_js_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_loaders_stylePostLoader_js_packages_loaders_dist_style_loader_js_mid_mpx_app_scope_node_modules_pnpm_vue_loader_15_10_1_tol3wgcfbjl54e2ppfs7m6pkna_node_modules_vue_loader_lib_index_js_clonedRuleSet_5_use_0_packages_web_plugin_dist_webpack_loader_web_loader_js_clonedRuleSet_5_use_1_app_mpx_vue_type_style_index_0_id_5ef46707_mpxStyleOptions_7B_22mid_22_3A_22mpx_app_scope_22_7D_lang_css_isApp__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),
/* 300 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(301);
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = (__webpack_require__(13)["default"])
var update = add("dfa15a82", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(12)(false);
// imports


// module
exports.push([module.id, "\n\n\n\n\n\n\n\n\n\n\n/*此处编写全局样式*/\nbody {\n  box-sizing: border-box;\n  color: #333999;\n}\n", ""]);

// exports


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "mpx-transform-web-demo:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 				if (script.src.indexOf(window.location.origin + '/') !== 0) {
/******/ 					script.crossOrigin = "anonymous";
/******/ 				}
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			};
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			0: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkmpx_transform_web_demo"] = self["webpackChunkmpx_transform_web_demo"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _app_mpx_isApp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);



new vue__WEBPACK_IMPORTED_MODULE_1__["default"]({
  el: '#app',
  render: function(h){
    return h(_app_mpx_isApp__WEBPACK_IMPORTED_MODULE_0__["default"])
  }
})


}();
/******/ })()
;
//# sourceMappingURL=app.js.map